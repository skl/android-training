SCRIPT  /usr/share/vim/vim73/scripts.vim
Sourced 1 time
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2010 Sep 22
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000004 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000006 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000010 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000006 let s:line1 = getline(1)
                            
    1              0.000005 if s:line1 =~ "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~ '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~ '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~ '^csh\>'
                                if exists("g:filetype_csh")
                                  call SetFileTypeShell(g:filetype_csh)
                                else
                                  call SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~ '^tcsh\>'
                                call SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~ '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~ '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~ '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~ 'make\>'
                                set ft=make
                            
                                " Lua
                              elseif s:name =~ 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~ 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~ 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~ 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~ 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~ '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~ 'ruby'
                                set ft=ruby
                            
                                " BC calculator
                              elseif s:name =~ '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~ 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~ 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~ 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~ 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~ 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~ 'cfengine'
                                set ft=cfengine
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    1              0.000004   let s:line2 = getline(2)
    1              0.000003   let s:line3 = getline(3)
    1              0.000003   let s:line4 = getline(4)
    1              0.000003   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000004   if s:line1 =~ '^:$'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~ '^#compdef\>' || s:line1 =~ '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~ '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~ '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                              elseif s:line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\)'
                            	\ || (s:line1 =~ '^--- ' && s:line2 =~ '^+++ ')
                            	\ || (s:line1 =~ '^\* looking for ' && s:line2 =~ '^\* comparing to ')
                            	\ || (s:line1 =~ '^\*\*\* ' && s:line2 =~ '^--- ')
                            	\ || (s:line1 =~ '^=== ' && ((s:line2 =~ '^=\{66\}' && s:line3 =~ '^--- ' && s:line4 =~ '^+++') || (s:line2 =~ '^--- ' && s:line3 =~ '^+++ ')))
                            	\ || (s:line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~ '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~ '^\s*dnl\>'
                            	\ || s:line2 =~ '^\s*dnl\>'
                            	\ || s:line3 =~ '^\s*dnl\>'
                            	\ || s:line4 =~ '^\s*dnl\>'
                            	\ || s:line5 =~ '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
                              elseif $TERM == "amiga"
                            	\ && (s:line1 =~ "^;" || s:line1 =~ '^\.[bB][rR][aA]')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~ '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~ '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~ '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                              elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~ '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~ '^RCS file:' || s:line2 =~ '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~ '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~ '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~ '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~ '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~ '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~ '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~ '^\(\[pid \d\+\] \)\=[0-9:.]* *execve(' || s:line1 =~ '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~ '^\* $$ JOB\>' || s:line1 =~ '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~ 'K & K  Associates' || s:line2 =~ 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~ 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~ '|\*\{1,80}' && s:line2 =~ 'VRC '
                            	\ || s:line2 =~ '|\*\{1,80}' && s:line3 =~ 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~ '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~ 'exec\s\+\S*scheme' || s:line2 =~ 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " rst files
                              elseif s:line1 =~ '^\.\.\s\|^\s*restindex\s*$'
                            	\ || s:line2 =~ '^\.\.\s\|^\s*restindex\s*$'
                            	\ || s:line3 =~ '^\.\.\s\|^\s*restindex\s*$'
                            	\ || s:line4 =~ '^\.\.\s\|^\s*restindex\s*$'
                            	\ || s:line5 =~ '^\.\.\s\|^\s*restindex\s*$'
                                set ft=rst
                            
                              " Git output
                              elseif s:line1 =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                              " CVS diff
                              else
    1              0.000003     let s:lnum = 1
    1              0.000006     while getline(s:lnum) =~ "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    1              0.000005     if getline(s:lnum) =~ '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    1              0.000002     unlet s:lnum
                            
    1              0.000001   endif
                            
    1              0.000003   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000009 let &cpo = s:cpo_save
                            
    1              0.000003 unlet s:cpo_save s:line1

SCRIPT  /home/skl/.vim/bundle/nerdtree/syntax/nerdtree.vim
Sourced 3 times
Total time:   0.001866
 Self time:   0.001866

count  total (s)   self (s)
                            let s:tree_up_dir_line = '.. (up a dir)'
                            "NERDTreeFlags are syntax items that should be invisible, but give clues as to
                            "how things should be highlighted
    3              0.000042 syn match NERDTreeFlag #\~#
    3              0.000020 syn match NERDTreeFlag #\[RO\]#
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    3              0.000035 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "highlighting for the ~/+ symbols for the directory nodes
    3              0.000018 syn match NERDTreeClosable #\~\<#
    3              0.000015 syn match NERDTreeClosable #\~\.#
    3              0.000014 syn match NERDTreeOpenable #+\<#
    3              0.000016 syn match NERDTreeOpenable #+\.#he=e-1
                            
                            "highlighting for the tree structural parts
    3              0.000016 syn match NERDTreePart #|#
    3              0.000013 syn match NERDTreePart #`#
    3              0.000036 syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart
                            
                            "quickhelp syntax elements
    3              0.000025 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#hs=s+2,he=e-1
    3              0.000020 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#hs=s+2,he=e-1
    3              0.000049 syn match NERDTreeHelpTitle #" .*\~#hs=s+2,he=e-1 contains=NERDTreeFlag
    3              0.000035 syn match NERDTreeToggleOn #".*(on)#hs=e-2,he=e-1 contains=NERDTreeHelpKey
    3              0.000032 syn match NERDTreeToggleOff #".*(off)#hs=e-3,he=e-1 contains=NERDTreeHelpKey
    3              0.000022 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    3              0.000102 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeFlag,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for readonly files
    3              0.000075 syn match NERDTreeRO #.*\[RO\]#hs=s+2 contains=NERDTreeFlag,NERDTreeBookmark,NERDTreePart,NERDTreePartFile
                            
                            "highlighting for sym links
    3              0.000076 syn match NERDTreeLink #[^-| `].* -> # contains=NERDTreeBookmark,NERDTreeOpenable,NERDTreeClosable,NERDTreeDirSlash
                            
                            "highlighing for directory nodes and file nodes
    3              0.000016 syn match NERDTreeDirSlash #/#
    3              0.000075 syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeDirSlash,NERDTreeOpenable,NERDTreeClosable
    3              0.000092 syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark
    3              0.000099 syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
    3              0.000099 syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
    3              0.000018 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    3              0.000016 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    3              0.000015 syn match NERDTreeBookmarksLeader #^>#
    3              0.000036 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    3              0.000032 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    3              0.000060 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    3              0.000021 if exists("g:NERDChristmasTree") && g:NERDChristmasTree
    3              0.000030     hi def link NERDTreePart Special
    3              0.000021     hi def link NERDTreePartFile Type
    3              0.000020     hi def link NERDTreeFile Normal
    3              0.000020     hi def link NERDTreeExecFile Title
    3              0.000019     hi def link NERDTreeDirSlash Identifier
    3              0.000019     hi def link NERDTreeClosable Type
    3              0.000003 else
                                hi def link NERDTreePart Normal
                                hi def link NERDTreePartFile Normal
                                hi def link NERDTreeFile Normal
                                hi def link NERDTreeClosable Title
                            endif
                            
    3              0.000020 hi def link NERDTreeBookmarksHeader statement
    3              0.000021 hi def link NERDTreeBookmarksLeader ignore
    3              0.000020 hi def link NERDTreeBookmarkName Identifier
    3              0.000019 hi def link NERDTreeBookmark normal
                            
    3              0.000019 hi def link NERDTreeHelp String
    3              0.000021 hi def link NERDTreeHelpKey Identifier
    3              0.000019 hi def link NERDTreeHelpCommand Identifier
    3              0.000026 hi def link NERDTreeHelpTitle Macro
    3              0.000023 hi def link NERDTreeToggleOn Question
    3              0.000020 hi def link NERDTreeToggleOff WarningMsg
                            
    3              0.000020 hi def link NERDTreeDir Directory
    3              0.000020 hi def link NERDTreeUp Directory
    3              0.000020 hi def link NERDTreeCWD Statement
    3              0.000020 hi def link NERDTreeLink Macro
    3              0.000020 hi def link NERDTreeOpenable Title
    3              0.000019 hi def link NERDTreeFlag ignore
    3              0.000020 hi def link NERDTreeRO WarningMsg
    3              0.000020 hi def link NERDTreeBookmark Statement
                            
    3              0.000026 hi def link NERDTreeCurrentNode Search

SCRIPT  /usr/share/vim/vim73/ftplugin/xml.vim
Sourced 2 times
Total time:   0.000373
 Self time:   0.000373

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	xml
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    2              0.000016 if exists("b:did_ftplugin") | finish | endif
    2              0.000008 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    2              0.000017 let s:save_cpo = &cpo
    2              0.000024 set cpo-=C
                            
    2              0.000008 setlocal commentstring=<!--%s-->
    2              0.000007 setlocal comments=s:<!--,m:\ \ \ \ \ ,e:-->
                            
    2              0.000006 setlocal formatoptions-=t
    2              0.000011 if !exists("g:ft_xml_autocomment") || (g:ft_xml_autocomment == 1)
    2              0.000008     setlocal formatoptions+=croql
    2              0.000003 endif
                            
                            
                            " XML:  thanks to Johannes Zellner and Akbar Ibrahim
                            " - case sensitive
                            " - don't match empty tags <fred/>
                            " - match <!--, --> style comments (but not --, --)
                            " - match <!, > inlined dtd's. This is not perfect, as it
                            "   gets confused for example by
                            "       <!ENTITY gt ">">
    2              0.000007 if exists("loaded_matchit")
    2              0.000008     let b:match_ignorecase=0
    2              0.000021     let b:match_words =
                                 \  '<:>,' .
                                 \  '<\@<=!\[CDATA\[:]]>,'.
                                 \  '<\@<=!--:-->,'.
                                 \  '<\@<=?\k\+:?>,'.
                                 \  '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'.
                                 \  '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
    2              0.000004 endif
                            
                            "
                            " For Omni completion, by Mikolaj Machowski.
    2              0.000013 if exists('&ofu')
    2              0.000014   setlocal ofu=xmlcomplete#CompleteTags
    2              0.000002 endif
    2              0.000061 command! -nargs=+ XMLns call xmlcomplete#CreateConnection(<f-args>)
    2              0.000030 command! -nargs=? XMLent call xmlcomplete#CreateEntConnection(<f-args>)
                            
                            
                            " Change the :browse e filter to primarily show xml-related files.
    2              0.000013 if has("gui_win32")
                                let  b:browsefilter="XML Files (*.xml)\t*.xml\n" .
                            		\	"DTD Files (*.dtd)\t*.dtd\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    2              0.000013 let b:undo_ftplugin = "setlocal commentstring< comments< formatoptions<" .
                            		\     " | unlet! b:match_ignorecase b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    2              0.000023 let &cpo = s:save_cpo
    2              0.000008 unlet s:save_cpo

SCRIPT  /usr/share/vim/vim73/indent/xml.vim
Sourced 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                            " Language:	xml
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            " Last Change:	2012 May 18
                            " Notes:	1) does not indent pure non-xml code (e.g. embedded scripts)
                            "		2) will be confused by unbalanced tags in comments
                            "		or CDATA sections.
                            "		2009-05-26 patch by Nikolai Weibull
                            " TODO: 	implement pre-like tags, see xml_indent_open / xml_indent_close
                            
                            " Only load this indent file when no other was loaded.
    2              0.000011 if exists("b:did_indent")
                                finish
                            endif
    2              0.000006 let b:did_indent = 1
    2              0.000016 let s:keepcpo= &cpo
    2              0.000022 set cpo&vim
                            
                            " [-- local settings (must come before aborting the script) --]
    2              0.000005 setlocal indentexpr=XmlIndentGet(v:lnum,1)
    2              0.000005 setlocal indentkeys=o,O,*<Return>,<>>,<<>,/,{,}
                            
    2              0.000007 if !exists('b:xml_indent_open')
    2              0.000007     let b:xml_indent_open = '.\{-}<\a'
                                " pre tag, e.g. <address>
                                " let b:xml_indent_open = '.\{-}<[/]\@!\(address\)\@!'
    2              0.000002 endif
                            
    2              0.000006 if !exists('b:xml_indent_close')
    2              0.000006     let b:xml_indent_close = '.\{-}</'
                                " end pre tag, e.g. </address>
                                " let b:xml_indent_close = '.\{-}</\(address\)\@!'
    2              0.000004 endif
                            
                            " [-- finish, if the function already exists --]
    2              0.000010 if exists('*XmlIndentGet') | finish | endif

SCRIPT  /usr/share/vim/vim73/syntax/xml.vim
Sourced 2 times
Total time:   0.003072
 Self time:   0.001828

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	XML
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            "		Author and previous maintainer:
                            "		Paul Siegmann <pauls@euronet.nl>
                            " Last Change:	2009-07-13 21:26:55
                            " Filenames:	*.xml
                            " $Id: xml.vim,v 1.3 2006/04/11 21:32:00 vimboss Exp $
                            
                            " CONFIGURATION:
                            "   syntax folding can be turned on by
                            "
                            "      let g:xml_syntax_folding = 1
                            "
                            "   before the syntax file gets loaded (e.g. in ~/.vimrc).
                            "   This might slow down syntax highlighting significantly,
                            "   especially for large files.
                            "
                            " CREDITS:
                            "   The original version was derived by Paul Siegmann from
                            "   Claudio Fleiner's html.vim.
                            "
                            " REFERENCES:
                            "   [1] http://www.w3.org/TR/2000/REC-xml-20001006
                            "   [2] http://www.w3.org/XML/1998/06/xmlspec-report-19980910.htm
                            "
                            "   as <hirauchi@kiwi.ne.jp> pointed out according to reference [1]
                            "
                            "   2.3 Common Syntactic Constructs
                            "   [4]    NameChar    ::=    Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender
                            "   [5]    Name        ::=    (Letter | '_' | ':') (NameChar)*
                            "
                            " NOTE:
                            "   1) empty tag delimiters "/>" inside attribute values (strings)
                            "      confuse syntax highlighting.
                            "   2) for large files, folding can be pretty slow, especially when
                            "      loading a file the first time and viewoptions contains 'folds'
                            "      so that folds of previous sessions are applied.
                            "      Don't use 'foldmethod=syntax' in this case.
                            
                            
                            " Quit when a syntax file was already loaded
    2              0.000010 if exists("b:current_syntax")
                                finish
                            endif
                            
    2              0.000016 let s:xml_cpo_save = &cpo
    2              0.000017 set cpo&vim
                            
    2              0.000004 syn case match
                            
                            " mark illegal characters
    2              0.000029 syn match xmlError "[<&]"
                            
                            " strings (inside tags) aka VALUES
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "                      ^^^^^^^
    2              0.000030 syn region  xmlString contained start=+"+ end=+"+ contains=xmlEntity,@Spell display
    2              0.000023 syn region  xmlString contained start=+'+ end=+'+ contains=xmlEntity,@Spell display
                            
                            
                            " punctuation (within attributes) e.g. <tag xml:foo.attribute ...>
                            "                                              ^   ^
                            " syn match   xmlAttribPunct +[-:._]+ contained display
    2              0.000011 syn match   xmlAttribPunct +[:.]+ contained display
                            
                            " no highlighting for xmlEqual (xmlEqual has no highlighting group)
    2              0.000009 syn match   xmlEqual +=+ display
                            
                            
                            " attribute, everything before the '='
                            "
                            " PROVIDES: @xmlAttribHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "      ^^^^^^^^^^^^^
                            "
    2              0.000042 syn match   xmlAttrib
                                \ +[-'"<]\@<!\<[a-zA-Z:_][-.0-9a-zA-Z0-9:_]*\>\(['">]\@!\|$\)+
                                \ contained
                                \ contains=xmlAttribPunct,@xmlAttribHook
                                \ display
                            
                            
                            " namespace spec
                            "
                            " PROVIDES: @xmlNamespaceHook
                            "
                            " EXAMPLE:
                            "
                            " <xsl:for-each select = "lola">
                            "  ^^^
                            "
    2              0.000008 if exists("g:xml_namespace_transparent")
                            syn match   xmlNamespace
                                \ +\(<\|</\)\@<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ transparent
                                \ display
                            else
    2              0.000023 syn match   xmlNamespace
                                \ +\(<\|</\)\@<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ display
    2              0.000002 endif
                            
                            
                            " tag name
                            "
                            " PROVIDES: @xmlTagHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "  ^^^
                            "
    2              0.000034 syn match   xmlTagName
                                \ +[<]\@<=[^ /!?<>"']\++
                                \ contained
                                \ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                                \ display
                            
                            
    2              0.000008 if exists('g:xml_syntax_folding')
                            
                                " start tag
                                " use matchgroup=xmlTag to skip over the leading '<'
                                "
                                " PROVIDES: @xmlStartTagHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                " s^^^^^^^^^^^^^^^e
                                "
    2              0.000074     syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
                            
                                " highlight the end tag
                                "
                                " PROVIDES: @xmlTagHook
                                " (should we provide a separate @xmlEndTagHook ?)
                                "
                                " EXAMPLE:
                                "
                                " </tag>
                                " ^^^^^^
                                "
    2              0.000033     syn match   xmlEndTag
                            	\ +</[^ /!?<>"']\+>+
                            	\ contained
                            	\ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
                            
                                " tag elements with syntax-folding.
                                " NOTE: NO HIGHLIGHTING -- highlighting is done by contained elements
                                "
                                " PROVIDES: @xmlRegionHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                "   <!-- comment -->
                                "   <another.tag></another.tag>
                                "   <empty.tag/>
                                "   some data
                                " </tag>
                                "
    2              0.000102     syn region   xmlRegion
                            	\ start=+<\z([^ /!?<>"']\+\)+
                            	\ skip=+<!--\_.\{-}-->+
                            	\ end=+</\z1\_\s\{-}>+
                            	\ matchgroup=xmlEndTag end=+/>+
                            	\ fold
                            	\ contains=xmlTag,xmlEndTag,xmlCdata,xmlRegion,xmlComment,xmlEntity,xmlProcessing,@xmlRegionHook,@Spell
                            	\ keepend
                            	\ extend
                            
    2              0.000004 else
                            
                                " no syntax folding:
                                " - contained attribute removed
                                " - xmlRegion not defined
                                "
                                syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
                                syn match   xmlEndTag
                            	\ +</[^ /!?<>"']\+>+
                            	\ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
                            endif
                            
                            
                            " &entities; compare with dtd
    2              0.000022 syn match   xmlEntity                 "&[^; \t]*;" contains=xmlEntityPunct
    2              0.000010 syn match   xmlEntityPunct  contained "[&.;]"
                            
    2              0.000008 if exists('g:xml_syntax_folding')
                            
                                " The real comments (this implements the comments as defined by xml,
                                " but not all xml pages actually conform to it. Errors are flagged.
    2              0.000037     syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            	\ fold
                            
    2              0.000002 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
                                syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            
                            endif
                            
    2              0.000020 syn match xmlCommentStart   contained "<!" nextgroup=xmlCommentPart
    2              0.000014 syn keyword xmlTodo         contained TODO FIXME XXX
    2              0.000010 syn match   xmlCommentError contained "[^><!]"
    2              0.000029 syn region  xmlCommentPart
                                \ start=+--+
                                \ end=+--+
                                \ contained
                                \ contains=xmlTodo,@xmlCommentHook,@Spell
                            
                            
                            " CData sections
                            "
                            " PROVIDES: @xmlCdataHook
                            "
    2              0.000040 syn region    xmlCdata
                                \ start=+<!\[CDATA\[+
                                \ end=+]]>+
                                \ contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook,@Spell
                                \ keepend
                                \ extend
                            
                            " using the following line instead leads to corrupt folding at CDATA regions
                            " syn match    xmlCdata      +<!\[CDATA\[\_.\{-}]]>+  contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook
    2              0.000019 syn match    xmlCdataStart +<!\[CDATA\[+  contained contains=xmlCdataCdata
    2              0.000009 syn keyword  xmlCdataCdata CDATA          contained
    2              0.000010 syn match    xmlCdataEnd   +]]>+          contained
                            
                            
                            " Processing instructions
                            " This allows "?>" inside strings -- good idea?
    2              0.000042 syn region  xmlProcessing matchgroup=xmlProcessingDelim start="<?" end="?>" contains=xmlAttrib,xmlEqual,xmlString
                            
                            
    2              0.000009 if exists('g:xml_syntax_folding')
                            
                                " DTD -- we use dtd.vim here
    2              0.000048     syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ fold
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
    2              0.000002 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
                                syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
                            
                            endif
                            
    2              0.000012 syn keyword xmlDocTypeKeyword contained DOCTYPE PUBLIC SYSTEM
    2              0.000020 syn region  xmlInlineDTD contained matchgroup=xmlDocTypeDecl start="\[" end="]" contains=@xmlDTD
    2              0.000057 syn include @xmlDTD <sfile>:p:h/dtd.vim
    2              0.000005 unlet b:current_syntax
                            
                            
                            " synchronizing
                            " TODO !!! to be improved !!!
                            
    2              0.000025 syn sync match xmlSyncDT grouphere  xmlDocType +\_.\(<!DOCTYPE\)\@=+
                            " syn sync match xmlSyncDT groupthere  NONE       +]>+
                            
    2              0.000010 if exists('g:xml_syntax_folding')
    2              0.000021     syn sync match xmlSync grouphere   xmlRegion  +\_.\(<[^ /!?<>"']\+\)\@=+
                                " syn sync match xmlSync grouphere  xmlRegion "<[^ /!?<>"']*>"
    2              0.000017     syn sync match xmlSync groupthere  xmlRegion  +</[^ /!?<>"']\+>+
    2              0.000002 endif
                            
    2              0.000004 syn sync minlines=100
                            
                            
                            " The default highlighting.
    2              0.000014 hi def link xmlTodo		Todo
    2              0.000014 hi def link xmlTag		Function
    2              0.000012 hi def link xmlTagName		Function
    2              0.000012 hi def link xmlEndTag		Identifier
    2              0.000010 if !exists("g:xml_namespace_transparent")
    2              0.000013     hi def link xmlNamespace	Tag
    2              0.000001 endif
    2              0.000012 hi def link xmlEntity		Statement
    2              0.000011 hi def link xmlEntityPunct	Type
                            
    2              0.000012 hi def link xmlAttribPunct	Comment
    2              0.000012 hi def link xmlAttrib		Type
                            
    2              0.000012 hi def link xmlString		String
    2              0.000012 hi def link xmlComment		Comment
    2              0.000010 hi def link xmlCommentStart	xmlComment
    2              0.000012 hi def link xmlCommentPart	Comment
    2              0.000015 hi def link xmlCommentError	Error
    2              0.000012 hi def link xmlError		Error
                            
    2              0.000012 hi def link xmlProcessingDelim	Comment
    2              0.000011 hi def link xmlProcessing	Type
                            
    2              0.000012 hi def link xmlCdata		String
    2              0.000012 hi def link xmlCdataCdata	Statement
    2              0.000011 hi def link xmlCdataStart	Type
    2              0.000021 hi def link xmlCdataEnd		Type
                            
    2              0.000012 hi def link xmlDocTypeDecl	Function
    2              0.000013 hi def link xmlDocTypeKeyword	Statement
    2              0.000012 hi def link xmlInlineDTD	Function
                            
    2              0.000007 let b:current_syntax = "xml"
                            
    2              0.000032 let &cpo = s:xml_cpo_save
    2              0.000004 unlet s:xml_cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim73/syntax/dtd.vim
Sourced 2 times
Total time:   0.001238
 Self time:   0.001238

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	DTD (Document Type Definition for XML)
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            "		Author and previous maintainer:
                            "		Daniel Amyot <damyot@site.uottawa.ca>
                            " Last Change:	Tue, 27 Apr 2004 14:54:59 CEST
                            " Filenames:	*.dtd
                            "
                            " REFERENCES:
                            "   http://www.w3.org/TR/html40/
                            "   http://www.w3.org/TR/NOTE-html-970421
                            "
                            " TODO:
                            "   - improve synchronizing.
                            
    2              0.000010 if exists("b:current_syntax")
                                finish
                            endif
    2              0.000020 let s:dtd_cpo_save = &cpo
    2              0.000021 set cpo&vim
                            
    2              0.000008 if !exists("dtd_ignore_case")
                                " I prefer having the case takes into consideration.
    2              0.000005     syn case match
    2              0.000002 else
                                syn case ignore
                            endif
                            
                            
                            " the following line makes the opening <! and
                            " closing > highlighted using 'dtdFunction'.
                            "
                            " PROVIDES: @dtdTagHook
                            "
    2              0.000111 syn region dtdTag matchgroup=dtdFunction
                                \ start=+<!+ end=+>+ matchgroup=NONE
                                \ contains=dtdTag,dtdTagName,dtdError,dtdComment,dtdString,dtdAttrType,dtdAttrDef,dtdEnum,dtdParamEntityInst,dtdParamEntityDecl,dtdCard,@dtdTagHook
                            
    2              0.000007 if !exists("dtd_no_tag_errors")
                                " mark everything as an error which starts with a <!
                                " and is not overridden later. If this is annoying,
                                " it can be switched off by setting the variable
                                " dtd_no_tag_errors.
    2              0.000015     syn region dtdError contained start=+<!+lc=2 end=+>+
    2              0.000002 endif
                            
                            " if this is a html like comment hightlight also
                            " the opening <! and the closing > as Comment.
    2              0.000032 syn region dtdComment		start=+<![ \t]*--+ end=+-->+ contains=dtdTodo,@Spell
                            
                            
                            " proper DTD comment
    2              0.000022 syn region dtdComment contained start=+--+ end=+--+ contains=dtdTodo,@Spell
                            
                            
                            " Start tags (keywords). This is contained in dtdFunction.
                            " Note that everything not contained here will be marked
                            " as error.
    2              0.000026 syn match dtdTagName contained +<!\(ATTLIST\|DOCTYPE\|ELEMENT\|ENTITY\|NOTATION\|SHORTREF\|USEMAP\|\[\)+lc=2,hs=s+2
                            
                            
                            " wildcards and operators
    2              0.000008 syn match  dtdCard contained "|"
    2              0.000009 syn match  dtdCard contained ","
                            " evenutally overridden by dtdEntity
    2              0.000008 syn match  dtdCard contained "&"
    2              0.000009 syn match  dtdCard contained "?"
    2              0.000008 syn match  dtdCard contained "\*"
    2              0.000010 syn match  dtdCard contained "+"
                            
                            " ...and finally, special cases.
    2              0.000010 syn match  dtdCard      "ANY"
    2              0.000011 syn match  dtdCard      "EMPTY"
                            
    2              0.000007 if !exists("dtd_no_param_entities")
                            
                                " highlight parameter entity declarations
                                " and instances. Note that the closing `;'
                                " is optional.
                            
                                " instances
    2              0.000041     syn region dtdParamEntityInst oneline matchgroup=dtdParamEntityPunct
                            	\ start="%[-_a-zA-Z0-9.]\+"he=s+1,rs=s+1
                            	\ skip=+[-_a-zA-Z0-9.]+
                            	\ end=";\|\>"
                            	\ matchgroup=NONE contains=dtdParamEntityPunct
    2              0.000011     syn match  dtdParamEntityPunct contained "\."
                            
                                " declarations
                                " syn region dtdParamEntityDecl oneline matchgroup=dtdParamEntityDPunct start=+<!ENTITY % +lc=8 skip=+[-_a-zA-Z0-9.]+ matchgroup=NONE end="\>" contains=dtdParamEntityDPunct
    2              0.000025     syn match dtdParamEntityDecl +<!ENTITY % [-_a-zA-Z0-9.]*+lc=8 contains=dtdParamEntityDPunct
    2              0.000011     syn match  dtdParamEntityDPunct contained "%\|\."
                            
    2              0.000003 endif
                            
                            " &entities; compare with xml
    2              0.000023 syn match   dtdEntity		      "&[^; \t]*;" contains=dtdEntityPunct
    2              0.000011 syn match   dtdEntityPunct  contained "[&.;]"
                            
                            " Strings are between quotes
    2              0.000063 syn region dtdString    start=+"+ skip=+\\\\\|\\"+  end=+"+ contains=dtdAttrDef,dtdAttrType,dtdEnum,dtdParamEntityInst,dtdEntity,dtdCard
    2              0.000061 syn region dtdString    start=+'+ skip=+\\\\\|\\'+  end=+'+ contains=dtdAttrDef,dtdAttrType,dtdEnum,dtdParamEntityInst,dtdEntity,dtdCard
                            
                            " Enumeration of elements or data between parenthesis
                            "
                            " PROVIDES: @dtdEnumHook
                            "
    2              0.000043 syn region dtdEnum matchgroup=dtdType start="(" end=")" matchgroup=NONE contains=dtdEnum,dtdParamEntityInst,dtdCard,@dtdEnumHook
                            
                            "Attribute types
    2              0.000012 syn keyword dtdAttrType NMTOKEN  ENTITIES  NMTOKENS  ID  CDATA
    2              0.000010 syn keyword dtdAttrType IDREF  IDREFS
                            " ENTITY has to treated special for not overriding <!ENTITY
    2              0.000012 syn match   dtdAttrType +[^!]\<ENTITY+
                            
                            "Attribute Definitions
    2              0.000016 syn match  dtdAttrDef   "#REQUIRED"
    2              0.000012 syn match  dtdAttrDef   "#IMPLIED"
    2              0.000010 syn match  dtdAttrDef   "#FIXED"
                            
    2              0.000002 syn case match
                            " define some common keywords to mark TODO
                            " and important sections inside comments.
    2              0.000008 syn keyword dtdTodo contained TODO FIXME XXX
                            
    2              0.000006 syn sync lines=250
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    2              0.000007 if version >= 508 || !exists("did_dtd_syn_inits")
    2              0.000003     if version < 508
                            	let did_dtd_syn_inits = 1
                            	command -nargs=+ HiLink hi link <args>
                                else
    2              0.000024 	command -nargs=+ HiLink hi def link <args>
    2              0.000002     endif
                            
                                " The default highlighting.
    2              0.000033     HiLink dtdFunction		Function
    2              0.000017     HiLink dtdTag		Normal
    2              0.000015     HiLink dtdType		Type
    2              0.000012     HiLink dtdAttrType		dtdType
    2              0.000012     HiLink dtdAttrDef		dtdType
    2              0.000015     HiLink dtdConstant		Constant
    2              0.000011     HiLink dtdString		dtdConstant
    2              0.000011     HiLink dtdEnum		dtdConstant
    2              0.000012     HiLink dtdCard		dtdFunction
                            
    2              0.000014     HiLink dtdEntity		Statement
    2              0.000012     HiLink dtdEntityPunct	dtdType
    2              0.000012     HiLink dtdParamEntityInst	dtdConstant
    2              0.000012     HiLink dtdParamEntityPunct	dtdType
    2              0.000012     HiLink dtdParamEntityDecl	dtdType
    2              0.000012     HiLink dtdParamEntityDPunct dtdComment
                            
    2              0.000014     HiLink dtdComment		Comment
    2              0.000017     HiLink dtdTagName		Statement
    2              0.000015     HiLink dtdError		Error
    2              0.000015     HiLink dtdTodo		Todo
                            
    2              0.000004     delcommand HiLink
    2              0.000002 endif
                            
    2              0.000023 let &cpo = s:dtd_cpo_save
    2              0.000004 unlet s:dtd_cpo_save
                            
    2              0.000006 let b:current_syntax = "dtd"
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim73/ftplugin/java.vim
Sourced 1 time
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Java
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Change:  2012 Mar 11
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000008 if exists("b:did_ftplugin") | finish | endif
    1              0.000004 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000008 let s:save_cpo = &cpo
    1              0.000010 set cpo-=C
                            
                            " For filename completion, prefer the .java extension over the .class
                            " extension.
    1              0.000004 set suffixes+=.class
                            
                            " Enable gf on import statements.  Convert . in the package
                            " name to / and append .java to the name, then search the path.
    1              0.000003 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
    1              0.000004 setlocal suffixesadd=.java
    1              0.000004 if exists("g:ftplugin_java_source_path")
                                let &l:path=g:ftplugin_java_source_path . ',' . &l:path
                            endif
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set 'comments' to format dashed lists in comments. Behaves just like C.
    1              0.000006 setlocal comments& comments^=sO:*\ -,mO:*\ \ ,exO:*/
                            
    1              0.000002 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show Java-related files.
    1              0.000005 if has("gui_win32")
                                let  b:browsefilter="Java Files (*.java)\t*.java\n" .
                            		\	"Properties Files (*.prop*)\t*.prop*\n" .
                            		\	"Manifest Files (*.mf)\t*.mf\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    1              0.000007 let b:undo_ftplugin = "setlocal suffixes< suffixesadd<" .
                            		\     " formatoptions< comments< commentstring< path< includeexpr<" .
                            		\     " | unlet! b:browsefilter"
                            
                            " Restore the saved compatibility options.
    1              0.000014 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /usr/share/vim/vim73/indent/java.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Java
                            " Previous Maintainer: Toby Allsopp <toby.allsopp@peace.com>
                            " Current Maintainer: Hong Xu <xuhdev@gmail.com>
                            " Last Change:	2012 May 18
                            " Version: 1.0
                            " License: Same as Vim.
                            " Copyright (c) 2012 Hong Xu
                            " Before 2012, this file is maintained by Toby Allsopp.
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
                            endif
    1              0.000003 let b:did_indent = 1
                            
                            " Indent Java anonymous classes correctly.
    1              0.000006 setlocal cindent cinoptions& cinoptions+=j1
                            
                            " The "extends" and "implements" lines start off with the wrong indent.
    1              0.000005 setlocal indentkeys& indentkeys+=0=extends indentkeys+=0=implements
                            
                            " Set the function to do the work.
    1              0.000002 setlocal indentexpr=GetJavaIndent()
                            
    1              0.000004 let b:undo_indent = "set cin< cino< indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetJavaIndent")
    1              0.000001   finish

SCRIPT  /usr/share/vim/vim73/syntax/java.vim
Sourced 1 time
Total time:   0.003778
 Self time:   0.002172

count  total (s)   self (s)
                            " Vim syntax file " Language:	  Java
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " URL:		http://www.fleiner.com/vim/syntax/java.vim
                            " Last Change:	2011 Dec 30
                            
                            " Please check :help java.vim for comments on some of the options available.
                            
                            " Quit when a syntax file was already loaded
    1              0.000005 if !exists("main_syntax")
    1              0.000003   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              " we define it here so that included files can test for it
    1              0.000005   let main_syntax='java'
    1              0.000013   syn region javaFold start="{" end="}" transparent fold
    1              0.000001 endif
                            
                            " don't use standard HiLink, it will not work with included syntax files
    1              0.000002 if version < 508
                              command! -nargs=+ JavaHiLink hi link <args>
                            else
    1              0.000017   command! -nargs=+ JavaHiLink hi def link <args>
    1              0.000001 endif
                            
                            " some characters that cannot be in a java program (outside a string)
    1              0.000006 syn match javaError "[\\@`]"
    1              0.000010 syn match javaError "<<<\|\.\.\|=>\|<>\|||=\|&&=\|[^-]->\|\*\/"
    1              0.000006 syn match javaOK "\.\.\."
                            
                            " use separate name so that it can be deleted in javacc.vim
    1              0.000004 syn match   javaError2 "#\|=<"
    1              0.000008 JavaHiLink javaError2 javaError
                            
                            
                            
                            " keyword definitions
    1              0.000005 syn keyword javaExternal	native package
    1              0.000008 syn match javaExternal		"\<import\>\(\s\+static\>\)\?"
    1              0.000004 syn keyword javaError		goto const
    1              0.000004 syn keyword javaConditional	if else switch
    1              0.000004 syn keyword javaRepeat		while for do
    1              0.000004 syn keyword javaBoolean		true false
    1              0.000003 syn keyword javaConstant	null
    1              0.000004 syn keyword javaTypedef		this super
    1              0.000004 syn keyword javaOperator	new instanceof
    1              0.000005 syn keyword javaType		boolean char byte short int long float double
    1              0.000003 syn keyword javaType		void
    1              0.000003 syn keyword javaStatement	return
    1              0.000006 syn keyword javaStorageClass	static synchronized transient volatile final strictfp serializable
    1              0.000004 syn keyword javaExceptions	throw try catch finally
    1              0.000003 syn keyword javaAssert		assert
    1              0.000003 syn keyword javaMethodDecl	synchronized throws
    1              0.000004 syn keyword javaClassDecl	extends implements interface
                            " to differentiate the keyword class from MyClass.class we use a match here
    1              0.000007 syn match   javaTypedef		"\.\s*\<class\>"ms=s+1
    1              0.000006 syn keyword javaClassDecl	enum
    1              0.000005 syn match   javaClassDecl	"^class\>"
    1              0.000006 syn match   javaClassDecl	"[^.]\s*\<class\>"ms=s+1
    1              0.000012 syn match   javaAnnotation	"@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>"
    1              0.000006 syn match   javaClassDecl	"@interface\>"
    1              0.000010 syn keyword javaBranch		break continue nextgroup=javaUserLabelRef skipwhite
    1              0.000004 syn match   javaUserLabelRef	"\k\+" contained
    1              0.000004 syn match   javaVarArg		"\.\.\."
    1              0.000008 syn keyword javaScopeDecl	public protected private abstract
                            
    1              0.000004 if exists("java_highlight_java_lang_ids")
                              let java_highlight_all=1
                            endif
    1              0.000006 if exists("java_highlight_all")  || exists("java_highlight_java")  || exists("java_highlight_java_lang") 
                              " java.lang.*
                              syn match javaLangClass "\<System\>"
                              syn keyword javaR_JavaLang NegativeArraySizeException ArrayStoreException IllegalStateException RuntimeException IndexOutOfBoundsException UnsupportedOperationException ArrayIndexOutOfBoundsException ArithmeticException ClassCastException EnumConstantNotPresentException StringIndexOutOfBoundsException IllegalArgumentException IllegalMonitorStateException IllegalThreadStateException NumberFormatException NullPointerException TypeNotPresentException SecurityException
                              syn cluster javaTop add=javaR_JavaLang
                              syn cluster javaClasses add=javaR_JavaLang
                              JavaHiLink javaR_JavaLang javaR_Java
                              syn keyword javaC_JavaLang Process RuntimePermission StringKeySet CharacterData01 Class ThreadLocal ThreadLocalMap CharacterData0E Package Character StringCoding Long ProcessImpl ProcessEnvironment Short AssertionStatusDirectives 1PackageInfoProxy UnicodeBlock InheritableThreadLocal AbstractStringBuilder StringEnvironment ClassLoader ConditionalSpecialCasing CharacterDataPrivateUse StringBuffer StringDecoder Entry StringEntry WrappedHook StringBuilder StrictMath State ThreadGroup Runtime CharacterData02 MethodArray Object CharacterDataUndefined Integer Gate Boolean Enum Variable Subset StringEncoder Void Terminator CharsetSD IntegerCache CharacterCache Byte CharsetSE Thread SystemClassLoaderAction CharacterDataLatin1 StringValues StackTraceElement Shutdown ShortCache String ConverterSD ByteCache Lock EnclosingMethodInfo Math Float Value Double SecurityManager LongCache ProcessBuilder StringEntrySet Compiler Number UNIXProcess ConverterSE ExternalData CaseInsensitiveComparator CharacterData00 NativeLibrary
                              syn cluster javaTop add=javaC_JavaLang
                              syn cluster javaClasses add=javaC_JavaLang
                              JavaHiLink javaC_JavaLang javaC_Java
                              syn keyword javaE_JavaLang IncompatibleClassChangeError InternalError UnknownError ClassCircularityError AssertionError ThreadDeath IllegalAccessError NoClassDefFoundError ClassFormatError UnsupportedClassVersionError NoSuchFieldError VerifyError ExceptionInInitializerError InstantiationError LinkageError NoSuchMethodError Error UnsatisfiedLinkError StackOverflowError AbstractMethodError VirtualMachineError OutOfMemoryError
                              syn cluster javaTop add=javaE_JavaLang
                              syn cluster javaClasses add=javaE_JavaLang
                              JavaHiLink javaE_JavaLang javaE_Java
                              syn keyword javaX_JavaLang CloneNotSupportedException Exception NoSuchMethodException IllegalAccessException NoSuchFieldException Throwable InterruptedException ClassNotFoundException InstantiationException
                              syn cluster javaTop add=javaX_JavaLang
                              syn cluster javaClasses add=javaX_JavaLang
                              JavaHiLink javaX_JavaLang javaX_Java
                            
                              JavaHiLink javaR_Java javaR_
                              JavaHiLink javaC_Java javaC_
                              JavaHiLink javaE_Java javaE_
                              JavaHiLink javaX_Java javaX_
                              JavaHiLink javaX_		     javaExceptions
                              JavaHiLink javaR_		     javaExceptions
                              JavaHiLink javaE_		     javaExceptions
                              JavaHiLink javaC_		     javaConstant
                            
                              syn keyword javaLangObject clone equals finalize getClass hashCode
                              syn keyword javaLangObject notify notifyAll toString wait
                              JavaHiLink javaLangObject		     javaConstant
                              syn cluster javaTop add=javaLangObject
                            endif
                            
    1              0.000012 if filereadable(expand("<sfile>:p:h")."/javaid.vim")
                              source <sfile>:p:h/javaid.vim
                            endif
                            
    1              0.000004 if exists("java_space_errors")
                              if !exists("java_no_trail_space_error")
                                syn match	javaSpaceError	"\s\+$"
                              endif
                              if !exists("java_no_tab_space_error")
                                syn match	javaSpaceError	" \+\t"me=e-1
                              endif
                            endif
                            
    1              0.000015 syn region  javaLabelRegion	transparent matchgroup=javaLabel start="\<case\>" matchgroup=NONE end=":" contains=javaNumber,javaCharacter
    1              0.000011 syn match   javaUserLabel	"^\s*[_$a-zA-Z][_$a-zA-Z0-9_]*\s*:"he=e-1 contains=javaLabel
    1              0.000007 syn keyword javaLabel		default
                            
                            " highlighting C++ keywords as errors removed, too many people find it
                            " annoying.  Was: if !exists("java_allow_cpp_keywords")
                            
                            " The following cluster contains all java groups except the contained ones
    1              0.000076 syn cluster javaTop add=javaExternal,javaError,javaError,javaBranch,javaLabelRegion,javaLabel,javaConditional,javaRepeat,javaBoolean,javaConstant,javaTypedef,javaOperator,javaType,javaType,javaStatement,javaStorageClass,javaAssert,javaExceptions,javaMethodDecl,javaClassDecl,javaClassDecl,javaClassDecl,javaScopeDecl,javaError,javaError2,javaUserLabel,javaLangObject,javaAnnotation,javaVarArg
                            
                            
                            " Comments
    1              0.000004 syn keyword javaTodo		 contained TODO FIXME XXX
    1              0.000004 if exists("java_comment_strings")
                              syn region  javaCommentString    contained start=+"+ end=+"+ end=+$+ end=+\*/+me=s-1,he=s-1 contains=javaSpecial,javaCommentStar,javaSpecialChar,@Spell
                              syn region  javaComment2String   contained start=+"+	end=+$\|"+  contains=javaSpecial,javaSpecialChar,@Spell
                              syn match   javaCommentCharacter contained "'\\[^']\{1,6\}'" contains=javaSpecialChar
                              syn match   javaCommentCharacter contained "'\\''" contains=javaSpecialChar
                              syn match   javaCommentCharacter contained "'[^\\]'"
                              syn cluster javaCommentSpecial add=javaCommentString,javaCommentCharacter,javaNumber
                              syn cluster javaCommentSpecial2 add=javaComment2String,javaCommentCharacter,javaNumber
                            endif
    1              0.000010 syn region  javaComment		 start="/\*"  end="\*/" contains=@javaCommentSpecial,javaTodo,@Spell
    1              0.000006 syn match   javaCommentStar	 contained "^\s*\*[^/]"me=e-1
    1              0.000006 syn match   javaCommentStar	 contained "^\s*\*$"
    1              0.000009 syn match   javaLineComment	 "//.*" contains=@javaCommentSpecial2,javaTodo,@Spell
    1              0.000007 JavaHiLink javaCommentString javaString
    1              0.000005 JavaHiLink javaComment2String javaString
    1              0.000004 JavaHiLink javaCommentCharacter javaCharacter
                            
    1              0.000010 syn cluster javaTop add=javaComment,javaLineComment
                            
    1              0.000006 if !exists("java_ignore_javadoc") && main_syntax != 'jsp'
    1              0.000002   syntax case ignore
                              " syntax coloring for javadoc comments (HTML)
    1              0.000030   syntax include @javaHtml <sfile>:p:h/html.vim
    1              0.000004   unlet b:current_syntax
                              " HTML enables spell checking for all text that is not in a syntax item. This
                              " is wrong for Java (all identifiers would be spell-checked), so it's undone
                              " here.
    1              0.000003   syntax spell default
                            
    1              0.000019   syn region  javaDocComment	start="/\*\*"  end="\*/" keepend contains=javaCommentTitle,@javaHtml,javaDocTags,javaDocSeeTag,javaTodo,@Spell
    1              0.000024   syn region  javaCommentTitle	contained matchgroup=javaDocComment start="/\*\*"   matchgroup=javaCommentTitle keepend end="\.$" end="\.[ \t\r<&]"me=e-1 end="[^{]@"me=s-2,he=s-1 end="\*/"me=s-1,he=s-1 contains=@javaHtml,javaCommentStar,javaTodo,@Spell,javaDocTags,javaDocSeeTag
                            
    1              0.000015   syn region javaDocTags	 contained start="{@\(link\|linkplain\|inherit[Dd]oc\|doc[rR]oot\|value\)" end="}"
    1              0.000011   syn match  javaDocTags	 contained "@\(param\|exception\|throws\|since\)\s\+\S\+" contains=javaDocParam
    1              0.000005   syn match  javaDocParam	 contained "\s\S\+"
    1              0.000012   syn match  javaDocTags	 contained "@\(version\|author\|return\|deprecated\|serial\|serialField\|serialData\)\>"
    1              0.000010   syn region javaDocSeeTag	 contained matchgroup=javaDocTags start="@see\s\+" matchgroup=NONE end="\_."re=e-1 contains=javaDocSeeTagParam
    1              0.000014   syn match  javaDocSeeTagParam  contained @"\_[^"]\+"\|<a\s\+\_.\{-}</a>\|\(\k\|\.\)*\(#\k\+\((\_[^)]\+)\)\=\)\=@ extend
    1              0.000002   syntax case match
    1              0.000001 endif
                            
                            " match the special comment /**/
    1              0.000004 syn match   javaComment		 "/\*\*/"
                            
                            " Strings and constants
    1              0.000004 syn match   javaSpecialError	 contained "\\."
    1              0.000004 syn match   javaSpecialCharError contained "[^']"
    1              0.000010 syn match   javaSpecialChar	 contained "\\\([4-9]\d\|[0-3]\d\d\|[\"\\'ntbrf]\|u\x\{4\}\)"
    1              0.000012 syn region  javaString		start=+"+ end=+"+ end=+$+ contains=javaSpecialChar,javaSpecialError,@Spell
                            " next line disabled, it can cause a crash for a long line
                            "syn match   javaStringError	  +"\([^"\\]\|\\.\)*$+
    1              0.000009 syn match   javaCharacter	 "'[^']*'" contains=javaSpecialChar,javaSpecialCharError
    1              0.000007 syn match   javaCharacter	 "'\\''" contains=javaSpecialChar
    1              0.000005 syn match   javaCharacter	 "'[^\\]'"
    1              0.000008 syn match   javaNumber		 "\<\(0[0-7]*\|0[xX]\x\+\|\d\+\)[lL]\=\>"
    1              0.000010 syn match   javaNumber		 "\(\<\d\+\.\d*\|\.\d\+\)\([eE][-+]\=\d\+\)\=[fFdD]\="
    1              0.000006 syn match   javaNumber		 "\<\d\+[eE][-+]\=\d\+[fFdD]\=\>"
    1              0.000006 syn match   javaNumber		 "\<\d\+\([eE][-+]\=\d\+\)\=[fFdD]\>"
                            
                            " unicode characters
    1              0.000005 syn match   javaSpecial "\\u\d\{4\}"
                            
    1              0.000017 syn cluster javaTop add=javaString,javaCharacter,javaNumber,javaSpecial,javaStringError
                            
    1              0.000006 if exists("java_highlight_functions")
                              if java_highlight_functions == "indent"
                                syn match  javaFuncDef "^\(\t\| \{8\}\)[_$a-zA-Z][_$a-zA-Z0-9_. \[\]]*([^-+*/()]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses
                                syn region javaFuncDef start=+^\(\t\| \{8\}\)[$_a-zA-Z][$_a-zA-Z0-9_. \[\]]*([^-+*/()]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses
                                syn match  javaFuncDef "^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]]*([^-+*/()]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses
                                syn region javaFuncDef start=+^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]]*([^-+*/()]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses
                              else
                                " This line catches method declarations at any indentation>0, but it assumes
                                " two things:
                                "	1. class names are always capitalized (ie: Button)
                                "	2. method names are never capitalized (except constructors, of course)
                                syn region javaFuncDef start=+^\s\+\(\(public\|protected\|private\|static\|abstract\|final\|native\|synchronized\)\s\+\)*\(\(void\|boolean\|char\|byte\|short\|int\|long\|float\|double\|\([A-Za-z_][A-Za-z0-9_$]*\.\)*[A-Z][A-Za-z0-9_$]*\)\(<[^>]*>\)\=\(\[\]\)*\s\+[a-z][A-Za-z0-9_$]*\|[A-Z][A-Za-z0-9_$]*\)\s*([^0-9]+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,javaComment,javaLineComment,@javaClasses
                              endif
                              syn match  javaBraces  "[{}]"
                              syn cluster javaTop add=javaFuncDef,javaBraces
                            endif
                            
    1              0.000003 if exists("java_highlight_debug")
                            
                              " Strings and constants
                              syn match   javaDebugSpecial		contained "\\\d\d\d\|\\."
                              syn region  javaDebugString		contained start=+"+  end=+"+  contains=javaDebugSpecial
                              syn match   javaDebugStringError	+"\([^"\\]\|\\.\)*$+
                              syn match   javaDebugCharacter	contained "'[^\\]'"
                              syn match   javaDebugSpecialCharacter contained "'\\.'"
                              syn match   javaDebugSpecialCharacter contained "'\\''"
                              syn match   javaDebugNumber		contained "\<\(0[0-7]*\|0[xX]\x\+\|\d\+\)[lL]\=\>"
                              syn match   javaDebugNumber		contained "\(\<\d\+\.\d*\|\.\d\+\)\([eE][-+]\=\d\+\)\=[fFdD]\="
                              syn match   javaDebugNumber		contained "\<\d\+[eE][-+]\=\d\+[fFdD]\=\>"
                              syn match   javaDebugNumber		contained "\<\d\+\([eE][-+]\=\d\+\)\=[fFdD]\>"
                              syn keyword javaDebugBoolean		contained true false
                              syn keyword javaDebugType		contained null this super
                              syn region javaDebugParen  start=+(+ end=+)+ contained contains=javaDebug.*,javaDebugParen
                            
                              " to make this work you must define the highlighting for these groups
                              syn match javaDebug "\<System\.\(out\|err\)\.print\(ln\)*\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "\<p\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "[A-Za-z][a-zA-Z0-9_]*\.printStackTrace\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "\<trace[SL]\=\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                            
                              syn cluster javaTop add=javaDebug
                            
                              if version >= 508 || !exists("did_c_syn_inits")
                                JavaHiLink javaDebug		 Debug
                                JavaHiLink javaDebugString		 DebugString
                                JavaHiLink javaDebugStringError	 javaError
                                JavaHiLink javaDebugType		 DebugType
                                JavaHiLink javaDebugBoolean		 DebugBoolean
                                JavaHiLink javaDebugNumber		 Debug
                                JavaHiLink javaDebugSpecial		 DebugSpecial
                                JavaHiLink javaDebugSpecialCharacter DebugSpecial
                                JavaHiLink javaDebugCharacter	 DebugString
                                JavaHiLink javaDebugParen		 Debug
                            
                                JavaHiLink DebugString		 String
                                JavaHiLink DebugSpecial		 Special
                                JavaHiLink DebugBoolean		 Boolean
                                JavaHiLink DebugType		 Type
                              endif
                            endif
                            
    1              0.000004 if exists("java_mark_braces_in_parens_as_errors")
                              syn match javaInParen		 contained "[{}]"
                              JavaHiLink javaInParen	javaError
                              syn cluster javaTop add=javaInParen
                            endif
                            
                            " catch errors caused by wrong parenthesis
    1              0.000009 syn region  javaParenT	transparent matchgroup=javaParen  start="("  end=")" contains=@javaTop,javaParenT1
    1              0.000018 syn region  javaParenT1 transparent matchgroup=javaParen1 start="(" end=")" contains=@javaTop,javaParenT2 contained
    1              0.000009 syn region  javaParenT2 transparent matchgroup=javaParen2 start="(" end=")" contains=@javaTop,javaParenT  contained
    1              0.000005 syn match   javaParenError	 ")"
                            " catch errors caused by wrong square parenthesis
    1              0.000009 syn region  javaParenT	transparent matchgroup=javaParen  start="\["  end="\]" contains=@javaTop,javaParenT1
    1              0.000008 syn region  javaParenT1 transparent matchgroup=javaParen1 start="\[" end="\]" contains=@javaTop,javaParenT2 contained
    1              0.000008 syn region  javaParenT2 transparent matchgroup=javaParen2 start="\[" end="\]" contains=@javaTop,javaParenT  contained
    1              0.000004 syn match   javaParenError	 "\]"
                            
    1              0.000006 JavaHiLink javaParenError	javaError
                            
    1              0.000004 if !exists("java_minlines")
                              let java_minlines = 10
                            endif
    1              0.000009 exec "syn sync ccomment javaComment minlines=" . java_minlines
                            
                            " The default highlighting.
    1              0.000003 if version >= 508 || !exists("did_java_syn_inits")
    1              0.000002   if version < 508
                                let did_java_syn_inits = 1
                              endif
    1              0.000007   JavaHiLink javaFuncDef		Function
    1              0.000007   JavaHiLink javaVarArg			Function
    1              0.000007   JavaHiLink javaBraces			Function
    1              0.000006   JavaHiLink javaBranch			Conditional
    1              0.000005   JavaHiLink javaUserLabelRef		javaUserLabel
    1              0.000007   JavaHiLink javaLabel			Label
    1              0.000006   JavaHiLink javaUserLabel		Label
    1              0.000007   JavaHiLink javaConditional		Conditional
    1              0.000006   JavaHiLink javaRepeat			Repeat
    1              0.000007   JavaHiLink javaExceptions		Exception
    1              0.000006   JavaHiLink javaAssert			Statement
    1              0.000007   JavaHiLink javaStorageClass		StorageClass
    1              0.000005   JavaHiLink javaMethodDecl		javaStorageClass
    1              0.000007   JavaHiLink javaClassDecl		javaStorageClass
    1              0.000005   JavaHiLink javaScopeDecl		javaStorageClass
    1              0.000007   JavaHiLink javaBoolean		Boolean
    1              0.000007   JavaHiLink javaSpecial		Special
    1              0.000006   JavaHiLink javaSpecialError		Error
    1              0.000008   JavaHiLink javaSpecialCharError	Error
    1              0.000006   JavaHiLink javaString			String
    1              0.000007   JavaHiLink javaCharacter		Character
    1              0.000006   JavaHiLink javaSpecialChar		SpecialChar
    1              0.000006   JavaHiLink javaNumber			Number
    1              0.000007   JavaHiLink javaError			Error
    1              0.000006   JavaHiLink javaStringError		Error
    1              0.000007   JavaHiLink javaStatement		Statement
    1              0.000007   JavaHiLink javaOperator		Operator
    1              0.000006   JavaHiLink javaComment		Comment
    1              0.000007   JavaHiLink javaDocComment		Comment
    1              0.000006   JavaHiLink javaLineComment		Comment
    1              0.000007   JavaHiLink javaConstant		Constant
    1              0.000006   JavaHiLink javaTypedef		Typedef
    1              0.000007   JavaHiLink javaTodo			Todo
    1              0.000007   JavaHiLink javaAnnotation		PreProc
                            
    1              0.000006   JavaHiLink javaCommentTitle		SpecialComment
    1              0.000007   JavaHiLink javaDocTags		Special
    1              0.000006   JavaHiLink javaDocParam		Function
    1              0.000006   JavaHiLink javaDocSeeTagParam		Function
    1              0.000005   JavaHiLink javaCommentStar		javaComment
                            
    1              0.000006   JavaHiLink javaType			Type
    1              0.000006   JavaHiLink javaExternal		Include
                            
    1              0.000007   JavaHiLink htmlComment		Special
    1              0.000008   JavaHiLink htmlCommentPart		Special
    1              0.000006   JavaHiLink javaSpaceError		Error
    1              0.000001 endif
                            
    1              0.000002 delcommand JavaHiLink
                            
    1              0.000004 let b:current_syntax = "java"
                            
    1              0.000003 if main_syntax == 'java'
    1              0.000002   unlet main_syntax
    1              0.000001 endif
                            
    1              0.000003 let b:spell_options="contained"
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim73/syntax/html.vim
Sourced 1 time
Total time:   0.001603
 Self time:   0.001603

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	HTML
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " URL:		http://www.fleiner.com/vim/syntax/html.vim
                            " Last Change:  2006 Jun 19
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    1              0.000005 if !exists("main_syntax")
                              if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
                            endif
                            
                            " don't use standard HiLink, it will not work with included syntax files
    1              0.000002 if version < 508
                              command! -nargs=+ HtmlHiLink hi link <args>
                            else
    1              0.000010   command! -nargs=+ HtmlHiLink hi def link <args>
    1              0.000001 endif
                            
    1              0.000002 syntax spell toplevel
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000005 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000013 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000011 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000011 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000011 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000025 syn region  htmlTag                start=+<[^/]+   end=+>+ contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000013 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000011 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000005 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000006 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000005 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000008 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000004 syn keyword htmlTagName contained form hr html img
    1              0.000005 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000005 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000010 syn keyword htmlTagName contained select small strike sub sup
    1              0.000012 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000012 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000005 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000006 syn keyword htmlTagName contained colgroup del fieldset iframe ins legend
    1              0.000005 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " legal arg names
    1              0.000003 syn keyword htmlArg contained action
    1              0.000006 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000004 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000006 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000006 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000005 syn keyword htmlArg contained gutter height hspace id
    1              0.000004 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000004 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000005 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000005 syn keyword htmlArg contained size src start target text type url
    1              0.000005 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000008 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " Netscape extensions
    1              0.000005 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000004 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000005 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000005 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000005 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000003 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000006 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000005 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000007 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000006 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000005 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000024 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000023 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000018 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " special characters
    1              0.000017 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000005 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+
                            else
    1              0.000014   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError
    1              0.000006   syn match  htmlCommentError contained "[^><!]"
    1              0.000008   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc
    1              0.000001 endif
    1              0.000008 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    1              0.000014 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000018 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000009 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000012 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000012 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000006 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000020 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000004 if !exists("html_no_rendering")
                              " rendering
    1              0.000019   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000012   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000015   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000009   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000009   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000011   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000007   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    1              0.000007   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    1              0.000009   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000011   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000009   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000010   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000008   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000009   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000006   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    1              0.000007   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    1              0.000009   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
    1              0.000011   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000008   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    1              0.000008   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000009   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000008   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
    1              0.000008   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000006   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    1              0.000007   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
    1              0.000022   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000008   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
    1              0.000007   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
    1              0.000007   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
    1              0.000007   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
    1              0.000007   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
    1              0.000009   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
    1              0.000030   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000022   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000014 syn keyword htmlTagName         contained noscript
    1              0.000008 syn keyword htmlSpecialTagName  contained script style
    1              0.000005 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
                              syn include @htmlJavaScript syntax/javascript.vim
                              unlet b:current_syntax
                              syn region  javaScript start=+<script[^>]*>+ keepend end=+</script>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
                              syn region  htmlScriptTag     contained start=+<script+ end=+>+       contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
                              HtmlHiLink htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
                              if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
                              endif
                              syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
                              syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
                              HtmlHiLink htmlEventSQ htmlEvent
                              HtmlHiLink htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
                              syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
                            endif
                            
    1              0.000004 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
                              syn include @htmlVbScript syntax/vb.vim
                              unlet b:current_syntax
                              syn region  javaScript start=+<script [^>]*language *=[^>]*vbscript[^>]*>+ keepend end=+</script>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
                            endif
                            
    1              0.000003 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000003 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
                              syn keyword htmlArg           contained media
                              syn include @htmlCss syntax/css.vim
                              unlet b:current_syntax
                              syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
                              syn match htmlCssStyleComment contained "\(<!--\|-->\)"
                              syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
                              HtmlHiLink htmlStyleArg htmlString
                            endif
                            
    1              0.000002 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
                            endif
                            
                            " The default highlighting.
    1              0.000003 if version >= 508 || !exists("did_html_syn_inits")
    1              0.000001   if version < 508
                                let did_html_syn_inits = 1
                              endif
    1              0.000012   HtmlHiLink htmlTag                     Function
    1              0.000007   HtmlHiLink htmlEndTag                  Identifier
    1              0.000007   HtmlHiLink htmlArg                     Type
    1              0.000004   HtmlHiLink htmlTagName                 htmlStatement
    1              0.000006   HtmlHiLink htmlSpecialTagName          Exception
    1              0.000006   HtmlHiLink htmlValue                     String
    1              0.000006   HtmlHiLink htmlSpecialChar             Special
                              
    1              0.000003   if !exists("html_no_rendering")
    1              0.000016     HtmlHiLink htmlH1                      Title
    1              0.000005     HtmlHiLink htmlH2                      htmlH1
    1              0.000004     HtmlHiLink htmlH3                      htmlH2
    1              0.000004     HtmlHiLink htmlH4                      htmlH3
    1              0.000003     HtmlHiLink htmlH5                      htmlH4
    1              0.000006     HtmlHiLink htmlH6                      htmlH5
    1              0.000006     HtmlHiLink htmlHead                    PreProc
    1              0.000007     HtmlHiLink htmlTitle                   Title
    1              0.000005     HtmlHiLink htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000004     HtmlHiLink htmlUnderlineBold           htmlBoldUnderline
    1              0.000005     HtmlHiLink htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000004     HtmlHiLink htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000005     HtmlHiLink htmlItalicUnderline         htmlUnderlineItalic
    1              0.000004     HtmlHiLink htmlItalicBold              htmlBoldItalic
    1              0.000004     HtmlHiLink htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000004     HtmlHiLink htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000006     HtmlHiLink htmlLink                    Underlined
    1              0.000004     if !exists("html_my_rendering")
    1              0.000003       hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000002       hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000003       hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000002       hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000003       hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000002       hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000002       hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000001     endif
    1              0.000001   endif
                              
    1              0.000007   HtmlHiLink htmlPreStmt            PreProc
    1              0.000006   HtmlHiLink htmlPreError           Error
    1              0.000007   HtmlHiLink htmlPreProc            PreProc
    1              0.000006   HtmlHiLink htmlPreAttr            String
    1              0.000007   HtmlHiLink htmlPreProcAttrName    PreProc
    1              0.000006   HtmlHiLink htmlPreProcAttrError   Error
    1              0.000006   HtmlHiLink htmlSpecial            Special
    1              0.000006   HtmlHiLink htmlSpecialChar        Special
    1              0.000007   HtmlHiLink htmlString             String
    1              0.000008   HtmlHiLink htmlStatement          Statement
    1              0.000006   HtmlHiLink htmlComment            Comment
    1              0.000007   HtmlHiLink htmlCommentPart        Comment
    1              0.000006   HtmlHiLink htmlValue              String
    1              0.000005   HtmlHiLink htmlCommentError       htmlError
    1              0.000004   HtmlHiLink htmlTagError           htmlError
    1              0.000004   HtmlHiLink htmlEvent              javaScript
    1              0.000006   HtmlHiLink htmlError              Error
                              
    1              0.000006   HtmlHiLink javaScript             Special
    1              0.000004   HtmlHiLink javaScriptExpression   javaScript
    1              0.000007   HtmlHiLink htmlCssStyleComment    Comment
    1              0.000006   HtmlHiLink htmlCssDefinition      Special
    1              0.000001 endif
                            
    1              0.000001 delcommand HtmlHiLink
                            
    1              0.000004 let b:current_syntax = "html"
                            
    1              0.000003 if main_syntax == 'html'
                              unlet main_syntax
                            endif
                            
                            " vim: ts=8

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/helper.vim
Sourced 1 time
Total time:   0.001236
 Self time:   0.001236

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: helpers.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 23 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000068 let s:save_cpo = &cpo
    1              0.000041 set cpo&vim
                            
    1              0.000024 function! unite#helper#call_hook(sources, hook_name) "{{{
                              let context = unite#get_context()
                              if context.unite__disable_hooks
                                return
                              endif
                            
                              let _ = []
                              for source in a:sources
                                if !has_key(source.hooks, a:hook_name)
                                  continue
                                endif
                            
                                try
                                  call call(source.hooks[a:hook_name],
                                        \ [source.args, source.unite__context], source.hooks)
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error(
                                        \ '[unite.vim] Error occured in calling hook "' . a:hook_name . '"!')
                                  call unite#print_error(
                                        \ '[unite.vim] Source name is ' . source.name)
                                endtry
                              endfor
                            endfunction"}}}
                            
    1              0.000014 function! unite#helper#get_substitute_input(input) "{{{
                              let input = a:input
                            
                              let unite = unite#get_current_unite()
                              let substitute_patterns = reverse(unite#util#sort_by(
                                    \ values(unite#custom#get_profile(unite.profile_name,
                                    \        'substitute_patterns')),
                                    \ 'v:val.priority'))
                              if unite.input != '' && stridx(input, unite.input) == 0
                                " Substitute after input.
                                let input_save = input
                                let input = input_save[len(unite.input) :]
                                let head = input_save[: len(unite.input)-1]
                              else
                                " Substitute all input.
                                let head = ''
                              endif
                            
                              let inputs = unite#helper#get_substitute_input_loop(input, substitute_patterns)
                            
                              return map(inputs, 'head . v:val')
                            endfunction"}}}
    1              0.000016 function! unite#helper#get_substitute_input_loop(input, substitute_patterns) "{{{
                              if empty(a:substitute_patterns)
                                return [a:input]
                              endif
                            
                              let inputs = [a:input]
                              for pattern in a:substitute_patterns
                                let cnt = 0
                                for input in inputs
                                  if input =~ pattern.pattern
                                    if type(pattern.subst) == type([])
                                      if len(inputs) == 1
                                        " List substitute.
                                        let inputs = []
                                        for subst in pattern.subst
                                          call add(inputs,
                                                \ substitute(input, pattern.pattern, subst, 'g'))
                                        endfor
                                      endif
                                    else
                                      let inputs[cnt] = substitute(
                                            \ input, pattern.pattern, pattern.subst, 'g')
                                    endif
                                  endif
                            
                                  let cnt += 1
                                endfor
                              endfor
                            
                              return inputs
                            endfunction"}}}
                            
    1              0.000014 function! unite#helper#adjustments(currentwinwidth, the_max_source_name, size) "{{{
                              let max_width = a:currentwinwidth - a:the_max_source_name - a:size
                              if max_width < 20
                                return [a:currentwinwidth - a:size, 0]
                              else
                                return [max_width, a:the_max_source_name]
                              endif
                            endfunction"}}}
                            
    1              0.000012 function! unite#helper#parse_options(args) "{{{
                              let args = []
                              let options = {}
                              for arg in split(a:args, '\%(\\\@<!\s\)\+')
                                let arg = substitute(arg, '\\\( \)', '\1', 'g')
                            
                                let arg_key = substitute(arg, '=\zs.*$', '', '')
                                let matched_list = filter(copy(unite#variables#options()),
                                      \  'v:val ==# arg_key')
                                for option in matched_list
                                  let key = substitute(substitute(option, '-', '_', 'g'), '=$', '', '')[1:]
                                  let options[key] = (option =~ '=$') ?
                                        \ arg[len(option) :] : 1
                                endfor
                            
                                if empty(matched_list)
                                  call add(args, arg)
                                endif
                              endfor
                            
                              return [args, options]
                            endfunction"}}}
    1              0.000013 function! unite#helper#parse_options_args(args) "{{{
                              let _ = []
                              let [args, options] = unite#helper#parse_options(a:args)
                              for arg in args
                                " Add source name.
                                let source_name = matchstr(arg, '^[^:]*')
                                let source_arg = arg[len(source_name)+1 :]
                                let source_args = source_arg  == '' ? [] :
                                      \  map(split(source_arg, '\\\@<!:', 1),
                                      \      'substitute(v:val, ''\\\(.\)'', "\\1", "g")')
                                call add(_, insert(source_args, source_name))
                              endfor
                            
                              return [_, options]
                            endfunction"}}}
                            
    1              0.000010 function! unite#helper#get_marked_candidates() "{{{
                              return unite#util#sort_by(filter(copy(unite#get_unite_candidates()),
                                    \ 'v:val.unite__is_marked'), 'v:val.unite__marked_time')
                            endfunction"}}}
                            
    1              0.000009 function! unite#helper#get_input() "{{{
                              let unite = unite#get_current_unite()
                              " Prompt check.
                              if stridx(getline(unite.prompt_linenr), unite.prompt) != 0
                                let modifiable_save = &l:modifiable
                                setlocal modifiable
                            
                                " Restore prompt.
                                call setline(unite.prompt_linenr, unite.prompt
                                      \ . getline(unite.prompt_linenr))
                            
                                let &l:modifiable = modifiable_save
                              endif
                            
                              return getline(unite.prompt_linenr)[len(unite.prompt):]
                            endfunction"}}}
                            
    1              0.000012 function! unite#helper#get_source_names(sources) "{{{
                              return map(map(copy(a:sources),
                                    \ "type(v:val) == type([]) ? v:val[0] : v:val"),
                                    \ "type(v:val) == type('') ? v:val : v:val.name")
                            endfunction"}}}
                            
    1              0.000011 function! unite#helper#get_postfix(prefix, is_create, ...) "{{{
                              let buffers = get(a:000, 0, range(1, bufnr('$')))
                              let buflist = sort(filter(map(buffers,
                                    \ 'bufname(v:val)'), 'stridx(v:val, a:prefix) >= 0'))
                              if empty(buflist)
                                return ''
                              endif
                            
                              return a:is_create ? '@'.(matchstr(buflist[-1], '@\zs\d\+$') + 1)
                                    \ : matchstr(buflist[-1], '@\d\+$')
                            endfunction"}}}
                            
    1              0.000013 function! unite#helper#convert_source_name(source_name) "{{{
                              let context = unite#get_context()
                              return !context.short_source_names ? a:source_name :
                                    \ a:source_name !~ '\A'  ? a:source_name[:1] :
                                    \ substitute(a:source_name, '\a\zs\a\+', '', 'g')
                            endfunction"}}}
                            
    1              0.000013 function! unite#helper#loaded_source_names_with_args() "{{{
                              return map(copy(unite#loaded_sources_list()), "
                                    \ join(insert(filter(copy(v:val.args),
                                    \  'type(v:val) <= 1'),
                                    \   unite#helper#convert_source_name(v:val.name)), ':')
                                    \ . (v:val.unite__orig_len_candidates == 0 ? '' :
                                    \      v:val.unite__orig_len_candidates ==
                                    \            v:val.unite__len_candidates ?
                                    \            '(' .  v:val.unite__len_candidates . ')' :
                                    \      printf('(%s/%s)', v:val.unite__len_candidates,
                                    \      v:val.unite__orig_len_candidates))
                                    \ ")
                            endfunction"}}}
                            
    1              0.000012 function! unite#helper#invalidate_cache(source_name)  "{{{
                              for source in unite#get_current_unite().sources
                                if source.name ==# a:source_name
                                  let source.unite__is_invalidate = 1
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000011 function! unite#helper#get_unite_winnr(buffer_name) "{{{
                              for winnr in filter(range(1, winnr('$')),
                                    \ "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                let buffer_context = get(getbufvar(
                                      \ winbufnr(winnr), 'unite'), 'context', {})
                                if !empty(buffer_context) &&
                                      \ buffer_context.buffer_name ==# a:buffer_name
                                  if buffer_context.temporary
                                        \ && !empty(filter(copy(buffer_context.old_buffer_info),
                                        \ 'v:val.buffer_name ==# buffer_context.buffer_name'))
                                    " Disable resume.
                                    let buffer_context.old_buffer_info = []
                                  endif
                                  return winnr
                                endif
                              endfor
                            
                              return -1
                            endfunction"}}}
    1              0.000011 function! unite#helper#get_unite_bufnr(buffer_name) "{{{
                              for bufnr in filter(range(1, bufnr('$')),
                                    \ "getbufvar(v:val, '&filetype') ==# 'unite'")
                                let buffer_context = get(getbufvar(bufnr, 'unite'), 'context', {})
                                if !empty(buffer_context) &&
                                      \ buffer_context.buffer_name ==# a:buffer_name
                                  if buffer_context.temporary
                                        \ && !empty(filter(copy(buffer_context.old_buffer_info),
                                        \ 'v:val.buffer_name ==# buffer_context.buffer_name'))
                                    " Disable resume.
                                    let buffer_context.old_buffer_info = []
                                  endif
                            
                                  return bufnr
                                endif
                              endfor
                            
                              return -1
                            endfunction"}}}
                            
    1              0.000014 function! unite#helper#get_current_candidate(...) "{{{
                              let linenr = a:0 >= 1? a:1 : line('.')
                              let num = linenr <= unite#get_current_unite().prompt_linenr ?
                                    \ 0 : linenr - (unite#get_current_unite().prompt_linenr+1)
                            
                              return get(unite#get_unite_candidates(), num, {})
                            endfunction"}}}
                            
    1              0.000013 function! unite#helper#get_current_candidate_linenr(num) "{{{
                              let num = 0
                            
                              let candidate_num = 0
                              for candidate in unite#get_unite_candidates()
                                if !candidate.is_dummy
                                  let candidate_num += 1
                                endif
                            
                                let num += 1
                            
                                if candidate_num >= a:num+1
                                  break
                                endif
                              endfor
                            
                              return unite#get_current_unite().prompt_linenr + num
                            endfunction"}}}
                            
    1              0.000012 function! unite#helper#call_filter(filter_name, candidates, context) "{{{
                              let filter = unite#get_filters(a:filter_name)
                              if empty(filter)
                                return a:candidates
                              endif
                            
                              return filter.filter(a:candidates, a:context)
                            endfunction"}}}
                            
    1              0.000012 function! unite#helper#get_source_args(sources) "{{{
                              return map(copy(a:sources),
                                    \ 'type(v:val) == type([]) ? [v:val[0], v:val[1:]] : [v:val, []]')
                            endfunction"}}}
                            
    1              0.000037 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/variables.vim
Sourced 1 time
Total time:   0.000899
 Self time:   0.000899

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: variables.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 17 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000048 let s:save_cpo = &cpo
    1              0.000029 set cpo&vim
                            
    1              0.000017 if !exists('s:use_current_unite')
    1              0.000012   let s:use_current_unite = 1
    1              0.000004 endif
                            
    1              0.000015 function! unite#variables#current_unite() "{{{
                              if !exists('s:current_unite')
                                let s:current_unite = {}
                              endif
                            
                              return s:current_unite
                            endfunction"}}}
                            
    1              0.000013 function! unite#variables#set_current_unite(unite) "{{{
                              let s:current_unite = a:unite
                            endfunction"}}}
                            
    1              0.000016 function! unite#variables#use_current_unite() "{{{
                              return s:use_current_unite
                            endfunction"}}}
                            
    1              0.000011 function! unite#variables#enable_current_unite() "{{{
                              let s:use_current_unite = 1
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#disable_current_unite() "{{{
                              let s:use_current_unite = 0
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#static() "{{{
                              if !exists('s:static')
                                let s:static = {}
                                let s:static.sources = {}
                                let s:static.kinds = {}
                                let s:static.filters = {}
                              endif
                            
                              return s:static
                            endfunction"}}}
                            
    1              0.000009 function! unite#variables#dynamic() "{{{
                              if !exists('s:dynamic')
                                let s:dynamic = {}
                                let s:dynamic.sources = {}
                                let s:dynamic.kinds = {}
                                let s:dynamic.filters = {}
                              endif
                            
                              return s:dynamic
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#loaded_defaults() "{{{
                              if !exists('s:loaded_defaults')
                                let s:loaded_defaults = {}
                              endif
                            
                              return s:loaded_defaults
                            endfunction"}}}
                            
    1              0.000009 function! unite#variables#options() "{{{
                              if !exists('s:options')
                                let s:options = [
                                      \ '-buffer-name=', '-profile-name=', '-input=', '-prompt=',
                                      \ '-default-action=', '-start-insert',
                                      \ '-no-start-insert', '-no-quit',
                                      \ '-winwidth=', '-winheight=',
                                      \ '-immediately', '-no-empty',
                                      \ '-auto-preview', '-auto-highlight', '-complete',
                                      \ '-vertical', '-horizontal', '-direction=', '-no-split',
                                      \ '-verbose', '-auto-resize',
                                      \ '-toggle', '-quick-match', '-create',
                                      \ '-cursor-line-highlight=', '-no-cursor-line',
                                      \ '-update-time=', '-hide-source-names', '-hide-status-line',
                                      \ '-max-multi-lines=', '-here', '-silent', '-keep-focus',
                                      \ '-auto-quit', '-no-focus',
                                      \ '-long-source-names', '-short-source-names',
                                      \ '-multi-line', '-resume', '-wrap', '-select=', '-log',
                                      \ '-truncate', '-tab',
                                      \]
                              endif
                            
                              return s:options
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#kinds(...) "{{{
                              if a:0 == 0
                                call unite#init#_default_scripts('kinds', [])
                              else
                                call unite#init#_default_scripts('kinds', [a:1])
                              endif
                            
                              let kinds = unite#init#_kinds()
                              return (a:0 == 0) ? kinds : get(kinds, a:1, {})
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#sources(...) "{{{
                              let unite = unite#get_current_unite()
                              if !has_key(unite, 'sources')
                                return {}
                              endif
                            
                              if a:0 == 0
                                return unite.sources
                              endif
                            
                              return unite#util#get_name(unite.sources, a:1, {})
                            endfunction"}}}
                            
    1              0.000011 function! unite#variables#all_sources(...) "{{{
                              if a:0 == 0
                                return unite#init#_sources()
                              endif
                            
                              let unite = unite#get_current_unite()
                            
                              let all_sources = unite#init#_sources([], a:1)
                              let source = get(all_sources, a:1, {})
                            
                              return empty(source) ?
                                    \ get(filter(copy(get(unite, 'sources', [])),
                                    \ 'v:val.name ==# a:1'), 0, {}) : source
                            endfunction"}}}
                            
    1              0.000009 function! unite#variables#filters(...) "{{{
                              if a:0 == 0
                                call unite#init#_default_scripts('filters', [])
                              else
                                call unite#init#_default_scripts('filters', [a:1])
                              endif
                            
                              let filters = unite#init#_filters()
                            
                              if a:0 == 0
                                return filters
                              endif
                            
                              return get(filters, a:1, {})
                            endfunction"}}}
                            
    1              0.000010 function! unite#variables#loaded_sources(...) "{{{
                              " Initialize load.
                              let unite = unite#get_current_unite()
                              return a:0 == 0 ? unite.sources :
                                    \ get(filter(copy(unite.sources), 'v:val.name ==# a:1'), 0, {})
                            endfunction"}}}
                            
    1              0.000011 function! unite#variables#default_context() "{{{
                              if !exists('s:default_context')
                                let s:default_context = {
                                      \ 'input' : '',
                                      \ 'start_insert' : g:unite_enable_start_insert,
                                      \ 'complete' : 0,
                                      \ 'script' : 0,
                                      \ 'col' : col('.'),
                                      \ 'no_quit' : 0,
                                      \ 'buffer_name' : 'default',
                                      \ 'profile_name' : '',
                                      \ 'prompt' : g:unite_prompt,
                                      \ 'default_action' : 'default',
                                      \ 'winwidth' : g:unite_winwidth,
                                      \ 'winheight' : g:unite_winheight,
                                      \ 'immediately' : 0,
                                      \ 'no_empty' : 0,
                                      \ 'auto_preview' : 0,
                                      \ 'auto_highlight' : 0,
                                      \ 'vertical' : g:unite_enable_split_vertically,
                                      \ 'direction' : g:unite_split_rule,
                                      \ 'no_split' : 0,
                                      \ 'temporary' : 0,
                                      \ 'verbose' : 0,
                                      \ 'auto_resize' : 0,
                                      \ 'old_buffer_info' : [],
                                      \ 'toggle' : 0,
                                      \ 'quick_match' : 0,
                                      \ 'create' : 0,
                                      \ 'cursor_line_highlight' :
                                      \    g:unite_cursor_line_highlight,
                                      \ 'no_cursor_line' : 0,
                                      \ 'update_time' : g:unite_update_time,
                                      \ 'no_buffer' : 0,
                                      \ 'hide_source_names' : 0,
                                      \ 'max_multi_lines' : 5,
                                      \ 'here' : 0,
                                      \ 'silent' : 0,
                                      \ 'keep_focus' : 0,
                                      \ 'auto_quit' : 0,
                                      \ 'is_redraw' : 0,
                                      \ 'is_restart' : 0,
                                      \ 'is_resize' : 0,
                                      \ 'no_focus' : 0,
                                      \ 'multi_line' : 0,
                                      \ 'resume' : 0,
                                      \ 'wrap' : 0,
                                      \ 'select' : 0,
                                      \ 'log' : 0,
                                      \ 'truncate' : 0,
                                      \ 'tab' : 0,
                                      \ 'execute_command' : '',
                                      \ 'unite__direct_switch' : 0,
                                      \ 'unite__is_interactive' : 1,
                                      \ 'unite__is_complete' : 0,
                                      \ 'unite__is_vimfiler' : 0,
                                      \ 'unite__old_winwidth' : 0,
                                      \ 'unite__old_winheight' : 0,
                                      \ 'unite__disable_hooks' : 0,
                                      \ 'unite__disable_max_candidates' : 0,
                                      \ }
                              endif
                            
                              return s:default_context
                            endfunction"}}}
                            
    1              0.000015 function! unite#variables#get_source_variable(source, variable, default) "{{{
                              if !exists('s:source_variables')
                                let s:source_variables = {}
                              endif
                            
                              if !has_key(s:source_variables, a:source)
                                let s:source_variables[a:source] = {}
                              endif
                            
                              if !has_key(s:source_variables[a:source], a:variable)
                                let s:source_variables[a:source][a:variable] = a:default
                              endif
                            
                              return s:source_variables[a:source][a:variable]
                            endfunction"}}}
                            
    1              0.000032 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/start.vim
Sourced 1 time
Total time:   0.001376
 Self time:   0.001376

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: start.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 30 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000036 let s:save_cpo = &cpo
    1              0.000030 set cpo&vim
                            
    1              0.000016 function! unite#start#standard(sources, ...) "{{{
                              if empty(a:sources)
                                call unite#print_error('[unite.vim] Source names is required.')
                                return
                              endif
                            
                              " Check command line window.
                              if unite#util#is_cmdwin()
                                call unite#print_error(
                                      \ '[unite.vim] Command line buffer is detected! '.
                                      \ 'Please close command line buffer.')
                                return
                              endif
                            
                              let context = get(a:000, 0, {})
                              let context = unite#init#_context(context,
                                    \ unite#helper#get_source_names(a:sources))
                            
                              if context.resume
                                " Check resume buffer.
                                let resume_bufnr = s:get_resume_buffer(context.buffer_name)
                                if resume_bufnr > 0 &&
                                      \ getbufvar(resume_bufnr, 'unite').source_names ==#
                                      \    unite#helper#get_source_names(a:sources)
                                  return unite#start#resume(context.buffer_name, context)
                                endif
                              endif
                            
                              call unite#variables#enable_current_unite()
                            
                              if context.toggle "{{{
                                if unite#view#_close(context.buffer_name)
                                  return
                                endif
                              endif"}}}
                            
                              try
                                call unite#init#_current_unite(a:sources, context)
                              catch /^unite.vim: Invalid /
                                call unite#print_error('[unite.vim] ' . v:exception)
                                return
                              endtry
                            
                              " Caching.
                              let current_unite = unite#variables#current_unite()
                              let current_unite.last_input = context.input
                              let current_unite.input = context.input
                              call unite#candidates#_recache(context.input, context.is_redraw)
                            
                              if !current_unite.is_async &&
                                    \ (context.immediately || context.no_empty) "{{{
                                let candidates = unite#candidates#gather()
                            
                                if empty(candidates)
                                  " Ignore.
                                  call unite#variables#disable_current_unite()
                                  return
                                elseif context.immediately && len(candidates) == 1
                                  " Immediately action.
                                  call unite#action#do(
                                        \ context.default_action, [candidates[0]])
                                  call unite#variables#disable_current_unite()
                                  return
                                endif
                              endif"}}}
                            
                              call unite#init#_unite_buffer()
                            
                              call unite#variables#disable_current_unite()
                            
                              let unite = unite#get_current_unite()
                            
                              setlocal modifiable
                            
                              " Redraw prompt.
                              silent % delete _
                              call setline(unite.prompt_linenr,
                                    \ unite.prompt . unite.context.input)
                            
                              call unite#view#_redraw_candidates()
                            
                              call unite#handlers#_on_bufwin_enter(bufnr('%'))
                            
                              call unite#view#_init_cursor()
                            endfunction"}}}
                            
    1              0.000012 function! unite#start#script(sources, ...) "{{{
                              " Start unite from script.
                            
                              let context = get(a:000, 0, {})
                            
                              let context.script = 1
                            
                              return &filetype == 'unite' ?
                                    \ unite#start#temporary(a:sources, context) :
                                    \ unite#start#standard(a:sources, context)
                            endfunction"}}}
                            
    1              0.000019 function! unite#start#temporary(sources, ...) "{{{
                              " Get current context.
                              let old_context = unite#get_context()
                              let unite = unite#get_current_unite()
                            
                              if !empty(unite) && !empty(old_context)
                                let context = deepcopy(old_context)
                                let context.old_buffer_info = insert(context.old_buffer_info, {
                                      \ 'buffer_name' : unite.buffer_name,
                                      \ 'pos' : getpos('.'),
                                      \ 'profile_name' : unite.profile_name,
                                      \ })
                              else
                                let context = {}
                                let context = unite#init#_context(context,
                                      \ unite#helper#get_source_names(a:sources))
                                let context.old_buffer_info = []
                              endif
                            
                              let new_context = get(a:000, 0, {})
                            
                              " Overwrite context.
                              let context = extend(context, new_context)
                            
                              let context.temporary = 1
                              let context.unite__direct_switch = 1
                              let context.input = ''
                              let context.auto_preview = 0
                              let context.auto_highlight = 0
                              let context.unite__is_vimfiler = 0
                              let context.default_action = 'default'
                              let context.unite__old_winwidth = 0
                              let context.unite__old_winheight = 0
                              let context.is_resize = 0
                              let context.is_restart = 0
                              let context.quick_match = 0
                            
                              if context.script
                                " Set buffer-name automatically.
                                let context.buffer_name = unite#helper#get_source_names(a:sources)
                              endif
                            
                              let buffer_name = get(a:000, 1,
                                    \ matchstr(context.buffer_name, '^\S\+')
                                    \ . ' - ' . len(context.old_buffer_info))
                            
                              let context.buffer_name = buffer_name
                            
                              let unite_save = unite#get_current_unite()
                            
                              let cwd = getcwd()
                            
                              call unite#start#standard(a:sources, context)
                            
                              " Overwrite unite.
                              let unite = unite#get_current_unite()
                              let unite.prev_bufnr = unite_save.prev_bufnr
                              let unite.prev_winnr = unite_save.prev_winnr
                              if has_key(unite, 'update_time_save')
                                let unite.update_time_save = unite_save.update_time_save
                              endif
                              let unite.winnr = unite_save.winnr
                            
                              " Restore current directory.
                              execute 'lcd' fnameescape(cwd)
                            endfunction"}}}
                            
    1              0.000014 function! unite#start#vimfiler_check_filetype(sources, ...) "{{{
                              let context = get(a:000, 0, {})
                              let context = unite#init#_context(context,
                                    \ unite#helper#get_source_names(a:sources))
                              let context.unite__is_vimfiler = 1
                              let context.unite__is_interactive = 0
                              if !has_key(context, 'vimfiler__is_dummy')
                                let context.vimfiler__is_dummy = 0
                              endif
                            
                              try
                                call unite#init#_current_unite(a:sources, context)
                              catch /^unite.vim: Invalid /
                                return []
                              endtry
                            
                              for source in filter(copy(unite#loaded_sources_list()),
                                    \ "has_key(v:val, 'vimfiler_check_filetype')")
                                let ret = source.vimfiler_check_filetype(source.args, context)
                                if empty(ret)
                                  continue
                                endif
                            
                                let [type, info] = ret
                                if type ==# 'file'
                                  call unite#init#_candidates_source([info[1]], source.name)
                                elseif type ==# 'directory'
                                  " nop
                                elseif type ==# 'error'
                                  call unite#print_error('[unite.vim] ' . info)
                                  return []
                                else
                                  call unite#print_error('[unite.vim] Invalid filetype : ' . type)
                                endif
                            
                                return [type, info]
                              endfor
                            
                              " Not found.
                              return []
                            endfunction"}}}
                            
    1              0.000012 function! unite#start#get_candidates(sources, ...) "{{{
                              let unite_save = unite#get_current_unite()
                            
                              try
                                let context = get(a:000, 0, {})
                                let context = unite#init#_context(context,
                                      \ unite#helper#get_source_names(a:sources))
                                let context.no_buffer = 1
                                let context.unite__is_interactive = 0
                            
                                " Finalize.
                                let candidates = s:get_candidates(a:sources, context)
                            
                                " Call finalize functions.
                                call unite#helper#call_hook(unite#loaded_sources_list(), 'on_close')
                                let unite = unite#get_current_unite()
                                let unite.is_finalized = 1
                              finally
                                call unite#set_current_unite(unite_save)
                              endtry
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000012 function! unite#start#get_vimfiler_candidates(sources, ...) "{{{
                              let unite_save = unite#get_current_unite()
                            
                              try
                                let unite = unite#get_current_unite()
                                let context = get(a:000, 0, {})
                                let context = unite#init#_context(context,
                                      \ unite#helper#get_source_names(a:sources))
                                let context.no_buffer = 1
                                let context.unite__is_vimfiler = 1
                                let context.unite__is_interactive = 0
                                if !has_key(context, 'vimfiler__is_dummy')
                                  let context.vimfiler__is_dummy = 0
                                endif
                            
                                let candidates = s:get_candidates(a:sources, context)
                            
                                " Converts utf-8-mac to the current encoding.
                                if unite#util#is_mac() && has('iconv')
                                  for item in filter(copy(candidates),
                                        \ "v:val.action__path =~# '[^\\x00-\\x7f]'")
                                    let item.action__path = unite#util#iconv(
                                          \ item.action__path, 'utf-8-mac', &encoding)
                                    let item.action__directory = unite#util#iconv(
                                          \ item.action__directory, 'utf-8-mac', &encoding)
                                    let item.word = unite#util#iconv(item.word, 'utf-8-mac', &encoding)
                                    let item.abbr = unite#util#iconv(item.abbr, 'utf-8-mac', &encoding)
                                    let item.vimfiler__filename = unite#util#iconv(
                                          \ item.vimfiler__filename, 'utf-8-mac', &encoding)
                                    let item.vimfiler__abbr = unite#util#iconv(
                                          \ item.vimfiler__abbr, 'utf-8-mac', &encoding)
                                  endfor
                                endif
                              finally
                                call unite#set_current_unite(unite_save)
                              endtry
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000011 function! unite#start#resume(buffer_name, ...) "{{{
                              " Check command line window.
                              if unite#util#is_cmdwin()
                                call unite#print_error(
                                      \ '[unite.vim] Command line buffer is detected! '.
                                      \ 'Please close command line buffer.')
                                return
                              endif
                            
                              if a:buffer_name == ''
                                " Use last unite buffer.
                                if !exists('t:unite') ||
                                      \ !bufexists(t:unite.last_unite_bufnr)
                                  call unite#util#print_error('No unite buffer.')
                                  return
                                endif
                            
                                let bufnr = t:unite.last_unite_bufnr
                              else
                                let bufnr = s:get_resume_buffer(a:buffer_name)
                              endif
                            
                              if bufnr < 0
                                return
                              endif
                            
                              let winnr = winnr()
                              let win_rest_cmd = winrestcmd()
                            
                              if type(getbufvar(bufnr, 'unite')) != type({})
                                " Unite buffer is released.
                                call unite#util#print_error(
                                      \ printf('Invalid unite buffer(%d) is detected.', bufnr))
                                return
                              endif
                            
                              let context = getbufvar(bufnr, 'unite').context
                            
                              let new_context = get(a:000, 0, {})
                              if has_key(new_context, 'no_start_insert')
                                    \ && new_context.no_start_insert
                                let new_context.start_insert = 0
                              endif
                              call extend(context, new_context)
                            
                              call unite#view#_switch_unite_buffer(context.buffer_name, context)
                            
                              " Set parameters.
                              let unite = b:unite
                              let unite.winnr = winnr
                              if !context.unite__direct_switch
                                let unite.win_rest_cmd = win_rest_cmd
                              endif
                              let unite.redrawtime_save = &redrawtime
                              let unite.access_time = localtime()
                              let unite.context = context
                              let unite.is_finalized = 0
                            
                              call unite#set_current_unite(unite)
                            
                              call unite#view#_init_cursor()
                            endfunction"}}}
                            
    1              0.000012 function! unite#start#resume_from_temporary(context)  "{{{
                              if empty(a:context.old_buffer_info)
                                return
                              endif
                            
                              call unite#handlers#_on_buf_unload(a:context.buffer_name)
                            
                              let unite_save = unite#get_current_unite()
                            
                              " Resume unite buffer.
                              let buffer_info = a:context.old_buffer_info[0]
                              call unite#start#resume(buffer_info.buffer_name,
                                    \ {'unite__direct_switch' : 1})
                              call setpos('.', buffer_info.pos)
                              let a:context.old_buffer_info = a:context.old_buffer_info[1:]
                            
                              " Overwrite unite.
                              let unite = unite#get_current_unite()
                              let unite.prev_bufnr = unite_save.prev_bufnr
                              let unite.prev_winnr = unite_save.prev_winnr
                            
                              call unite#redraw()
                            endfunction"}}}
                            
    1              0.000011 function! unite#start#complete(sources, ...) "{{{
                              let sources = type(a:sources) == type('') ?
                                    \ [a:sources] : a:sources
                              let context = {
                                    \ 'col' : col('.'), 'complete' : 1,
                                    \ 'direction' : 'rightbelow',
                                    \ 'buffer_name' : 'completion',
                                    \ 'here' : 1,
                                    \ }
                              call extend(context, get(a:000, 0, {}))
                            
                              return printf("\<ESC>:call unite#start(%s, %s)\<CR>",
                                    \  string(sources), string(context))
                            endfunction "}}}
                            
    1              0.000013 function! s:get_candidates(sources, context) "{{{
                              try
                                let current_unite = unite#init#_current_unite(a:sources, a:context)
                              catch /^unite.vim: Invalid /
                                return []
                              endtry
                            
                              " Caching.
                              let current_unite.last_input = a:context.input
                              let current_unite.input = a:context.input
                              call unite#set_current_unite(current_unite)
                              call unite#set_context(a:context)
                            
                              call unite#variables#enable_current_unite()
                            
                              call unite#candidates#_recache(a:context.input, a:context.is_redraw)
                            
                              let candidates = []
                              for source in current_unite.sources
                                if !empty(source.unite__candidates)
                                  let candidates += source.unite__candidates
                                endif
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000010 function! s:get_resume_buffer(buffer_name) "{{{
                              let buffer_name = a:buffer_name
                              if buffer_name !~ '@\d\+$'
                                " Add postfix.
                                let prefix = '[unite] - '
                                let prefix .= buffer_name
                                let buffer_name .= unite#helper#get_postfix(prefix, 0)
                              endif
                            
                              let buffer_dict = {}
                              for unite in map(filter(range(1, bufnr('$')),
                                    \ "getbufvar(v:val, '&filetype') ==# 'unite' &&
                                    \  type(getbufvar(v:val, 'unite')) == type({})"),
                                    \ "getbufvar(v:val, 'unite')")
                                let buffer_dict[unite.buffer_name] = unite.bufnr
                              endfor
                            
                              return get(buffer_dict, buffer_name, -1)
                            endfunction"}}}
                            
    1              0.000036 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/init.vim
Sourced 1 time
Total time:   0.000630
 Self time:   0.000630

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 30 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " Global options definition. "{{{
    1              0.000009 let g:unite_ignore_source_files =
                                  \ get(g:, 'unite_ignore_source_files', [])
                            "}}}
                            
    1              0.000004 function! unite#init#_context(context, ...) "{{{
                              let source_names = get(a:000, 0, [])
                            
                              let profile_name = get(a:context, 'profile_name',
                                    \ ((len(source_names) == 1 && !has_key(a:context, 'buffer_name')) ?
                                    \    'source/' . source_names[0] :
                                    \    get(a:context, 'buffer_name', 'default')))
                            
                              " Overwrite default_context by profile context.
                              let default_context = extend(copy(unite#variables#default_context()),
                                    \ unite#custom#get_profile(profile_name, 'context'))
                            
                              let context = extend(default_context, a:context)
                            
                              if context.temporary || context.script
                                " User can overwrite context by profile context.
                                let context = extend(context,
                                      \ unite#custom#get_profile(profile_name, 'context'))
                              endif
                            
                              " Complex initializer.
                              if get(context, 'complete', 1) && !has_key(a:context, 'start_insert')
                                let context.start_insert = 1
                              endif
                              if get(context, 'no_start_insert', 0)
                                " Disable start insert.
                                let context.start_insert = 0
                              endif
                              if has_key(context, 'horizontal')
                                " Disable vertically.
                                let context.vertical = 0
                              endif
                              if context.immediately
                                " Ignore empty unite buffer.
                                let context.no_empty = 1
                              endif
                              if context.tab
                                let context.no_split = 1
                              endif
                              if !has_key(context, 'short_source_names')
                                let context.short_source_names = g:unite_enable_short_source_names
                              endif
                              if get(context, 'long_source_names', 0)
                                " Disable short name.
                                let context.short_source_names = 0
                              endif
                              if &l:modified && !&l:hidden
                                " Split automatically.
                                let context.no_split = 0
                              endif
                              if !has_key(a:context, 'buffer_name') && context.script
                                " Set buffer-name automatically.
                                let context.buffer_name = join(source_names)
                              endif
                            
                              let context.is_changed = 0
                            
                              return context
                            endfunction"}}}
                            
    1              0.000004 function! unite#init#_unite_buffer() "{{{
                              let current_unite = unite#variables#current_unite()
                              let is_bufexists = bufexists(current_unite.real_buffer_name)
                              let current_unite.context.real_buffer_name =
                                    \ current_unite.real_buffer_name
                            
                              let context = current_unite.context
                            
                              if !context.temporary && context.tab
                                tabnew
                              endif
                            
                              call unite#view#_switch_unite_buffer(
                                    \ current_unite.buffer_name, context)
                            
                              let b:unite = current_unite
                              let unite = unite#get_current_unite()
                            
                              let unite.bufnr = bufnr('%')
                            
                              " Note: If unite buffer initialize is incomplete, &modified or &modifiable.
                              if !is_bufexists || &modified || &modifiable
                                " Basic settings.
                                setlocal bufhidden=hide
                                setlocal buftype=nofile
                                setlocal nolist
                                setlocal nobuflisted
                                setlocal noswapfile
                                setlocal nospell
                                setlocal noreadonly
                                setlocal nofoldenable
                                setlocal nomodeline
                                setlocal nonumber
                                setlocal foldcolumn=0
                                setlocal iskeyword+=-,+,\\,!,~
                                setlocal matchpairs-=<:>
                                setlocal completefunc=unite#dummy_completefunc
                                setlocal omnifunc=
                                match
                                if has('conceal')
                                  setlocal conceallevel=3
                                  setlocal concealcursor=n
                                endif
                                if exists('+cursorcolumn')
                                  setlocal nocursorcolumn
                                endif
                                if exists('+colorcolumn')
                                  setlocal colorcolumn=0
                                endif
                                if exists('+relativenumber')
                                  setlocal norelativenumber
                                endif
                            
                                " Autocommands.
                                augroup plugin-unite
                                  autocmd! * <buffer>
                                  autocmd InsertEnter <buffer>
                                        \ call unite#handlers#_on_insert_enter()
                                  autocmd InsertLeave <buffer>
                                        \ call unite#handlers#_on_insert_leave()
                                  autocmd CursorHoldI <buffer>
                                        \ call unite#handlers#_on_cursor_hold_i()
                                  autocmd CursorMovedI <buffer>
                                        \ call unite#handlers#_on_cursor_moved_i()
                                  autocmd CursorMoved,CursorMovedI <buffer>  nested
                                        \ call unite#handlers#_on_cursor_moved()
                                  autocmd BufUnload,BufHidden <buffer>
                                        \ call unite#handlers#_on_buf_unload(expand('<afile>'))
                                  autocmd WinEnter,BufWinEnter <buffer>
                                        \ call unite#handlers#_on_bufwin_enter(bufnr(expand('<abuf>')))
                                  autocmd WinLeave,BufWinLeave <buffer>
                                        \ call unite#handlers#_restore_updatetime()
                                augroup END
                            
                                if v:version > 703 || v:version == 703 && has('patch418')
                                  " Enable auto narrow feature.
                                  autocmd plugin-unite InsertCharPre <buffer>
                                        \ call unite#handlers#_on_insert_char_pre()
                                endif
                            
                                call unite#mappings#define_default_mappings()
                              endif
                            
                              let &l:wrap = context.wrap
                            
                              if exists('&redrawtime')
                                " Save redrawtime
                                let unite.redrawtime_save = &redrawtime
                                let &redrawtime = 100
                              endif
                            
                              call unite#handlers#_save_updatetime()
                            
                              " User's initialization.
                              setlocal nomodifiable
                              set sidescrolloff=0
                              setlocal nocursorline
                              setfiletype unite
                            endfunction"}}}
                            
    1              0.000005 function! unite#init#_current_unite(sources, context) "{{{
                              let context = a:context
                            
                              " Quit previous unite buffer.
                              if !context.create && !context.temporary
                                    \ && context.unite__is_interactive
                                let winnr = unite#helper#get_unite_winnr(context.buffer_name)
                                if winnr > 0 && unite#helper#get_source_args(a:sources) !=#
                                      \ getbufvar(winbufnr(winnr), 'unite').args
                                  " Quit unite buffer.
                                  execute winnr 'wincmd w'
                            
                                  if context.input == ''
                                    " Get input text.
                                    let context.input = unite#helper#get_input()
                                  endif
                            
                                  " Get winwidth.
                                  let context.winwidth = winwidth(0)
                            
                                  " Get winheight.
                                  let context.winheight = winheight(0)
                            
                                  call unite#force_quit_session()
                                endif
                              endif
                            
                              " The current buffer is initialized.
                              let buffer_name = '[unite] - '
                              let buffer_name .= context.buffer_name
                            
                              let winnr = winnr()
                              let win_rest_cmd = winrestcmd()
                            
                              " Check sources.
                              let sources = unite#init#_loaded_sources(a:sources, a:context)
                            
                              " Set parameters.
                              let unite = {}
                              let unite.winnr = winnr
                              let unite.win_rest_cmd = (!context.unite__direct_switch) ?
                                    \ win_rest_cmd : ''
                              let unite.context = context
                              let unite.current_candidates = []
                              let unite.sources = sources
                              let unite.source_names = unite#helper#get_source_names(sources)
                              let unite.buffer_name = (context.buffer_name == '') ?
                                    \ 'default' : context.buffer_name
                              let unite.profile_name =
                                    \ (context.profile_name != '') ? context.profile_name :
                                    \ (len(sources) == 1) ? 'source/' . sources[0].name :
                                    \ unite.buffer_name
                              let unite.prev_bufnr = bufnr('%')
                              let unite.prev_winnr = winnr()
                              let unite.update_time_save = &updatetime
                              let unite.statusline = '*unite* : %{unite#get_status_string()}'
                            
                              " Create new buffer name.
                              let postfix = unite#helper#get_postfix(
                                    \ buffer_name, unite.context.create)
                              let unite.buffer_name .= postfix
                            
                              let unite.real_buffer_name = buffer_name . postfix
                              let unite.prompt = context.prompt
                              let unite.input = context.input
                              let unite.last_input = context.input
                              let unite.sidescrolloff_save = &sidescrolloff
                              let unite.prompt_linenr = 1
                              let unite.is_async =
                                    \ len(filter(copy(sources),
                                    \  'v:val.unite__context.is_async')) > 0
                              let unite.access_time = localtime()
                              let unite.is_finalized = 0
                              let unite.previewd_buffer_list = []
                              let unite.post_filters = unite#util#convert2list(
                                    \ unite#custom#get_profile(unite.profile_name, 'filters'))
                              let unite.preview_candidate = {}
                              let unite.highlight_candidate = {}
                              let unite.max_source_name = 0
                              let unite.candidates_pos = 0
                              let unite.candidates = []
                              let unite.max_source_candidates = 0
                              let unite.is_multi_line = 0
                              let unite.args = unite#helper#get_source_args(a:sources)
                              let unite.msgs = []
                              let unite.err_msgs = []
                              let unite.redraw_hold_candidates = (unite#util#has_lua() ? 20000 : 10000)
                              let unite.disabled_max_candidates = 0
                              let unite.cursor_line_time = reltime()
                            
                              if context.here
                                let context.winheight = winheight(0) - winline() +
                                      \ unite.prompt_linenr + 1
                                if context.winheight < 7
                                  let context.winheight = 7
                                endif
                              endif
                            
                              " Preview windows check.
                              let unite.has_preview_window =
                                    \ len(filter(range(1, winnr('$')),
                                    \  'getwinvar(v:val, "&previewwindow")')) > 0
                            
                              call unite#set_current_unite(unite)
                              call unite#set_context(context)
                            
                              if !context.unite__is_complete
                                call unite#helper#call_hook(sources, 'on_init')
                              endif
                            
                              return unite
                            endfunction"}}}
                            
    1              0.000003 function! unite#init#_candidates(candidates) "{{{
                              let unite = unite#get_current_unite()
                              let context = unite.context
                              let [max_width, max_source_name] =
                                    \ unite#helper#adjustments(winwidth(0)-5, unite.max_source_name, 2)
                              let is_multiline = 0
                            
                              let candidates = []
                              for candidate in a:candidates
                                let candidate.unite__abbr =
                                      \ get(candidate, 'abbr', candidate.word)
                            
                                " Delete too long abbr.
                                if !&l:wrap && (candidate.is_multiline || context.multi_line)
                                  let candidate.unite__abbr =
                                        \ candidate.unite__abbr[: max_width *
                                        \  (context.max_multi_lines + 1)+10]
                                elseif len(candidate.unite__abbr) > max_width * 2 && !context.wrap
                                  let candidate.unite__abbr =
                                        \ candidate.unite__abbr[: max_width * 2]
                                endif
                            
                                " Substitute tab.
                                if candidate.unite__abbr =~ '\t'
                                  let candidate.unite__abbr = substitute(
                                        \ candidate.unite__abbr, '\t',
                                        \ repeat(' ', &tabstop), 'g')
                                endif
                            
                                if context.wrap || (!candidate.is_multiline && !context.multi_line)
                                  call add(candidates, candidate)
                                  continue
                                endif
                            
                                if candidate.unite__abbr !~ '\n'
                                  " Auto split.
                                  let abbr = candidate.unite__abbr
                                  let candidate.unite__abbr = ''
                            
                                  while abbr !~ '^\s\+$'
                                    let trunc_abbr = unite#util#strwidthpart(
                                          \ abbr, max_width)
                                    let candidate.unite__abbr .= trunc_abbr . "~\n"
                                    let abbr = '  ' . abbr[len(trunc_abbr):]
                                  endwhile
                            
                                  let candidate.unite__abbr =
                                        \ substitute(candidate.unite__abbr,
                                        \    '\~\n$', '', '')
                                else
                                  let candidate.unite__abbr =
                                        \ substitute(candidate.unite__abbr,
                                        \    '\r\?\n$', '^@', '')
                                endif
                            
                                if candidate.unite__abbr !~ '\n'
                                  let candidate.is_multiline = 0
                                  call add(candidates, candidate)
                                  continue
                                endif
                            
                                " Convert multi line.
                                let cnt = 0
                                for multi in split(
                                      \ candidate.unite__abbr, '\r\?\n', 1)[:
                                      \   context.max_multi_lines-1]
                                  let candidate_multi = (cnt != 0) ?
                                        \ deepcopy(candidate) : candidate
                                  let candidate_multi.unite__abbr =
                                        \ (cnt == 0 ? '+ ' : '| ') . multi
                            
                                  if cnt != 0
                                    let candidate_multi.is_dummy = 1
                                  endif
                            
                                  let is_multiline = 1
                                  call add(candidates, candidate_multi)
                            
                                  let cnt += 1
                                endfor
                              endfor
                            
                              " Multiline check.
                              if is_multiline || context.multi_line
                                for candidate in filter(copy(candidates), '!v:val.is_multiline')
                                  let candidate.unite__abbr = '  ' . candidate.unite__abbr
                                endfor
                            
                                let unite.is_multi_line = 1
                              endif
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000004 function! unite#init#_candidates_source(candidates, source_name) "{{{
                              let source = unite#variables#loaded_sources(a:source_name)
                            
                              let default_candidate = {
                                    \ 'kind' : source.default_kind,
                                    \ 'is_dummy' : 0,
                                    \ 'is_matched' : 1,
                                    \ 'is_multiline' : 0,
                                    \ 'unite__is_marked' : 0,
                                    \ }
                            
                              let candidates = []
                              for candidate in a:candidates
                                let candidate = extend(candidate, default_candidate, 'keep')
                                let candidate.source = a:source_name
                            
                                call add(candidates, candidate)
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000004 function! unite#init#_default_scripts(kind, names) "{{{
                              let names = empty(a:names) ? [''] : a:names
                              if a:kind ==# 'sources' && !empty(a:names)
                                call add(names, 'alias')
                            
                                if !exists('*neobundle#autoload#unite_sources')
                                  " Dummy call.
                                  try
                                    call neobundle#autoload#unite_sources([])
                                  catch /E117.*/
                                  endtry
                                endif
                            
                                if exists('*neobundle#autoload#unite_sources')
                                  call neobundle#autoload#unite_sources(a:names)
                                endif
                              endif
                            
                              let loaded_defaults = unite#variables#loaded_defaults()
                            
                              if get(loaded_defaults, a:kind, '') ==# &runtimepath
                                return
                              endif
                            
                              let static = unite#variables#static()
                            
                              for name in names
                                if name != '' && has_key(static[a:kind], name)
                                      \ || (a:kind ==# 'sources' && name ==# 'alias' &&
                                      \     has_key(loaded_defaults, 'alias'))
                                  continue
                                endif
                            
                                if name == ''
                                  let loaded_defaults[a:kind] = &runtimepath
                                elseif a:kind ==# 'sources' && name ==# 'alias'
                                  let loaded_defaults.alias = 1
                                endif
                            
                                " Search files by prefix or postfix.
                                if a:kind ==# 'filters'
                                  let prefix_name = substitute(name,
                                        \'^\%(matcher\|sorter\|converter\)_[^/_-]\+\zs[/_-].*$', '', '')
                                  let postfix_name = ''
                                  let postfix_name2 = ''
                                else
                                  let prefix_name = matchstr(name, '^[^/_-]\+')
                                  let postfix_name = matchstr(name, '[^/_-]\+$')
                                  let postfix_name2 = matchstr(name, '^[^/_-]\+[/_-]\+\zs[^/_-]\+')
                                endif
                            
                                let files = []
                                for prefix in filter(unite#util#uniq([
                                      \ prefix_name, postfix_name, postfix_name2]),
                                      \ "name == '' || v:val != ''")
                                  let files += split(globpath(&runtimepath,
                                        \ 'autoload/unite/'.a:kind.'/'.prefix.'*.vim', 1), '\n')
                                endfor
                            
                                if a:kind == 'sources'
                                  call filter(files, "index(g:unite_ignore_source_files,
                                        \ fnamemodify(v:val, ':t')) < 0")
                                endif
                            
                                for define in map(files,
                                      \ "unite#{a:kind}#{fnamemodify(v:val, ':t:r')}#define()")
                                  for dict in filter(unite#util#convert2list(define),
                                        \ '!empty(v:val) && !has_key(static[a:kind], v:val.name)')
                                    let static[a:kind][dict.name] = dict
                                  endfor
                                  unlet define
                                endfor
                              endfor
                            endfunction"}}}
                            
    1              0.000004 function! unite#init#_kinds() "{{{
                              let kinds = extend(copy(unite#variables#static().kinds),
                                    \ unite#variables#dynamic().kinds)
                              for kind in values(filter(copy(kinds),
                                    \ '!has_key(v:val, "is_initialized")'))
                                let kind.is_initialized = 1
                                if !has_key(kind, 'action_table')
                                  let kind.action_table = {}
                                endif
                                if !has_key(kind, 'alias_table')
                                  let kind.alias_table = {}
                                endif
                                if !has_key(kind, 'parents')
                                  let kind.parents = ['common']
                                endif
                              endfor
                            
                              return kinds
                            endfunction"}}}
    1              0.000003 function! unite#init#_filters() "{{{
                              return extend(copy(unite#variables#static().filters),
                                    \ unite#variables#dynamic().filters)
                            endfunction"}}}
                            
    1              0.000003 function! unite#init#_loaded_sources(sources, context) "{{{
                              let all_sources = unite#init#_sources(
                                    \ unite#helper#get_source_names(a:sources))
                              let sources = []
                            
                              let number = 0
                              for [source, args] in unite#helper#get_source_args(a:sources)
                                if type(source) == type('')
                                  let source_name = source
                                  unlet source
                                  if !has_key(all_sources, source_name)
                                    if a:context.unite__is_vimfiler || a:context.unite__is_complete
                                      " Ignore error.
                                      continue
                                    endif
                            
                                    if source_name =~ '^-'
                                      call unite#util#print_error(
                                            \ 'unite.vim: Invalid option "' .
                                            \ source_name . '" is detected.')
                                      throw 'unite.vim: Invalid option'
                                    else
                                      call unite#util#print_error(
                                            \ 'unite.vim: Invalid source name "' .
                                            \ source_name . '" is detected.')
                                      throw 'unite.vim: Invalid source'
                                    endif
                                  endif
                            
                                  let source = deepcopy(all_sources[source_name])
                                else
                                  " Use source dictionary.
                                  call unite#init#_sources(source)
                                endif
                            
                                let source.args = args
                                let source.unite__is_invalidate = 1
                            
                                let source.unite__context = deepcopy(a:context)
                                let source.unite__context.is_async =
                                      \ has_key(source, 'async_gather_candidates')
                                let source.unite__context.source = source
                                let source.unite__candidates = []
                                let source.unite__cached_candidates = []
                                let source.unite__cached_change_candidates = []
                                let source.unite__number = number
                                let number += 1
                            
                                call add(sources, source)
                            
                                unlet source
                              endfor
                            
                              return sources
                            endfunction"}}}
                            
    1              0.000003 function! unite#init#_sources(...) "{{{
                              " args: source_names or source_definition
                            
                              " Initialize load.
                              if type(get(a:000, 0, [])) != type({})
                                let source_names = type(get(a:000, 0, [])) == type([]) ?
                                      \ get(a:000, 0, []) : []
                                let head_name = get(a:000, 1, '')
                                if empty(source_names) && head_name != ''
                                  let source_names = [head_name]
                                endif
                                call unite#init#_default_scripts('sources', source_names)
                              endif
                            
                              let default_source = {
                                    \ 'is_volatile' : 0,
                                    \ 'is_listed' : 1,
                                    \ 'is_forced' : 0,
                                    \ 'required_pattern_length' : 0,
                                    \ 'action_table' : {},
                                    \ 'default_action' : {},
                                    \ 'default_kind' : 'common',
                                    \ 'alias_table' : {},
                                    \ 'parents' : [],
                                    \ 'description' : '',
                                    \ 'syntax' : '',
                                    \ }
                            
                              let sources = {}
                              let sources = extend(sources,
                                    \ unite#variables#static().sources)
                              let sources = extend(sources,
                                    \ unite#variables#dynamic().sources)
                              if type(get(a:000, 0, [])) == type({})
                                let sources[a:1.name] = a:1
                              endif
                            
                              let custom = unite#custom#get()
                            
                              for source in type(sources) == type([]) ?
                                    \ sources : values(sources)
                                try
                                  if !get(source, 'is_initialized', 0)
                                    let source.is_initialized = 1
                            
                                    if !has_key(source, 'hooks')
                                      let source.hooks = {}
                                    elseif has_key(source.hooks, 'on_pre_init')
                                      " Call pre_init hook.
                            
                                      " Set dummy value.
                                      let source.args = []
                                      let source.unite__context = { 'source' : source }
                            
                                      " Overwrite source values.
                                      call unite#helper#call_hook([source], 'on_pre_init')
                                    endif
                            
                                    let source = extend(source, default_source, 'keep')
                            
                                    if !empty(source.action_table)
                                      let action = values(source.action_table)[0]
                            
                                      " Check if '*' action_table?
                                      if has_key(action, 'func')
                                            \ && type(action.func) == type(function('type'))
                                        " Syntax sugar.
                                        let source.action_table = { '*' : source.action_table }
                                      endif
                                    endif
                            
                                    if type(source.default_action) == type('')
                                      " Syntax sugar.
                                      let source.default_action = { '*' : source.default_action }
                                    endif
                            
                                    if !empty(source.alias_table)
                                      " Check if '*' alias_table?
                                      if type(values(source.alias_table)[0]) == type('')
                                        " Syntax sugar.
                                        let source.alias_table = { '*' : source.alias_table }
                                      endif
                                    endif
                                    if source.is_volatile
                                          \ && !has_key(source, 'change_candidates')
                                      let source.change_candidates = source.gather_candidates
                                      call remove(source, 'gather_candidates')
                                    endif
                                  endif
                            
                                  " For custom sources.
                                  let custom_source = get(custom.sources, source.name, {})
                            
                                  " Set filters.
                                  if has_key(custom_source, 'filters')
                                    let source.filters = custom_source.filters
                                  elseif !has_key(source, 'filters')
                                        \ || has_key(custom_source, 'matchers')
                                        \ || has_key(custom_source, 'sorters')
                                        \ || has_key(custom_source, 'converters')
                                    let matchers = unite#util#convert2list(
                                          \ get(custom_source, 'matchers',
                                          \   get(source, 'matchers', 'matcher_default')))
                                    let sorters = unite#util#convert2list(
                                          \ get(custom_source, 'sorters',
                                          \   get(source, 'sorters', 'sorter_default')))
                                    let converters = unite#util#convert2list(
                                          \ get(custom_source, 'converters',
                                          \   get(source, 'converters', 'converter_default')))
                                    let source.filters = matchers + sorters + converters
                                  endif
                            
                                  let source.max_candidates =
                                        \ get(custom_source, 'max_candidates',
                                        \    get(source, 'max_candidates', 0))
                                  let source.ignore_pattern =
                                        \ get(custom_source, 'ignore_pattern',
                                        \    get(source, 'ignore_pattern', ''))
                                  let source.variables =
                                        \ extend(get(custom_source, 'variables', {}),
                                        \    get(source, 'variables', {}), 'keep')
                            
                                  let source.unite__len_candidates = 0
                                  let source.unite__orig_len_candidates = 0
                                  let source.unite__candidates = []
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error(
                                        \ '[unite.vim] Error occured in source initialization!')
                                  call unite#print_error(
                                        \ '[unite.vim] Source name is ' . source.name)
                                endtry
                              endfor
                            
                              return sources
                            endfunction"}}}
                            
    1              0.000003 function! unite#init#_tab_variables() "{{{
                              if !exists('t:unite')
                                let t:unite = { 'last_unite_bufnr' : -1 }
                              endif
                            endfunction"}}}
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/neocomplete.vim/autoload/vital/_b6a796b.vim
Sourced 1 time
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
                            let s:self_version = expand('<sfile>:t:r')
                            
                            " Note: The extra argument to globpath() was added in Patch 7.2.051.
    1              0.000006 let s:globpath_third_arg = v:version > 702 || v:version == 702 && has('patch51')
                            
    1              0.000002 let s:loaded = {}
                            
    1              0.000004 function! s:import(name, ...)
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = s:_import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
                            
    1              0.000002 function! s:load(...) dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                while 1 <= len(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == type({})
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                            
                                if exists('dict')
                                  call extend(dict, s:_import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
                            
    1              0.000001 function! s:unload()
                              let s:loaded = {}
                            endfunction
                            
    1              0.000002 function! s:_import(name)
                              if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
                              let path = s:_get_module_path(a:name)
                              if path ==# ''
                                throw 'vital: module not found: ' . a:name
                              endif
                              let sid = get(s:_scripts(), path, 0)
                              if !sid
                                try
                                  execute 'source' fnameescape(path)
                                catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
                                let sid = s:_scripts()[path]
                              endif
                              return s:_build_module(sid)
                            endfunction
                            
    1              0.000002 function! s:_get_module_path(name)
                              if s:_is_absolute_path(a:name) && filereadable(a:name)
                                return s:_unify_path(a:name)
                              endif
                              if a:name ==# ''
                                let tailpath = printf('autoload/vital/%s.vim', s:self_version)
                              elseif a:name =~# '\v^\u\w*%(\.\u\w*)*$'
                                let target = '/' . substitute(a:name, '\W\+', '/', 'g')
                                let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
                              else
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                            
                              if s:globpath_third_arg
                                let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
                              else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
                              call filter(paths, 'filereadable(v:val)')
                              return s:_unify_path(get(paths, 0, ''))
                            endfunction
                            
    1              0.000002 function! s:_scripts()
                              let scripts = {}
                              for line in filter(split(s:_redir('scriptnames'), "\n"),
                              \                  'stridx(v:val, s:self_version) > 0')
                                let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if !empty(list)
                                  let scripts[s:_unify_path(list[2])] = list[1] - 0
                                endif
                              endfor
                              return scripts
                            endfunction
                            
    1              0.000010 if filereadable(expand('<sfile>:r') . '.VIM')
                              function! s:_unify_path(path)
                                " Note: On windows, vim can't expand path names from 8.3 formats.
                                " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                                " vital load duplicated scripts. Below's :~ avoid this issue.
                                return tolower(fnamemodify(resolve(fnamemodify(
                                \              a:path, ':p:gs?[\\/]\+?/?')), ':~'))
                              endfunction
                            else
    1              0.000002   function! s:_unify_path(path)
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]\+?/?'))
                              endfunction
    1              0.000001 endif
                            
                            " Copy from System.Filepath
    1              0.000010 if has('win16') || has('win32') || has('win64')
                              function! s:_is_absolute_path(path)
                                return a:path =~? '^[a-z]:[/\\]'
                              endfunction
                            else
    1              0.000002   function! s:_is_absolute_path(path)
                                return a:path[0] ==# '/'
                              endfunction
    1              0.000002 endif
                            
    1              0.000002 function! s:_build_module(sid)
                              if has_key(s:loaded, a:sid)
                                return copy(s:loaded[a:sid])
                              endif
                              let functions = s:_get_functions(a:sid)
                            
                              let prefix = '<SNR>' . a:sid . '_'
                              let module = {}
                              for func in functions
                                let module[func] = function(prefix . func)
                              endfor
                              if has_key(module, '_vital_loaded')
                                let V = vital#{s:self_version}#new()
                                if has_key(module, '_vital_depends')
                                  call call(V.load, module._vital_depends(), V)
                                endif
                                try
                                  call module._vital_loaded(V)
                                catch
                                  " FIXME: Show an error message for debug.
                                endtry
                              endif
                              if !get(g:, 'vital_debug', 0)
                                call filter(module, 'v:key =~# "^\\a"')
                              endif
                              let s:loaded[a:sid] = module
                              return copy(module)
                            endfunction
                            
    1              0.000007 if exists('+regexpengine')
                              function! s:_get_functions(sid)
                                let funcs = s:_redir(printf("function /\\%%#=2^\<SNR>%d_", a:sid))
                                let map_pat = '<SNR>' . a:sid . '_\zs\w\+'
                                return map(split(funcs, "\n"), 'matchstr(v:val, map_pat)')
                              endfunction
                            else
    1              0.000002   function! s:_get_functions(sid)
                                let prefix = '<SNR>' . a:sid . '_'
                                let funcs = s:_redir('function')
                                let filter_pat = '^\s*function ' . prefix
                                let map_pat = prefix . '\zs\w\+'
                                return map(filter(split(funcs, "\n"),
                                \          'stridx(v:val, prefix) > 0 && v:val =~# filter_pat'),
                                \          'matchstr(v:val, map_pat)')
                              endfunction
    1              0.000001 endif
                            
    1              0.000002 function! s:_redir(cmd)
                              let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                              set verbose=0 verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                              return res
                            endfunction
                            
    1              0.000007 function! vital#{s:self_version}#new()
                              return s:_import('').load(['Prelude', ''])
                            endfunction

SCRIPT  /home/skl/.vim/bundle/neocomplete.vim/autoload/vital/_b6a796b/Prelude.vim
Sourced 1 time
Total time:   0.000566
 Self time:   0.000566

count  total (s)   self (s)
                            let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
                            " glob() wrapper which returns List
                            " and 'wildignore' does not affect
                            " this function's return value.
    1              0.000011 if v:version ># 703 ||
                            \  (v:version is 703 && has('patch465'))
    1              0.000005   function! s:glob(expr)
                                return glob(a:expr, 1, 1)
                              endfunction
    1              0.000001 else
                              function! s:glob(expr)
                                let R = glob(a:expr, 1)
                                return split(R, '\n')
                              endfunction
                            endif
                            
                            " globpath() wrapper which returns List
                            " and 'suffixes' and 'wildignore' does not affect
                            " this function's return value.
    1              0.000003 function! s:globpath(path, expr)
                              let R = globpath(a:path, a:expr, 1)
                              return split(R, '\n')
                            endfunction
                            
                            " Wrapper functions for type().
    1              0.000027 let [
                            \   s:__TYPE_NUMBER,
                            \   s:__TYPE_STRING,
                            \   s:__TYPE_FUNCREF,
                            \   s:__TYPE_LIST,
                            \   s:__TYPE_DICT,
                            \   s:__TYPE_FLOAT] = [
                                  \   type(3),
                                  \   type(""),
                                  \   type(function('tr')),
                                  \   type([]),
                                  \   type({}),
                                  \   has('float') ? type(str2float('0')) : -1]
                            " __TYPE_FLOAT = -1 when -float
                            " This doesn't match to anything.
                            
                            " Number or Float
    1              0.000003 function! s:is_numeric(Value)
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            
                            " Number
    1              0.000003 function! s:is_integer(Value)
                              echoerr 'Prelude.is_integer() is obsolete. Use its is_number() instead; they are equivalent.'
                              return s:is_number(a:Value)
                            endfunction
                            
    1              0.000002 function! s:is_number(Value)
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            
                            " Float
    1              0.000003 function! s:is_float(Value)
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            " String
    1              0.000002 function! s:is_string(Value)
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            " Funcref
    1              0.000002 function! s:is_funcref(Value)
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            " List
    1              0.000002 function! s:is_list(Value)
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            " Dictionary
    1              0.000002 function! s:is_dict(Value)
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
    1              0.000003 function! s:truncate_smart(str, max, footer_width, separator)
                              echoerr 'Prelude.truncate_smart() is obsolete. Use its truncate_skipping() instead; they are equivalent.'
                              return s:truncate_skipping(a:str, a:max, a:footer_width, a:separator)
                            endfunction
                            
    1              0.000004 function! s:truncate_skipping(str, max, footer_width, separator)
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000002 function! s:truncate(str, width)
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000003 function! s:strwidthpart(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000002 function! s:strwidthpart_reverse(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000003 if v:version >= 703
                              " Use builtin function.
    1              0.000002   function! s:wcswidth(str)
                                return strwidth(a:str)
                              endfunction
    1              0.000002 else
                              function! s:wcswidth(str)
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs)
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
                            endif
                            
    1              0.000013 let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
    1              0.000005 let s:is_cygwin = has('win32unix')
    1              0.000018 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000004 let s:is_unix = has('unix')
                            
    1              0.000003 function! s:is_windows()
                              return s:is_windows
                            endfunction
                            
    1              0.000004 function! s:is_cygwin()
                              return s:is_cygwin
                            endfunction
                            
    1              0.000002 function! s:is_mac()
                              return s:is_mac
                            endfunction
                            
    1              0.000002 function! s:is_unix()
                              return s:is_unix
                            endfunction
                            
    1              0.000002 function! s:print_error(message)
                              echohl ErrorMsg
                              for m in split(a:message, "\n")
                                echomsg m
                              endfor
                              echohl None
                            endfunction
                            
    1              0.000003 function! s:smart_execute_command(action, word)
                              execute a:action . ' ' . (a:word == '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000002 function! s:escape_file_searching(buffer_name)
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
                            
    1              0.000003 function! s:escape_pattern(str)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            
                            " iconv() wrapper for safety.
    1              0.000003 function! s:iconv(expr, from, to)
                              if a:from == '' || a:to == '' || a:from ==? a:to
                                return a:expr
                              endif
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr
                            endfunction
                            
                            " Like builtin getchar() but returns string always.
    1              0.000002 function! s:getchar(...)
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            
                            " Like builtin getchar() but returns string always.
                            " and do inputsave()/inputrestore() before/after getchar().
    1              0.000002 function! s:getchar_safe(...)
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type("") ? c : nr2char(c)
                            endfunction
                            
                            " Like builtin getchar() but
                            " do inputsave()/inputrestore() before/after input().
    1              0.000002 function! s:input_safe(...)
                                return s:input_helper('input', a:000)
                            endfunction
                            
                            " Do inputsave()/inputrestore() before/after calling a:funcname.
    1              0.000002 function! s:input_helper(funcname, args)
                                let success = 0
                                if inputsave() !=# success
                                    throw 'inputsave() failed'
                                endif
                                try
                                    return call(a:funcname, a:args)
                                finally
                                    if inputrestore() !=# success
                                        throw 'inputrestore() failed'
                                    endif
                                endtry
                            endfunction
                            
    1              0.000003 function! s:set_default(var, val)
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
                            
    1              0.000004 function! s:set_dictionary_helper(variable, keys, pattern)
                              for key in split(a:keys, '\s*,\s*')
                                if !has_key(a:variable, key)
                                  let a:variable[key] = a:pattern
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:substitute_path_separator(path)
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
                            
    1              0.000002 function! s:path2directory(path)
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
                            
    1              0.000003 function! s:_path2project_directory_git(path)
                              let parent = a:path
                            
                              while 1
                                let path = parent . '/.git'
                                if isdirectory(path) || filereadable(path)
                                  return parent
                                endif
                                let next = fnamemodify(parent, ':h')
                                if next == parent
                                  return ''
                                endif
                                let parent = next
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:_path2project_directory_svn(path)
                              let search_directory = a:path
                              let directory = ''
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir('.svn', find_directory . ';')
                              if d == ''
                                return ''
                              endif
                            
                              let directory = fnamemodify(d, ':p:h:h')
                            
                              " Search parent directories.
                              let parent_directory = s:path2directory(
                                    \ fnamemodify(directory, ':h'))
                            
                              if parent_directory != ''
                                let d = finddir('.svn', parent_directory . ';')
                                if d != ''
                                  let directory = s:_path2project_directory_svn(parent_directory)
                                endif
                              endif
                              return directory
                            endfunction
                            
    1              0.000003 function! s:_path2project_directory_others(vcs, path)
                              let vcs = a:vcs
                              let search_directory = a:path
                              let directory = ''
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir(vcs, find_directory . ';')
                              if d == ''
                                return ''
                              endif
                              return fnamemodify(d, ':p:h:h')
                            endfunction
                            
    1              0.000002 function! s:path2project_directory(path, ...)
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for vcs in ['.git', '.bzr', '.hg', '.svn']
                                if vcs ==# '.git'
                                  let directory = s:_path2project_directory_git(search_directory)
                                elseif vcs ==# '.svn'
                                  let directory = s:_path2project_directory_svn(search_directory)
                                else
                                  let directory = s:_path2project_directory_others(vcs, search_directory)
                                endif
                                if directory != ''
                                  break
                                endif
                              endfor
                            
                              " Search project file.
                              if directory == ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d != ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory == ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory == '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            
                            " Check vimproc.
    1              0.000002 function! s:has_vimproc()
                              if !exists('s:exists_vimproc')
                                try
                                  call vimproc#version()
                                  let s:exists_vimproc = 1
                                catch
                                  let s:exists_vimproc = 0
                                endtry
                              endif
                              return s:exists_vimproc
                            endfunction
                            
    1              0.000002 function! s:system(str, ...)
                              let command = a:str
                              let input = a:0 >= 1 ? a:1 : ''
                              let command = s:iconv(command, &encoding, 'char')
                              let input = s:iconv(input, &encoding, 'char')
                            
                              if a:0 == 0
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command) : system(command)
                              elseif a:0 == 1
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input) : system(command, input)
                              else
                                " ignores 3rd argument unless you have vimproc.
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input, a:2) : system(command, input)
                              endif
                            
                              let output = s:iconv(output, 'char', &encoding)
                            
                              return output
                            endfunction
                            
    1              0.000003 function! s:get_last_status()
                              return s:has_vimproc() ?
                                    \ vimproc#get_last_status() : v:shell_error
                            endfunction
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/skl/.vim/bundle/neocomplete.vim/autoload/vital/_b6a796b/Data/List.vim
Sourced 1 time
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
                            " Utilities for list.
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000004 function! s:pop(list)
                              return remove(a:list, -1)
                            endfunction
                            
    1              0.000003 function! s:push(list, val)
                              call add(a:list, a:val)
                              return a:list
                            endfunction
                            
    1              0.000002 function! s:shift(list)
                              return remove(a:list, 0)
                            endfunction
                            
    1              0.000004 function! s:unshift(list, val)
                              return insert(a:list, a:val)
                            endfunction
                            
    1              0.000002 function! s:cons(x, xs)
                              return [a:x] + a:xs
                            endfunction
                            
                            " TODO spec
    1              0.000002 function! s:conj(xs, x)
                              return a:xs + [a:x]
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000002 function! s:uniq(list, ...)
                              let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(a:0 ? list[i][1] : list[i])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:0 ? map(list, 'v:val[0]') : list
                            endfunction
                            
    1              0.000002 function! s:clear(list)
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction
                            
                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000002 function! s:concat(list)
                              let list = []
                              for Value in a:list
                                let list += Value
                              endfor
                              return list
                            endfunction
                            
                            " Flattens a list.
    1              0.000002 function! s:flatten(list, ...)
                              let limit = a:0 > 0 ? a:1 : -1
                              let list = []
                              if limit == 0
                                return a:list
                              endif
                              let limit -= 1
                              for Value in a:list
                                if type(Value) == type([])
                                  let list += s:flatten(Value, limit)
                                else
                                  call add(list, Value)
                                endif
                                unlet! Value
                              endfor
                              return list
                            endfunction
                            
                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000003 function! s:sort(list, expr)
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction
                            
    1              0.000003 function! s:_compare(a, b)
                              return eval(s:expr)
                            endfunction
                            
                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000002 function! s:sort_by(list, expr)
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction
                            
    1              0.000002 function! s:max(list, expr)
                              echoerr 'Data.List.max() is obsolete. Use its max_by() instead.'
                              return s:max_by(a:list, a:expr)
                            endfunction
                            
                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000002 function! s:max_by(list, expr)
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction
                            
    1              0.000002 function! s:min(list, expr)
                              echoerr 'Data.List.min() is obsolete. Use its min_by() instead.'
                              return s:min_by(a:list, a:expr)
                            endfunction
                            
                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000002 function! s:min_by(list, expr)
                              return s:max_by(a:list, '-(' . a:expr . ')')
                            endfunction
                            
                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000002 function! s:char_range(from, to)
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction
                            
                            " Returns true if a:list has a:value.
                            " Returns false otherwise.
    1              0.000003 function! s:has(list, value)
                              return index(a:list, a:value) isnot -1
                            endfunction
                            
                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000002 function! s:has_index(list, index)
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction
                            
                            " similar to Haskell's Data.List.span
    1              0.000002 function! s:span(f, xs)
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction
                            
                            " similar to Haskell's Data.List.break
    1              0.000003 function! s:break(f, xs)
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Data.List.takeWhile
    1              0.000003 function! s:take_while(f, xs)
                              return s:span(a:f, a:xs)[0]
                            endfunction
                            
                            " similar to Haskell's Data.List.partition
    1              0.000002 function! s:partition(f, xs)
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction
                            
                            " similar to Haskell's Prelude.all
    1              0.000002 function! s:all(f, xs)
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.any
    1              0.000002 function! s:any(f, xs)
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction
                            
                            " similar to Haskell's Prelude.and
    1              0.000002 function! s:and(xs)
                              return s:all('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.or
    1              0.000001 function! s:or(xs)
                              return s:any('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl
    1              0.000002 function! s:foldl(f, init, xs)
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl1
    1              0.000002 function! s:foldl1(f, xs)
                              if len(a:xs) == 0
                                throw 'foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction
                            
                            " similar to Haskell's Prelude.foldr
    1              0.000002 function! s:foldr(f, init, xs)
                              let memo = a:init
                              for i in reverse(range(0, len(a:xs) - 1))
                                let x = a:xs[i]
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.fold11
    1              0.000002 function! s:foldr1(f, xs)
                              if len(a:xs) == 0
                                throw 'foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction
                            
                            " similar to python's zip()
    1              0.000002 function! s:zip(...)
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction
                            
                            " similar to zip(), but goes until the longer one.
    1              0.000002 function! s:zip_fill(xs, ys, filler)
                              if empty(a:xs) && empty(a:ys)
                                return []
                              elseif empty(a:ys)
                                return s:cons([a:xs[0], a:filler], s:zip_fill(a:xs[1 :], [], a:filler))
                              elseif empty(a:xs)
                                return s:cons([a:filler, a:ys[0]], s:zip_fill([], a:ys[1 :], a:filler))
                              else
                                return s:cons([a:xs[0], a:ys[0]], s:zip_fill(a:xs[1 :], a:ys[1: ], a:filler))
                              endif
                            endfunction
                            
                            " Inspired by Ruby's with_index method.
    1              0.000002 function! s:with_index(list, ...)
                              let base = a:0 > 0 ? a:1 : 0
                              return s:zip(a:list, range(base, len(a:list)+base-1))
                            endfunction
                            
                            " similar to Ruby's detect or Haskell's find.
                            " TODO spec and doc
    1              0.000003 function! s:find(list, default, f)
                              for x in a:list
                                if eval(substitute(a:f, 'v:val', string(x), 'g'))
                                  return x
                                endif
                              endfor
                              return a:default
                            endfunction
                            
                            " Return non-zero if a:list1 and a:list2 have any common item(s).
                            " Return zero otherwise.
    1              0.000002 function! s:has_common_items(list1, list2)
                              return !empty(filter(copy(a:list1), 'index(a:list2, v:val) isnot -1'))
                            endfunction
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/sources/grep.vim
Sourced 1 time
Total time:   0.000447
 Self time:   0.000328

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: grep.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            "          Tomohiro Nishimura <tomohiro68 at gmail.com>
                            " Last Modified: 07 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Variables  "{{{
                            " Set from grepprg.
    1   0.000037   0.000012 call unite#util#set_default(
                                  \ 'g:unite_source_grep_command', 'grep')
    1   0.000026   0.000010 call unite#util#set_default(
                                  \ 'g:unite_source_grep_default_opts', '-inH')
                            
    1   0.000021   0.000005 call unite#util#set_default('g:unite_source_grep_recursive_opt', '-r')
    1   0.000022   0.000006 call unite#util#set_default('g:unite_source_grep_max_candidates', 100)
    1   0.000022   0.000006 call unite#util#set_default('g:unite_source_grep_search_word_highlight', 'Search')
    1   0.000026   0.000011 call unite#util#set_default('g:unite_source_grep_ignore_pattern',
                                  \'\~$\|\.\%(o\|exe\|dll\|bak\|sw[po]\)$\|'.
                                  \'\%(^\|/\)\.\%(hg\|git\|bzr\|svn\)\%($\|/\)\|'.
                                  \'\%(^\|/\)tags\%(-\a*\)\?$')
    1   0.000020   0.000005 call unite#util#set_default('g:unite_source_grep_encoding', 'char')
                            "}}}
                            
    1              0.000004 function! unite#sources#grep#define() "{{{
                              return s:source
                            endfunction "}}}
                            
    1              0.000022 let s:source = {
                                  \ 'name': 'grep',
                                  \ 'max_candidates': g:unite_source_grep_max_candidates,
                                  \ 'hooks' : {},
                                  \ 'syntax' : 'uniteSource__Grep',
                                  \ 'matchers' : 'matcher_regexp',
                                  \ 'ignore_pattern' : g:unite_source_grep_ignore_pattern,
                                  \ 'variables' : {
                                  \      'command' : g:unite_source_grep_command,
                                  \      'default_opts' : g:unite_source_grep_default_opts,
                                  \      'recursive_opt' : g:unite_source_grep_recursive_opt,
                                  \      'search_word_highlight' : g:unite_source_grep_search_word_highlight,
                                  \   },
                                  \ }
                            
    1              0.000004 function! s:source.hooks.on_init(args, context) "{{{
                              if !unite#util#has_vimproc()
                                call unite#print_source_error(
                                      \ 'vimproc is not installed.', s:source.name)
                                return
                              endif
                            
                              if type(get(a:args, 0, '')) == type([])
                                let a:context.source__target = a:args[0]
                                let targets = a:context.source__target
                              else
                                let default = get(a:args, 0, '')
                            
                                if default == ''
                                  let default = '.'
                                endif
                            
                                if type(get(a:args, 0, '')) == type('')
                                      \ && get(a:args, 0, '') == ''
                                      \ && a:context.input == ''
                                  let target = unite#util#substitute_path_separator(
                                        \ unite#util#input('Target: ', default, 'file'))
                                else
                                  let target = default
                                endif
                            
                                if target == '%' || target == '#'
                                  let target = unite#util#escape_file_searching(bufname(target))
                                elseif target ==# '$buffers'
                                  let target = join(map(filter(range(1, bufnr('$')),
                                        \ 'buflisted(v:val) && filereadable(bufname(v:val))'),
                                        \ 'unite#util#escape_file_searching(bufname(v:val))'))
                                elseif target == '**'
                                  " Optimized.
                                  let target = '.'
                                else
                                  " Escape filename.
                                  let target = escape(target, ' ')
                                endif
                            
                                let a:context.source__target = [target]
                            
                                let targets = map(filter(split(target), 'v:val !~ "^-"'),
                                      \ 'substitute(v:val, "\\*\\+$", "", "")')
                              endif
                            
                              let a:context.source__extra_opts = get(a:args, 1, '')
                            
                              let a:context.source__input = get(a:args, 2, a:context.input)
                              if a:context.source__input == ''
                                let a:context.source__input = unite#util#input('Pattern: ')
                              endif
                            
                              let a:context.source__directory =
                                    \ (len(targets) == 1) ?
                                    \ unite#util#substitute_path_separator(
                                    \  unite#util#expand(targets[0])) : ''
                            
                              let a:context.source__ssh_path = ''
                              if exists('b:vimfiler') &&
                                    \ exists('*vimfiler#get_current_vimfiler')
                                if !empty(b:vimfiler)
                                  let vimfiler = b:vimfiler
                                else
                                  let vimfiler = vimfiler#get_current_vimfiler()
                                endif
                            
                                if get(vimfiler, 'source', '') ==# 'ssh'
                                  let [hostname, port, path] =
                                        \ unite#sources#ssh#parse_path(
                                        \  vimfiler.source.':'.vimfiler.current_dir)
                                  let a:context.source__ssh_path =
                                        \ printf('%s://%s:%s/', vimfiler.source, hostname, port)
                            
                                  call map(a:context.source__target,
                                        \ "substitute(v:val, 'ssh://', '', '')")
                                endif
                              endif
                            endfunction"}}}
    1              0.000003 function! s:source.hooks.on_syntax(args, context) "{{{
                              if !unite#util#has_vimproc()
                                return
                              endif
                            
                              syntax case ignore
                              syntax region uniteSource__GrepLine
                                    \ start=' ' end='$'
                                    \ containedin=uniteSource__Grep
                              syntax match uniteSource__GrepFile /^[^:]*/ contained
                                    \ containedin=uniteSource__GrepLine
                                    \ nextgroup=uniteSource__GrepSeparator
                              syntax match uniteSource__GrepSeparator /:/ contained
                                    \ containedin=uniteSource__GrepLine
                                    \ nextgroup=uniteSource__GrepLineNr
                              syntax match uniteSource__GrepLineNr /\d\+\ze:/ contained
                                    \ containedin=uniteSource__GrepLine
                                    \ nextgroup=uniteSource__GrepPattern
                              execute 'syntax match uniteSource__GrepPattern /'
                                    \ . substitute(a:context.source__input, '\([/\\]\)', '\\\1', 'g')
                                    \ . '/ contained containedin=uniteSource__GrepLine'
                              highlight default link uniteSource__GrepFile Directory
                              highlight default link uniteSource__GrepLineNr LineNR
                              execute 'highlight default link uniteSource__GrepPattern'
                                    \ unite#get_source_variables(a:context).search_word_highlight
                            endfunction"}}}
    1              0.000003 function! s:source.hooks.on_close(args, context) "{{{
                              if has_key(a:context, 'source__proc')
                                call a:context.source__proc.kill()
                              endif
                            endfunction "}}}
    1              0.000002 function! s:source.hooks.on_post_filter(args, context) "{{{
                              for candidate in a:context.candidates
                                let candidate.kind = [((a:context.source__ssh_path != '') ?
                                      \ 'file/ssh' : 'file'), 'jump_list']
                                let candidate.action__directory =
                                      \ unite#util#path2directory(candidate.action__path)
                                let candidate.is_multiline = 1
                              endfor
                            endfunction"}}}
                            
    1              0.000002 function! s:source.gather_candidates(args, context) "{{{
                              let variables = unite#get_source_variables(a:context)
                              if !executable(variables.command)
                                call unite#print_source_message(printf(
                                      \ 'command "%s" is not executable.',
                                      \    variables.command), s:source.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
                              if !unite#util#has_vimproc()
                                call unite#print_source_message(
                                      \ 'vimproc plugin is not installed.', self.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
                              if empty(a:context.source__target)
                                    \ || a:context.source__input == ''
                                call unite#print_source_message('Canceled.', s:source.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
                              if a:context.is_redraw
                                let a:context.is_async = 1
                              endif
                            
                              let cmdline = printf('%s %s %s %s %s %s',
                                \   unite#util#substitute_path_separator(variables.command),
                                \   variables.default_opts,
                                \   variables.recursive_opt,
                                \   a:context.source__extra_opts,
                                \   string(a:context.source__input),
                                \   join(map(a:context.source__target,
                                \           "substitute(v:val, '/$', '', '')")),
                                \)
                              if a:context.source__ssh_path != ''
                                " Use ssh command.
                                let [hostname, port, path] =
                                      \ unite#sources#ssh#parse_path(a:context.source__ssh_path)
                                let cmdline = substitute(substitute(
                                      \ g:unite_kind_file_ssh_command . ' ' . cmdline,
                                      \   '\<HOSTNAME\>', hostname, 'g'), '\<PORT\>', port, 'g')
                              endif
                            
                              call unite#print_source_message('Command-line: ' . cmdline, s:source.name)
                            
                              let save_term = $TERM
                              try
                                " Disable colors.
                                let $TERM = 'dumb'
                            
                                let a:context.source__proc = vimproc#plineopen3(
                                      \ vimproc#util#iconv(cmdline, &encoding, 'char'), 1)
                              finally
                                let $TERM = save_term
                              endtry
                            
                              return self.async_gather_candidates(a:args, a:context)
                            endfunction "}}}
                            
    1              0.000003 function! s:source.async_gather_candidates(args, context) "{{{
                              let variables = unite#get_source_variables(a:context)
                            
                              if !has_key(a:context, 'source__proc')
                                let a:context.is_async = 0
                                call unite#print_source_message('Completed.', s:source.name)
                                return []
                              endif
                            
                              let stderr = a:context.source__proc.stderr
                              if !stderr.eof
                                " Print error.
                                let errors = filter(stderr.read_lines(-1, 100),
                                      \ "v:val !~ '^\\s*$'")
                                if !empty(errors)
                                  call unite#print_source_error(errors, s:source.name)
                                endif
                              endif
                            
                              let stdout = a:context.source__proc.stdout
                              if stdout.eof
                                " Disable async.
                                let a:context.is_async = 0
                                call unite#print_source_message('Completed.', s:source.name)
                            
                                call a:context.source__proc.waitpid()
                              endif
                            
                              let candidates = map(stdout.read_lines(-1, 100),
                                      \ "unite#util#iconv(v:val, g:unite_source_grep_encoding, &encoding)")
                              if variables.default_opts =~ '^-[^-]*l'
                                    \ || a:context.source__extra_opts =~ '^-[^-]*l'
                                let candidates = map(filter(candidates,
                                      \ 'v:val != ""'),
                                      \ '[v:val, [v:val[2:], 0]]')
                              else
                                let candidates = map(filter(candidates,
                                      \  'v:val =~ "^.\\+:.\\+$"'),
                                      \ '[v:val, split(v:val[2:], ":", 1)]')
                              endif
                            
                              if a:context.source__ssh_path != ''
                                " Use ssh command.
                                let [hostname, port, path] = unite#sources#ssh#parse_path(
                                      \     a:context.source__ssh_path)
                              endif
                            
                              let _ = []
                              for candidate in candidates
                                if len(candidate[1]) <= 1 || candidate[1][1] !~ '^\d\+$'
                                  let dict = {
                                        \   'action__path' : a:context.source__target[0],
                                        \ }
                                  if len(candidate[1]) <= 1
                                    let dict.action__line = candidate[0][:1][0]
                                    let dict.action__text = candidate[1][0]
                                  else
                                    let dict.action__line = candidate[0][:1].candidate[1][0]
                                    let dict.action__text = join(candidate[1][1:], ':')
                                  endif
                                else
                                  let dict = {
                                        \   'action__path' : candidate[0][:1].candidate[1][0],
                                        \   'action__line' : candidate[1][1],
                                        \   'action__text' : join(candidate[1][2:], ':'),
                                        \ }
                                endif
                            
                                if a:context.source__ssh_path != ''
                                  let dict.action__path =
                                        \ a:context.source__ssh_path . dict.action__path
                                else
                                  let dict.action__path =
                                        \ unite#util#substitute_path_separator(
                                        \   fnamemodify(dict.action__path, ':p'))
                                endif
                            
                                let dict.word = printf('%s:%s:%s',
                                      \  unite#util#substitute_path_separator(
                                      \     fnamemodify(dict.action__path, ':.')),
                                      \ dict.action__line, dict.action__text)
                            
                                call add(_, dict)
                              endfor
                            
                              return _
                            endfunction "}}}
                            
    1              0.000003 function! s:source.complete(args, context, arglead, cmdline, cursorpos) "{{{
                              return ['%', '#', '$buffers'] + unite#sources#file#complete_directory(
                                    \ a:args, a:context, a:arglead, a:cmdline, a:cursorpos)
                            endfunction"}}}
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/sources/alias.vim
Sourced 1 time
Total time:   0.000169
 Self time:   0.000148

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: alias.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            "          tacroe <tacroe at gmail.com>
                            " Last Modified: 31 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1   0.000030   0.000009 call unite#util#set_default('g:unite_source_alias_aliases', {})
                            
    1              0.000004 function! unite#sources#alias#define()
                              return s:make_aliases()
                            endfunction
                            
    1              0.000003 function! s:make_aliases()
                              let aliases = []
                              for [name, config] in items(g:unite_source_alias_aliases)
                                let args =
                                      \ (!has_key(config, 'args')) ? [] :
                                      \ (type(config.args) == type([])) ?
                                      \ config.args : [config.args]
                            
                                let alias = {}
                                let alias.name = name
                                let alias.description = get(config, 'description',
                                      \ s:make_default_description(config.source, args))
                                let alias.source__config = config
                                let alias.source__args = args
                                let alias.hooks = {}
                            
                                function! alias.hooks.on_pre_init(args, context)
                                  let config = a:context.source.source__config
                                  let original_source =
                                        \ (!has_key(config, 'source') ||
                                        \  config.source ==# a:context.source.name) ? {} :
                                        \ deepcopy(unite#get_all_sources(config.source))
                                  let alias_source = deepcopy(a:context.source)
                            
                                  if has_key(original_source, 'hooks')
                                        \ && has_key(original_source.hooks, 'on_pre_init')
                                    " Call pre init hook.
                                    call original_source.hooks.on_pre_init(
                                          \ a:context.source.source__args + a:args,
                                          \ { 'source' : original_source })
                                  endif
                            
                                  let source = extend(a:context.source,
                                        \ filter(copy(original_source),
                                        \ 'type(v:val) != type(function("type"))'))
                                  let source.name = alias_source.name
                                  let source.description = alias_source.description
                                  let source.hooks = {}
                                  let source.source__original_source = original_source
                                  let source.source__args = a:context.source.source__args
                            
                                  " Overwrite hooks.
                                  if has_key(original_source, 'hooks')
                                    for func in filter(keys(original_source.hooks),
                                          \ 'v:val !=# "on_pre_init"')
                                      let define_function = join([
                                            \ 'function! source.hooks.' . func . '(args, context)',
                                            \ '  let args = a:context.source.source__args + a:args',
                                            \ '  return a:context.source.source__original_source.hooks.'
                                            \                    . func . '(args, a:context)',
                                            \ 'endfunction'], "\n")
                                      execute define_function
                                    endfor
                                  endif
                            
                                  " Overwrite functions.
                                  for func in keys(filter(copy(original_source),
                                        \ 'type(v:val) == type(function("type"))'))
                                    if func ==# 'complete'
                                      let define_function = join([
                                            \ 'function! source.' . func . '(args, context, arglead, cmdline, cursorpos)',
                                            \ '  let args = self.source__args + a:args',
                                            \ '  return self.source__original_source.'
                                            \                    . func .
                                            \   '(args, a:context, a:arglead, a:cmdline, a:cursorpos)',
                                            \ 'endfunction'], "\n")
                                    else
                                      let define_function = join([
                                            \ 'function! source.' . func . '(args, context)',
                                            \ '  let args = self.source__args + a:args',
                                            \ '  return self.source__original_source.'
                                            \                    . func . '(args, a:context)',
                                            \ 'endfunction'], "\n")
                                    endif
                                    execute define_function
                                  endfor
                                endfunction
                            
                                call add(aliases, alias)
                              endfor
                            
                              return aliases
                            endfunction
                            
    1              0.000003 function! s:make_default_description(source_name, args)
                              let desc = 'alias for "' . a:source_name
                              if empty(a:args)
                                return desc . '"'
                              endif
                            
                              let desc .= ':' . join(a:args, ':') . '"'
                              return desc
                            endfunction
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /home/skl/.vim/bundle/vimproc.vim/autoload/vimproc.vim
Sourced 1 time
Total time:   0.003681
 Self time:   0.002361

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: vimproc.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com> (Modified)
                            "          Yukihiro Nakadaira <yukihiro.nakadaira at gmail.com> (Original)
                            " Last Modified: 05 Dec 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Saving 'cpoptions' {{{
    1              0.000010 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            " }}}
                            
    1              0.000005 function! s:print_error(string)
                              echohl Error | echomsg a:string | echohl None
                            endfunction
                            
                            " MacVim trouble shooter {{{
    1              0.000370 if vimproc#util#is_mac() && !&encoding
                              set encoding=utf-8
                            endif
                            "}}}
                            
                            " Check 'encoding' "{{{
    1              0.000005 if &encoding =~# '^euc-jp'
                              call s:print_error('Sorry, vimproc is not supported this encoding environment.')
                              call s:print_error('You should set ''encoding'' option to "utf-8" '
                                    \ .'and set ''termencoding'' option to "euc-jp".')
                              finish
                            endif
                            "}}}
                            
                            " Global options definition. "{{{
                            " Set the default of g:vimproc_dll_path by judging OS "{{{
    1   0.000009   0.000006 if vimproc#util#is_windows()
                              if has('win64')
                                let s:vimproc_dll_basename = 'vimproc_win64.dll'
                              else
                                let s:vimproc_dll_basename = 'vimproc_win32.dll'
                              endif
                            elseif vimproc#util#is_cygwin()
                              let s:vimproc_dll_basename = 'vimproc_cygwin.dll'
                            elseif vimproc#util#is_mac()
                              let s:vimproc_dll_basename = 'vimproc_mac.so'
                            else
    1              0.000004   let s:vimproc_dll_basename = 'vimproc_unix.so'
    1              0.000001 endif
                            "}}}
                            
    1   0.000046   0.000026 call vimproc#util#set_default(
                                  \ 'g:vimproc#dll_path',
                                  \ expand('<sfile>:p:h') . '/' . s:vimproc_dll_basename,
                                  \ 'g:vimproc_dll_path')
    1              0.000003 unlet s:vimproc_dll_basename
                            
    1   0.000035   0.000016 call vimproc#util#set_default(
                                  \ 'g:vimproc#password_pattern',
                                  \ '\%(Enter \|[Oo]ld \|[Nn]ew \|login '  .
                                  \'\|Kerberos \|CVS \|UNIX \| SMB \|LDAP \|\[sudo] ' .
                                  \'\|^\|\n\|''s \)\%([Pp]assword\|[Pp]assphrase\)\>',
                                  \ 'g:vimproc_password_pattern')
    1   0.000039   0.000019 call vimproc#util#set_default(
                                  \ 'g:vimproc#popen2_commands', {
                                  \     'sh' : 1, 'bash' : 1, 'zsh' : 1, 'csh' : 1, 'tcsh' : 1,
                                  \     'tmux' : 1, 'screen' : 1, 'su' : 1,
                                  \     'python' : 1, 'rhino' : 1, 'ipython' : 1, 'ipython3' : 1, 'yaourt' : 1,
                                  \ }, 'g:vimproc_popen2_commands')
    1   0.000029   0.000016 call vimproc#util#set_default(
                                  \ 'g:stdinencoding', 'char')
    1   0.000019   0.000007 call vimproc#util#set_default(
                                  \ 'g:stdoutencoding', 'char')
    1   0.000017   0.000005 call vimproc#util#set_default(
                                  \ 'g:stderrencoding', 'char')
                            "}}}
                            
                            " Constants {{{
    1              0.000003 let g:vimproc#SIGINT = 2
    1              0.000002 let g:vimproc#SIGQUIT = 3
    1              0.000002 let g:vimproc#SIGILL = 4
    1              0.000002 let g:vimproc#SIGABRT = 6
    1              0.000002 let g:vimproc#SIGFPE = 8
    1              0.000003 let g:vimproc#SIGKILL = 9
    1              0.000003 let g:vimproc#SIGSEGV = 11
    1              0.000002 let g:vimproc#SIGPIPE = 13
    1              0.000002 let g:vimproc#SIGALRM = 14
    1              0.000001 let g:vimproc#SIGTERM = 15
    1              0.000001 let g:vimproc#SIGUSR1 = 10
    1              0.000002 let g:vimproc#SIGUSR2 = 12
    1              0.000002 let g:vimproc#SIGCHLD = 17
    1              0.000002 let g:vimproc#SIGCONT = 18
    1              0.000002 let g:vimproc#SIGSTOP = 19
    1              0.000002 let g:vimproc#SIGTSTP = 20
    1              0.000002 let g:vimproc#SIGTTIN = 21
    1              0.000002 let g:vimproc#SIGTTOU = 22
    1              0.000002 let g:vimproc#SIGWINCH = 28
                            " }}}
                            
    1   0.000081   0.000037 let g:vimproc#dll_path =
                                  \ vimproc#util#iconv(
                                  \ vimproc#util#substitute_path_separator(g:vimproc#dll_path),
                                  \ &encoding, vimproc#util#termencoding())
                            
                            " Backward compatibility.
    1              0.000004 let g:vimproc_password_pattern = g:vimproc#password_pattern
                            
    1              0.000017 if !filereadable(g:vimproc#dll_path) "{{{
                              function! vimproc#get_last_status()
                                return v:shell_error
                              endfunction
                            
                              function! vimproc#get_last_errmsg()
                                return ''
                              endfunction
                            
                              function! vimproc#system(...)
                                return call('system', a:000)
                              endfunction
                            
                              echoerr printf('vimproc''s DLL: "%s" is not found.
                                    \ Please read :help vimproc and make it.', g:vimproc#dll_path)
                            
                              finish
                            endif"}}}
                            
    1              0.000003 function! vimproc#version() "{{{
                              return str2nr(printf('%2d%02d', 7, 1))
                            endfunction"}}}
    1              0.000002 function! vimproc#dll_version() "{{{
                              let [dll_version] = s:libcall('vp_dlversion', [])
                              return str2nr(dll_version)
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " API
                            
    1              0.000003 function! vimproc#open(filename) "{{{
                              let filename = vimproc#util#iconv(fnamemodify(a:filename, ':p'),
                                    \ &encoding, vimproc#util#termencoding())
                            
                              if filename =~ '^\%(https\?\|ftp\)://'
                                      \ && !vimproc#host_exists(filename)
                                " URI is invalid.
                                call s:print_error('vimproc#open: URI "' . filename . '" is invalid.')
                                return
                              endif
                            
                              " Detect desktop environment.
                              if vimproc#util#is_windows()
                                " For URI only.
                                "execute '!start rundll32 url.dll,FileProtocolHandler' filename
                            
                                call s:libcall('vp_open', [filename])
                              elseif has('win32unix')
                                " Cygwin.
                                call vimproc#system(['cygstart', filename])
                              elseif executable('xdg-open')
                                " Linux.
                                call vimproc#system_bg(['xdg-open', filename])
                              elseif exists('$KDE_FULL_SESSION') && $KDE_FULL_SESSION ==# 'true'
                                " KDE.
                                call vimproc#system_bg(['kioclient', 'exec', filename])
                              elseif exists('$GNOME_DESKTOP_SESSION_ID')
                                " GNOME.
                                call vimproc#system_bg(['gnome-open', filename])
                              elseif executable('exo-open')
                                " Xfce.
                                call vimproc#system_bg(['exo-open', filename])
                              elseif vimproc#util#is_mac() && executable('open')
                                " Mac OS.
                                call vimproc#system_bg(['open', filename])
                              else
                                " Give up.
                                call s:print_error('vimproc#open: Not supported.')
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#get_command_name(command, ...) "{{{
                              let path = get(a:000, 0, $PATH)
                            
                              let cnt = a:0 < 2 ? 1 : a:2
                            
                              let files = split(substitute(vimproc#util#substitute_path_separator(
                                    \ vimproc#filepath#which(a:command, path)), '//', '/', 'g'), '\n')
                            
                              if cnt < 0
                                return files
                              endif
                            
                              let file = get(files, cnt-1, '')
                            
                              if file == ''
                                throw printf(
                                      \ 'vimproc#get_command_name: File "%s" is not found.', a:command)
                              endif
                            
                              return file
                            endfunction"}}}
                            
    1              0.000005 function! s:system(cmdline, is_passwd, input, timeout, is_pty) "{{{
                              if empty(a:cmdline)
                                let s:last_status = 0
                                let s:last_errmsg = ''
                                return ''
                              endif
                            
                              " Open pipe.
                              let subproc = (type(a:cmdline[0]) == type('')) ? vimproc#popen3(a:cmdline) :
                                    \ a:is_pty ? vimproc#ptyopen(a:cmdline):
                                    \ vimproc#pgroup_open(a:cmdline)
                            
                              if a:input != ''
                                " Write input.
                                call subproc.stdin.write(a:input)
                              endif
                            
                              if a:timeout > 0 && has('reltime') && v:version >= 702
                                let start = reltime()
                                let timeout = a:timeout
                              else
                                let timeout = 0
                              endif
                            
                              if !a:is_passwd
                                call subproc.stdin.close()
                              endif
                            
                              let output = ''
                              let s:last_errmsg = ''
                              while !subproc.stdout.eof || !subproc.stderr.eof
                                if timeout > 0 "{{{
                                  " Check timeout.
                                  let end = split(reltimestr(reltime(start)))[0] * 1000
                                  if end > timeout && !subproc.stdout.eof
                                    " Kill process.
                                    try
                                      call subproc.kill(g:vimproc#SIGTERM)
                                      call subproc.waitpid()
                                    catch
                                      " Ignore error.
                                    endtry
                            
                                    throw 'vimproc: vimproc#system(): Timeout.'
                                  endif
                                endif"}}}
                            
                                if !subproc.stdout.eof "{{{
                                  let out = subproc.stdout.read(1000, 0)
                            
                                  if a:is_passwd && out =~# g:vimproc_password_pattern
                                    redraw
                                    echo out
                            
                                    " Password input.
                                    set imsearch=0
                                    let in = vimproc#util#iconv(inputsecret('Input Secret : ')."\<NL>",
                                          \ &encoding, vimproc#util#termencoding())
                            
                                    call subproc.stdin.write(in)
                                  else
                                    let output .= out
                                  endif
                                endif"}}}
                            
                                if !subproc.stderr.eof "{{{
                                  let out = subproc.stderr.read(1000, 0)
                            
                                  if a:is_passwd && out =~# g:vimproc_password_pattern
                                    redraw
                                    echo out
                            
                                    " Password input.
                                    set imsearch=0
                                    let in = vimproc#util#iconv(inputsecret('Input Secret : ') . "\<NL>",
                                          \ &encoding, vimproc#util#termencoding())
                            
                                    call subproc.stdin.write(in)
                                  else
                                    let s:last_errmsg .= out
                                    let output .= out
                                  endif
                                endif"}}}
                              endwhile
                            
                              let [cond, status] = subproc.waitpid()
                            
                              " Newline convert.
                              if vimproc#util#is_mac()
                                let output = substitute(output, '\r\n\@!', '\n', 'g')
                              elseif has('win32') || has('win64')
                                let output = substitute(output, '\r\n', '\n', 'g')
                              endif
                            
                              return output
                            endfunction"}}}
    1              0.000004 function! vimproc#system(cmdline, ...) "{{{
                              if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
                                let args = [{'statement' :
                                      \ [{ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                      \   'args' : a:cmdline }], 'condition' : 'always' }]
                              endif
                            
                              let timeout = get(a:000, 1, 0)
                              let input = get(a:000, 0, '')
                            
                              return s:system(args, 0, input, timeout, 0)
                            endfunction"}}}
    1              0.000003 function! vimproc#system2(...) "{{{
                              if empty(a:000)
                                return ''
                              endif
                            
                              if len(a:0) > 1
                                let args = deepcopy(a:000)
                                let args[1] = vimproc#util#iconv(
                                      \ args[1], &encoding, vimproc#util#stdinencoding())
                              else
                                let args = a:000
                              endif
                              let output = call('vimproc#system', args)
                            
                              " This function converts application encoding to &encoding.
                              let output = vimproc#util#iconv(
                                    \ output, vimproc#util#stdoutencoding(), &encoding)
                              let s:last_errmsg = vimproc#util#iconv(
                                    \ s:last_errmsg, vimproc#util#stderrencoding(), &encoding)
                            
                              return output
                            endfunction"}}}
    1              0.000003 function! vimproc#system_passwd(cmdline, ...) "{{{
                              if type(a:cmdline) == type('')
                                let args = vimproc#parser#parse_pipe(a:cmdline)
                              else
                                let args = [{ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                      \ 'args' : a:cmdline }]
                              endif
                            
                              let timeout = a:0 >= 2 ? a:2 : 0
                              let input = a:0 >= 1 ? a:1 : ''
                            
                              let lang_save = $LANG
                              try
                                let $LANG = 'C'
                            
                                return s:system(args, 1, input, timeout, 1)
                              finally
                                let $LANG = lang_save
                              endtry
                            endfunction"}}}
    1              0.000003 function! vimproc#system_bg(cmdline) "{{{
                              " Open pipe.
                              if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
                                let args = [{'statement' :
                                      \ [{ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                      \   'args' : a:cmdline }], 'condition' : 'always' }]
                              endif
                            
                              let subproc = vimproc#pgroup_open(args)
                              if empty(subproc)
                                " Not supported path error.
                                return ''
                              endif
                            
                              " Close handles.
                              call s:close_all(subproc)
                            
                              let s:bg_processes[subproc.pid] = subproc.pid
                            
                              return ''
                            endfunction"}}}
    1              0.000003 function! vimproc#system_gui(cmdline) "{{{
                              if vimproc#util#is_windows()
                                silent execute ':!start ' . join(map(vimproc#parser#split_args(a:cmdline), '"\"".v:val."\""'))
                                return ''
                              else
                                return vimproc#system_bg(a:cmdline)
                              endif
                            endfunction"}}}
                            
    1              0.000004 function! vimproc#get_last_status() "{{{
                              return s:last_status
                            endfunction"}}}
    1              0.000003 function! vimproc#get_last_errmsg() "{{{
                              return substitute(vimproc#util#iconv(s:last_errmsg,
                                    \ vimproc#util#stderrencoding(), &encoding), '\n$', '', '')
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#shellescape(string) "{{{
                              return string(a:string)
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#fopen(path, flags, ...) "{{{
                              let mode = get(a:000, 0, 0644)
                              let fd = s:vp_file_open(a:path, a:flags, mode)
                              let proc = s:fdopen(fd, 'vp_file_close', 'vp_file_read', 'vp_file_write')
                              return proc
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#popen2(args) "{{{
                              let args = type(a:args) == type('') ?
                                    \ vimproc#parser#split_args(a:args) :
                                    \ a:args
                            
                              return s:plineopen(2, [{
                                    \ 'args' : args,
                                    \ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                    \ }], 0)
                            endfunction"}}}
    1              0.000003 function! vimproc#popen3(args) "{{{
                              let args = type(a:args) == type('') ?
                                    \ vimproc#parser#split_args(a:args) :
                                    \ a:args
                            
                              return s:plineopen(3, [{
                                    \ 'args' : args,
                                    \ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                    \ }], 0)
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#plineopen2(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let is_pty = get(a:000, 0, 0)
                            
                              return s:plineopen(2, commands, is_pty)
                            endfunction"}}}
    1              0.000003 function! vimproc#plineopen3(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let is_pty = get(a:000, 0, 0)
                            
                              return s:plineopen(3, commands, is_pty)
                            endfunction"}}}
    1              0.000003 function! s:plineopen(npipe, commands, is_pty) "{{{
                              let pid_list = []
                              let stdin_list = []
                              let stdout_list = []
                              let stderr_list = []
                              let npipe = a:npipe
                            
                              " Open input.
                              let hstdin = (empty(a:commands) || a:commands[0].fd.stdin == '')?
                                    \ 0 : vimproc#fopen(a:commands[0].fd.stdin, 'O_RDONLY').fd
                            
                              let is_pty = !vimproc#util#is_windows() && a:is_pty
                            
                              let cnt = 0
                              for command in a:commands
                                if is_pty && command.fd.stdout == '' && cnt == 0
                                      \ && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstdout = 1
                                else
                                  let mode = 'O_WRONLY | O_CREAT'
                                  if command.fd.stdout =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stdout = command.fd.stdout[1:]
                                  else
                                    let mode .= ' | O_TRUNC'
                                  endif
                            
                                  let hstdout = s:is_pseudo_device(command.fd.stdout) ?
                                        \ 0 : vimproc#fopen(command.fd.stdout, mode).fd
                                endif
                            
                                if is_pty && command.fd.stderr == '' && cnt == 0
                                      \ && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstderr = 1
                                else
                                  let mode = 'O_WRONLY | O_CREAT'
                                  if command.fd.stderr =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stderr = command.fd.stderr[1:]
                                  else
                                    let mode .= ' | O_TRUNC'
                                  endif
                                  let hstderr = s:is_pseudo_device(command.fd.stderr) ?
                                        \ 0 : vimproc#fopen(command.fd.stderr, mode).fd
                                endif
                            
                                if command.fd.stderr ==# '/dev/stdout'
                                  let npipe = 2
                                endif
                            
                                let args = s:convert_args(command.args)
                                let command_name = fnamemodify(args[0], ':t:r')
                                let pty_npipe = cnt == 0
                                      \ && hstdin == 0 && hstdout == 0 && hstderr == 0
                                      \ && exists('g:vimproc_popen2_commands')
                                      \ && get(g:vimproc_popen2_commands, command_name, 0) != 0 ?
                                      \ 2 : npipe
                            
                                if is_pty && (cnt == 0 || cnt == len(a:commands)-1)
                                  " Use pty_open().
                                  let pipe = s:vp_pty_open(pty_npipe, winwidth(0)-5, winheight(0),
                                        \ hstdin, hstdout, hstderr, args)
                                else
                                  let pipe = s:vp_pipe_open(pty_npipe,
                                        \ hstdin, hstdout, hstderr, args)
                                endif
                            
                                if len(pipe) == 4
                                  let [pid, fd_stdin, fd_stdout, fd_stderr] = pipe
                                  let stderr = s:fdopen(fd_stderr,
                                        \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                else
                                  let [pid, fd_stdin, fd_stdout] = pipe
                                  let stderr = s:closed_fdopen(
                                        \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                endif
                            
                                call add(pid_list, pid)
                                let stdin = s:fdopen(fd_stdin,
                                      \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                let stdin.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstdin == 0
                                call add(stdin_list, stdin)
                                let stdout = s:fdopen(fd_stdout,
                                      \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                let stdout.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstdout == 0
                                call add(stdout_list, stdout)
                                let stderr.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstderr == 0
                                call add(stderr_list, stderr)
                            
                                let hstdin = stdout_list[-1].fd
                                let cnt += 1
                              endfor
                            
                              let proc = {}
                              let proc.pid_list = pid_list
                              let proc.pid = pid_list[-1]
                              let proc.stdin = s:fdopen_pipes(stdin_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.stdout = s:fdopen_pipes(stdout_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.stderr = s:fdopen_pipes(stderr_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.get_winsize = s:funcref('vp_get_winsize')
                              let proc.set_winsize = s:funcref('vp_set_winsize')
                              let proc.kill = s:funcref('vp_kill')
                              let proc.waitpid = s:funcref('vp_waitpid')
                              let proc.checkpid = s:funcref('vp_checkpid')
                              let proc.is_valid = 1
                              let proc.is_pty = is_pty
                              if a:is_pty
                                let proc.ttyname = ''
                                let proc.get_winsize = s:funcref('vp_get_winsize')
                                let proc.set_winsize = s:funcref('vp_set_winsize')
                              endif
                            
                              return proc
                            endfunction"}}}
                            
    1              0.000003 function! s:is_pseudo_device(filename) "{{{
                              if vimproc#util#is_windows() && (
                                \    a:filename ==# '/dev/stdin'
                                \ || a:filename ==# '/dev/stdout'
                                \ || a:filename ==# '/dev/stderr')
                                return 1
                              endif
                            
                              return a:filename == ''
                                    \ || a:filename ==# '/dev/null'
                                    \ || a:filename ==# '/dev/clip'
                                    \ || a:filename ==# '/dev/quickfix'
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#pgroup_open(statements, ...) "{{{
                              if type(a:statements) == type('')
                                let statements =
                                      \ vimproc#parser#parse_statements(a:statements)
                                for statement in statements
                                  let statement.statement =
                                        \ vimproc#parser#parse_pipe(statement.statement)
                                endfor
                              else
                                let statements = a:statements
                              endif
                            
                              let is_pty = get(a:000, 0, 0)
                              let npipe = get(a:000, 1, 3)
                            
                              return s:pgroup_open(statements, is_pty && !vimproc#util#is_windows(), npipe)
                            endfunction"}}}
                            
    1              0.000003 function! s:pgroup_open(statements, is_pty, npipe) "{{{
                              let proc = {}
                              let proc.current_proc =
                                    \ vimproc#plineopen{a:npipe}(a:statements[0].statement, a:is_pty)
                            
                              let proc.pid = proc.current_proc.pid
                              let proc.pid_list = proc.current_proc.pid_list
                              let proc.condition = a:statements[0].condition
                              let proc.statements = a:statements[1:]
                              let proc.stdin = s:fdopen_pgroup(proc, proc.current_proc.stdin,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.stdout = s:fdopen_pgroup(proc, proc.current_proc.stdout,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.stderr = s:fdopen_pgroup(proc, proc.current_proc.stderr,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.kill = s:funcref('vp_pgroup_kill')
                              let proc.waitpid = s:funcref('vp_pgroup_waitpid')
                              let proc.is_valid = 1
                              let proc.is_pty = 0
                              " echomsg expand('<sfile>')
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdin.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdout.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stderr.fd), 'v:val.fd'))
                            
                              return proc
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#ptyopen(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let npipe = get(a:000, 0, 3)
                            
                              return s:plineopen(npipe, commands, !vimproc#util#is_windows())
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#socket_open(host, port) "{{{
                              let fd = s:vp_socket_open(a:host, a:port)
                              return s:fdopen(fd, 'vp_socket_close', 'vp_socket_read', 'vp_socket_write')
                            endfunction"}}}
                            
    1              0.000002 function! vimproc#host_exists(host) "{{{
                              let rval = s:vp_host_exists(
                                    \ substitute(substitute(a:host, '^\a\+://', '', ''), '/.*$', '', ''))
                              return 0 + rval
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#kill(pid, sig) "{{{
                              if a:sig == 0 && vimproc#util#is_windows()
                                " Use waitpid().
                                let [cond, status] = s:waitpid(a:pid)
                                return cond ==# 'run'
                              endif
                            
                              try
                                let [ret] = s:libcall('vp_kill', [a:pid, a:sig])
                              catch
                                let s:last_errmsg = v:exception
                                return 1
                              endtry
                            
                              return ret
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#decode_signal(signal) "{{{
                              if a:signal == g:vimproc#SIGINT
                                return 'SIGINT'
                              elseif a:signal == g:vimproc#SIGQUIT
                                return 'SIGQUIT'
                              elseif a:signal == g:vimproc#SIGILL
                                return 'SIGILL'
                              elseif a:signal == g:vimproc#SIGABRT
                                return 'SIGABRT'
                              elseif a:signal == g:vimproc#SIGFPE
                                return 'SIGFPE'
                              elseif a:signal == g:vimproc#SIGKILL
                                return 'SIGKILL'
                              elseif a:signal == g:vimproc#SIGSEGV
                                return 'SIGSEGV'
                              elseif a:signal == g:vimproc#SIGPIPE
                                return 'SIGPIPE'
                              elseif a:signal == g:vimproc#SIGALRM
                                return 'SIGALRM'
                              elseif a:signal == g:vimproc#SIGTERM
                                return 'SIGTERM'
                              elseif a:signal == g:vimproc#SIGUSR1
                                return 'SIGUSR1'
                              elseif a:signal == g:vimproc#SIGUSR2
                                return 'SIGUSR2'
                              elseif a:signal == g:vimproc#SIGCHLD
                                return 'SIGCHLD'
                              elseif a:signal == g:vimproc#SIGCONT
                                return 'SIGCONT'
                              elseif a:signal == g:vimproc#SIGSTOP
                                return 'SIGSTOP'
                              elseif a:signal == g:vimproc#SIGTSTP
                                return 'SIGTSTP'
                              elseif a:signal == g:vimproc#SIGTTIN
                                return 'SIGTTIN'
                              elseif a:signal == g:vimproc#SIGTTOU
                                return 'SIGTTOU'
                              elseif a:signal == g:vimproc#SIGWINCH
                                return 'SIGTTOU'
                              else
                                return 'UNKNOWN'
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#write(filename, string, ...) "{{{
                              if a:string == ''
                                return
                              endif
                            
                              let mode = get(a:000, 0,
                                    \ a:filename =~ '^>' ? 'a' : 'w')
                            
                              let filename = a:filename =~ '^>' ?
                                    \ a:filename[1:] : a:filename
                            
                              if filename ==# '/dev/null'
                                " Nothing.
                              elseif filename ==# '/dev/clip'
                                " Write to clipboard.
                            
                                if mode =~ 'a'
                                  let @+ .= a:string
                                else
                                  let @+ = a:string
                                endif
                              elseif filename ==# '/dev/quickfix'
                                " Write to quickfix.
                                let qflist = getqflist()
                            
                                for str in split(a:string, '\n\|\r\n')
                                  if str =~ '^.\+:.\+:.\+$'
                                    let line = split(str[2:], ':')
                                    let filename = str[:1] . line[0]
                            
                                    if len(line) >= 3 && line[1] =~ '^\d\+$'
                                      call add(qflist, {
                                            \ 'filename' : filename,
                                            \ 'lnum' : line[1],
                                            \ 'text' : join(line[2:], ':'),
                                            \ })
                                    else
                                      call add(qflist, {
                                            \ 'text' : str,
                                            \ })
                                    endif
                                  endif
                                endfor
                            
                                call setqflist(qflist)
                              else
                                " Write file.
                            
                                let cmode = 'O_WRONLY | O_CREAT'
                                if mode =~# 'a'
                                  " Append mode.
                                  let cmode .= '| O_APPEND'
                                endif
                            
                                let hfile = vimproc#fopen(filename, cmode)
                                call hfile.write(a:string)
                                call hfile.close()
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#readdir(dirname) "{{{
                              let dirname = vimproc#util#expand(a:dirname)
                              if dirname == ''
                                let dirname = getcwd()
                              endif
                              let dirname = substitute(dirname, '.\zs/$', '', '')
                            
                              if !vimproc#util#is_windows()
                                let dirname = substitute(dirname, '//', '/', 'g')
                              endif
                            
                              if !isdirectory(dirname)
                                return []
                              endif
                            
                              let dirname = vimproc#util#iconv(dirname, &encoding,
                                    \ vimproc#util#termencoding())
                            
                              try
                                let files = s:libcall('vp_readdir', [dirname])
                              catch /vp_readdir/
                                return []
                              endtry
                            
                              call map(filter(files, 'v:val !~ "/\\.\\.\\?$"'), 'vimproc#util#iconv(
                                    \ v:val, vimproc#util#termencoding(), &encoding)')
                              if vimproc#util#is_windows()
                                call map(files, 'vimproc#util#substitute_path_separator(v:val)')
                              endif
                              call map(files, "substitute(v:val, '/\\./', '/', 'g')")
                            
                              return files
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#delete_trash(filename) "{{{
                              if !vimproc#util#is_windows()
                                call s:print_error('Not implemented in this platform.')
                                return
                              endif
                            
                              let filename = a:filename
                            
                              if !filewritable(filename) && !isdirectory(filename)
                                return 1
                              endif
                            
                              " Substitute path separator to "/".
                              let filename = substitute(
                                    \ fnamemodify(filename, ':p'), '/', '\\', 'g')
                            
                              " Delete last /.
                              if filename =~ '[^:][/\\]$'
                                " Delete last /.
                                let filename = filename[: -2]
                              endif
                            
                              " Encoding conversion.
                              let filename = vimproc#util#iconv(filename,
                                    \ &encoding, vimproc#util#termencoding())
                            
                              let [ret] = s:libcall('vp_delete_trash', [filename])
                            
                              return str2nr(ret)
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#test_readdir(dirname) "{{{
                              let start = reltime()
                              call split(glob(a:dirname.'/*'), '\n')
                              echomsg reltimestr(reltime(start))
                            
                              let start = reltime()
                              call vimproc#readdir(a:dirname)
                              echomsg reltimestr(reltime(start))
                            endfunction"}}}
                            
    1              0.000003 function! s:close_all(self) "{{{
                              if has_key(a:self, 'stdin')
                                call a:self.stdin.close()
                              endif
                              if has_key(a:self, 'stdout')
                                call a:self.stdout.close()
                              endif
                              if has_key(a:self, 'stderr')
                                call a:self.stderr.close()
                              endif
                            endfunction"}}}
    1              0.000011 function! s:close() dict "{{{
                              if self.is_valid
                                call self.f_close()
                              endif
                            
                              let self.is_valid = 0
                              let self.eof = 1
                              let self.__eof = 1
                            endfunction"}}}
    1              0.000002 function! s:read(...) dict "{{{
                              if self.__eof
                                let self.eof = 1
                                return ''
                              endif
                            
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                              let [hd, eof] = self.f_read(number, timeout)
                              let self.eof = eof
                              let self.__eof = eof
                            
                              if hd == ''
                                return ''
                              endif
                            
                              " Note: if output string is too long, if_lua is too slow.
                              return (vimproc#util#has_lua() && len(hd) < 1024) ?
                                    \ s:hd2str_lua([hd]) : s:hd2str([hd])
                              " return s:hd2str([hd])
                            endfunction"}}}
    1              0.000002 function! s:read_lines(...) dict "{{{
                              let res = self.buffer
                            
                              while !self.eof && stridx(res, "\n") < 0
                                let out = call(self.read, a:000, self)
                                if out  == ''
                                  break
                                endif
                            
                                let res .= out
                              endwhile
                            
                              let self.buffer = ''
                              let lines = split(res, '\r*\n', 1)
                              if !self.__eof
                                let self.buffer = get(lines, -1, '')
                                let lines = lines[ : -2]
                              endif
                            
                              return lines
                            endfunction"}}}
    1              0.000003 function! s:read_line(...) dict "{{{
                              let lines = call(self.read_lines, a:000, self)
                              let self.buffer = join(lines[1:], "\n") . self.buffer
                              let self.eof = (self.buffer != '') ?
                                    \ (self.__eof && self.buffer == '') : self.__eof
                              return get(lines, 0, '')
                            endfunction"}}}
                            
    1              0.000002 function! s:write(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                              let hd = s:str2hd(a:str)
                              return self.f_write(hd, timeout)
                            endfunction"}}}
                            
    1              0.000003 function! s:fdopen(fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'fd' : a:fd,
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000003 function! s:closed_fdopen(f_close, f_read, f_write) "{{{
                              return {
                                    \ 'fd' : -1,
                                    \ 'eof' : 1, '__eof' : 1, 'is_valid' : 0, 'buffer' : '',
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000004 function! s:fdopen_pty(fd_stdin, fd_stdout, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'fd_stdin' : a:fd_stdin, 'fd_stdout' : a:fd_stdout,
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000003 function! s:fdopen_pipes(fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'fd' : a:fd,
                                    \ 'f_close' : s:funcref(a:f_close),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000003 function! s:fdopen_pgroup(proc, fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'proc' : a:proc, 'fd' : a:fd,
                                    \ 'f_close' : s:funcref(a:f_close),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
                            
    1              0.000003 function! s:garbage_collect(is_force) "{{{
                              for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, status] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, status])
                                  if cond !=# 'run' || a:is_force
                                    if cond !=# 'exit'
                                      " Kill process.
                                      call vimproc#kill(pid, g:vimproc#SIGTERM)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor
                            endfunction"}}}
                            
                            " For debug API.
    1              0.000004 function! vimproc#_get_bg_processes() "{{{
                              return s:bg_processes
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " UTILS
                            
    1              0.000003 function! s:str2hd(str)
                              return join(map(range(len(a:str)),
                                    \ 'printf("%02X", char2nr(a:str[v:val]))'), '')
                            endfunction
                            
    1              0.000001 function! s:hd2str(hd)
                              " a:hd is a list because to avoid copying the value.
                              return get(s:libcall('vp_decode', [a:hd[0]]), 0, '')
                            endfunction
                            
    1              0.000002 function! s:hd2str_lua(hd)
                              let ret = []
                              lua << EOF
                            do
                              local ret = vim.eval('ret')
                              local hd = vim.eval('a:hd')
                              if hd[0] == nil then
                                hd[0] = ''
                              end
                              local len = string.len(hd[0])
                              local s = ''
                              for i = 1, len, 2 do
                                s = s .. string.char(tonumber(string.sub(hd[0], i, i+1), 16))
                              end
                            
                              ret:add(s)
                            end
                            EOF
                              return ret[0]
                            endfunction
                            
    1              0.000002 function! s:str2list(str)
                              return map(range(len(a:str)), 'char2nr(a:str[v:val])')
                            endfunction
                            
    1              0.000002 function! s:list2str(lis)
                              return s:hd2str(s:list2hd([a:lis]))
                            endfunction
                            
    1              0.000002 function! s:hd2list(hd)
                              return map(split(a:hd, '..\zs'), 'str2nr(v:val, 16)')
                            endfunction
                            
    1              0.000002 function! s:list2hd(lis)
                              return join(map(a:lis, 'printf("%02X", v:val)'), '')
                            endfunction
                            
    1              0.000002 function! s:convert_args(args) "{{{
                              if empty(a:args)
                                return []
                              endif
                            
                              if vimproc#util#is_windows() && !executable(a:args[0])
                                " Search from internal commands.
                                let internal_commands = [
                                      \ 'copy', 'dir', 'echo', 'erase', 'ftype',
                                      \ 'md', 'mkdir', 'move', 'path', 'rd', 'ren', 'rename',
                                      \ 'rmdir', 'start', 'time', 'type', 'ver', 'vol']
                                let index = index(internal_commands, a:args[0])
                                if index >= 0
                                  " Use cmd.exe
                                  return ['cmd', '/c', internal_commands[index]] + a:args[1:]
                                endif
                              endif
                            
                              let command_name = vimproc#get_command_name(a:args[0])
                            
                              return vimproc#analyze_shebang(command_name) + a:args[1:]
                            endfunction"}}}
                            
    1              0.000004 function! vimproc#analyze_shebang(filename) "{{{
                              if !filereadable(a:filename) ||
                                    \ getfsize(a:filename) > 100000 ||
                                    \ (vimproc#util#is_windows() &&
                                    \ '.'.fnamemodify(a:filename, ':e') !~?
                                    \   '^'.substitute($PATHEXT, ';', '$\\|^', 'g').'$')
                                  " Maybe a binary file.
                                return [a:filename]
                              endif
                            
                              let lines = readfile(a:filename, '', 1)
                              if empty(lines) || lines[0] !~ '^#!.\+'
                                " Shebang not found.
                                return [a:filename]
                              endif
                            
                              " Get shebang line.
                              let shebang = split(matchstr(lines[0], '^#!\zs.\+'))
                            
                              " Convert command name.
                              if vimproc#util#is_windows()
                                    \ && shebang[0] =~ '^/'
                                let shebang[0] = vimproc#get_command_name(
                                      \ fnamemodify(shebang[0], ':t'))
                              endif
                            
                              return shebang + [a:filename]
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " LOW LEVEL API
                            
    1              0.000004 augroup vimproc
    1              0.000011   autocmd VimLeave * call s:finalize()
    1              0.000007   autocmd CursorHold,BufWritePost * call s:garbage_collect(0)
    1              0.000002 augroup END
                            
                            " Initialize.
    1              0.000003 let s:lasterr = []
    1              0.000003 let s:read_timeout = 100
    1              0.000002 let s:write_timeout = 100
    1              0.000003 let s:bg_processes = {}
                            
    1   0.000019   0.000008 if vimproc#util#has_lua()
                              function! s:split(str, sep)
                                let result = []
                                lua << EOF
                                do
                                local result = vim.eval('result')
                                local str = vim.eval('a:str')
                                local sep = vim.eval('a:sep')
                                local last
                            
                                if string.find(str, sep, 1, true) == nil then
                                  result:add(str)
                                else
                                  for part, pos in string.gmatch(str,
                                      '(.-)' .. sep .. '()') do
                                    result:add(part)
                                    last = pos
                                  end
                            
                                  result:add(string.sub(str, last))
                                end
                              end
                            EOF
                            
                                return result
                              endfunction
                            else
    1              0.000003   function! s:split(str, sep)
                                let [result, pos] = [[], 0]
                                while 1
                                  let tmp = stridx(a:str, a:sep, pos)
                                  if tmp == -1
                                    call add(result, strpart(a:str, pos))
                                    break
                                  endif
                                  call add(result, strpart(a:str, pos, tmp - pos))
                                  let pos = tmp + 1
                                endwhile
                            
                                return result
                              endfunction
    1              0.000001 endif
                            
    1              0.000003 function! s:libcall(func, args) "{{{
                              " End Of Value
                              let EOV = "\xFF"
                              let args = empty(a:args) ? '' : (join(reverse(copy(a:args)), EOV) . EOV)
                              let stack_buf = libcall(g:vimproc#dll_path, a:func, args)
                              let result = s:split(stack_buf, EOV)
                              if get(result, -1, 'error') != ''
                                if stack_buf[len(stack_buf) - 1] ==# EOV
                                  " Note: If &encoding equals "cp932" and output ends multibyte first byte,
                                  "       will fail split.
                                  return result
                                endif
                                let s:lasterr = result
                                let msg = vimproc#util#iconv(string(result),
                                      \ vimproc#util#termencoding(), &encoding)
                            
                                throw printf('vimproc: %s: %s', a:func, msg)
                              endif
                              return result[:-2]
                            endfunction"}}}
                            
    1              0.000002 function! s:SID_PREFIX()
                              if !exists('s:sid_prefix')
                                let s:sid_prefix = matchstr(expand('<sfile>'),
                                      \ '<SNR>\d\+_\zeSID_PREFIX$')
                              endif
                              return s:sid_prefix
                            endfunction
                            
                            " Get funcref.
    1              0.000002 function! s:funcref(funcname)
                              return function(s:SID_PREFIX().a:funcname)
                            endfunction
                            
    1              0.000002 function! s:finalize()
                              call s:garbage_collect(1)
                            
                              if exists('s:dll_handle')
                                call s:vp_dlclose(s:dll_handle)
                              endif
                            endfunction
                            
    1              0.000002 function! s:vp_dlopen(path)
                              let [handle] = s:libcall('vp_dlopen', [a:path])
                              return handle
                            endfunction
                            
    1              0.000002 function! s:vp_dlclose(handle)
                              call s:libcall('vp_dlclose', [a:handle])
                            endfunction
                            
    1              0.000003 function! s:vp_file_open(path, flags, mode)
                              let [fd] = s:libcall('vp_file_open', [a:path, a:flags, a:mode])
                              return fd
                            endfunction
                            
    1              0.000002 function! s:vp_file_close() dict
                              if self.fd != 0
                                call s:libcall('vp_file_close', [self.fd])
                                let self.fd = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:vp_file_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_file_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000002 function! s:vp_file_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_file_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000002 function! s:quote_arg(arg)
                              return (a:arg == '' || a:arg =~ '[ "]') ?
                                    \ '"' . substitute(a:arg, '"', '\\"', 'g') . '"' : a:arg
                            endfunction
                            
    1              0.000002 function! s:vp_pipe_open(npipe, hstdin, hstdout, hstderr, argv) "{{{
                              if vimproc#util#is_windows()
                                let cmdline = s:quote_arg(substitute(a:argv[0], '/', '\', 'g'))
                                for arg in a:argv[1:]
                                  let cmdline .= ' ' . s:quote_arg(arg)
                                endfor
                                let [pid; fdlist] = s:libcall('vp_pipe_open',
                                      \ [a:npipe, a:hstdin, a:hstdout, a:hstderr, cmdline])
                              else
                                let [pid; fdlist] = s:libcall('vp_pipe_open',
                                      \ [a:npipe, a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
                              endif
                            
                              if a:npipe != len(fdlist)
                                call s:print_error(printf('a:npipe = %d, a:argv = %s', a:npipe, string(a:argv)))
                                call s:print_error(printf('pid = %d, fdlist = %s', pid, string(fdlist)))
                                echoerr 'Bug behavior is detected!: ' . pid
                              endif
                            
                              return [pid] + fdlist
                            endfunction"}}}
                            
    1              0.000002 function! s:vp_pipe_close() dict
                              " echomsg 'close:'.self.fd
                              if self.fd != 0
                                call s:libcall('vp_pipe_close', [self.fd])
                                let self.fd = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:vp_pipes_close() dict
                              for fd in self.fd
                                try
                                  call fd.close()
                                catch /vimproc: vp_pipe_close: /
                                  " Ignore error.
                                endtry
                              endfor
                            endfunction
                            
    1              0.000002 function! s:vp_pgroup_close() dict
                              call self.fd.close()
                            endfunction
                            
    1              0.000003 function! s:vp_pipe_read(number, timeout) dict
                              if self.fd == 0
                                return ['', 1]
                              endif
                            
                              let [hd, eof] = s:libcall('vp_pipe_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000002 function! s:vp_pipe_write(hd, timeout) dict
                              if self.fd == 0
                                return 0
                              endif
                            
                              let [nleft] = s:libcall('vp_pipe_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000002 function! s:read_pipes(...) dict "{{{
                              if type(self.fd[-1]) != type({})
                                let self.eof = 1
                                return ''
                              endif
                            
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                            
                              let output = self.fd[-1].read(number, timeout)
                              let self.eof = self.fd[-1].eof
                            
                              return output
                            endfunction"}}}
                            
    1              0.000002 function! s:write_pipes(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                            
                              if self.fd[0].eof
                                return 0
                              endif
                            
                              " Write data.
                              let nleft = self.fd[0].write(a:str, timeout)
                              let self.eof = self.fd[0].eof
                            
                              return nleft
                            endfunction"}}}
                            
    1              0.000002 function! s:read_pgroup(...) dict "{{{
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                            
                              let output = ''
                            
                              if !self.fd.eof
                                let output = self.fd.read(number, timeout)
                              endif
                            
                              if self.proc.current_proc.stdout.eof && self.proc.current_proc.stderr.eof
                                " Get status.
                                let [cond, status] = self.proc.current_proc.waitpid()
                            
                                if empty(self.proc.statements)
                                      \ || (self.proc.condition ==# 'true' && status)
                                      \ || (self.proc.condition ==# 'false' && !status)
                                  let self.proc.statements = []
                            
                                  " Caching status.
                                  let self.proc.cond = cond
                                  let self.proc.status = status
                                else
                                  " Initialize next statement.
                                  let proc = vimproc#plineopen3(self.proc.statements[0].statement)
                                  let self.proc.current_proc = proc
                            
                                  let self.pid = proc.pid
                                  let self.pid_list = proc.pid_list
                                  let self.proc.pid = proc.pid
                                  let self.proc.pid_list = proc.pid_list
                                  let self.proc.condition = self.proc.statements[0].condition
                                  let self.proc.statements = self.proc.statements[1:]
                            
                                  let self.proc.stdin = s:fdopen_pgroup(self.proc, proc.stdin, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stdout = s:fdopen_pgroup(self.proc, proc.stdout, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stderr = s:fdopen_pgroup(self.proc, proc.stderr, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                endif
                              endif
                            
                              if self.proc.current_proc.stdout.eof
                                let self.proc.stdout.eof = 1
                                let self.proc.stdout.__eof = 1
                              endif
                            
                              if self.proc.current_proc.stderr.eof
                                let self.proc.stderr.eof = 1
                                let self.proc.stderr.__eof = 1
                              endif
                            
                              return output
                            endfunction"}}}
                            
    1              0.000002 function! s:write_pgroup(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                            
                              let nleft = 0
                              if !self.fd.eof
                                " Write data.
                                let nleft = self.fd.write(a:str, timeout)
                              endif
                            
                              return nleft
                            endfunction"}}}
                            
    1              0.000003 function! s:vp_pty_open(npipe, width, height, hstdin, hstdout, hstderr, argv)
                              let [pid; fdlist] = s:libcall('vp_pty_open',
                                    \ [a:npipe, a:width, a:height,
                                    \  a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
                              return [pid] + fdlist
                            endfunction
                            
    1              0.000002 function! s:vp_pty_close() dict
                              call s:libcall('vp_pty_close', [self.fd])
                            endfunction
                            
    1              0.000003 function! s:vp_pty_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_pty_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000004 function! s:vp_pty_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_pty_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000002 function! s:vp_get_winsize() dict
                              if self.is_pty && vimproc#util#is_windows()
                                return [winwidth(0)-5, winheight(0)]
                              endif
                            
                              for pid in self.pid_list
                                let [width, height] = s:libcall('vp_pty_get_winsize', [pid])
                              endfor
                            
                              return [width, height]
                            endfunction
                            
    1              0.000002 function! s:vp_set_winsize(width, height) dict
                              if vimproc#util#is_windows() || !self.is_valid
                                " Not implemented.
                                return
                              endif
                            
                              if self.is_pty
                                if self.stdin.eof == 0 && self.stdin.fd[-1].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stdin.fd[-1].fd, a:width-5, a:height])
                                endif
                                if self.stdout.eof == 0 && self.stdout.fd[0].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stdout.fd[0].fd, a:width-5, a:height])
                                endif
                                if self.stderr.eof == 0 && self.stderr.fd[0].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stderr.fd[0].fd, a:width-5, a:height])
                                endif
                              endif
                            
                              " Send SIGWINCH = 28 signal.
                              for pid in self.pid_list
                                call vimproc#kill(pid, 28)
                              endfor
                            endfunction
                            
    1              0.000002 function! s:vp_kill(...) dict
                              let sig = get(a:000, 0, g:vimproc#SIGTERM)
                              if sig != 0
                                call s:close_all(self)
                                let self.is_valid = 0
                              endif
                            
                              let ret = 0
                              for pid in get(self, 'pid_list', [self.pid])
                                let ret = vimproc#kill(pid, sig)
                              endfor
                            
                              return ret
                            endfunction
                            
    1              0.000002 function! s:vp_pgroup_kill(...) dict
                              let sig = get(a:000, 0, g:vimproc#SIGTERM)
                              if sig != 0
                                call s:close_all(self)
                                let self.is_valid = 0
                              endif
                            
                              if self.pid == 0
                                " Ignore.
                                return
                              endif
                            
                              return self.current_proc.kill(sig)
                            endfunction
                            
    1              0.000002 function! s:waitpid(pid)
                              try
                                let [cond, status] = s:libcall('vp_waitpid', [a:pid])
                                " echomsg string([a:pid, cond, status])
                                if cond ==# 'run'
                                  " Add process list.
                                  let s:bg_processes[a:pid] = a:pid
                            
                                  let [cond, status] = ['exit', '0']
                                elseif vimproc#util#is_windows()
                                  call s:libcall('vp_close_handle', [a:pid])
                                endif
                            
                                let s:last_status = status
                              catch
                                let [cond, status] = ['error', '0']
                              endtry
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000002 function! s:vp_checkpid() dict
                              try
                                let [cond, status] = s:libcall('vp_waitpid', [self.pid])
                                if cond !=# 'run'
                                  let [self.cond, self.status] = [cond, status]
                                endif
                              catch /waitpid() error:\|vp_waitpid:/
                                let [cond, status] = ['error', '0']
                              endtry
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000002 function! s:vp_waitpid() dict
                              call s:close_all(self)
                            
                              let self.is_valid = 0
                            
                              if has_key(self, 'cond') && has_key(self, 'status')
                                " Use cache.
                                let [cond, status] = [self.cond, self.status]
                              else
                                let [cond, status] = s:waitpid(self.pid)
                              endif
                            
                              if cond ==# 'exit'
                                let self.pid = 0
                              endif
                            
                              if has_key(self, 'pid_list')
                                for pid in self.pid_list[: -2]
                                  call s:waitpid(pid)
                                endfor
                              endif
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000002 function! s:vp_pgroup_waitpid() dict
                              call s:close_all(self)
                            
                              let self.is_valid = 0
                            
                              if !has_key(self, 'cond') ||
                                    \ !has_key(self, 'status')
                                return s:waitpid(self.pid)
                              endif
                            
                              return [self.cond, self.status]
                            endfunction
                            
    1              0.000002 function! s:vp_socket_open(host, port)
                              let [socket] = s:libcall('vp_socket_open', [a:host, a:port])
                              return socket
                            endfunction
                            
    1              0.000002 function! s:vp_socket_close() dict
                              call s:libcall('vp_socket_close', [self.fd])
                              let self.is_valid = 0
                            endfunction
                            
    1              0.000002 function! s:vp_socket_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_socket_read',
                                    \ [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000002 function! s:vp_socket_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_socket_write',
                                    \ [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000002 function! s:vp_host_exists(host)
                              let [rval] = s:libcall('vp_host_exists', [a:host])
                              return rval
                            endfunction
                            
                            " Initialize.
    1              0.000004 if !exists('s:dll_handle')
    1   0.000751   0.000009   let s:dll_handle = s:vp_dlopen(g:vimproc#dll_path)
    1              0.000003   let s:last_status = 0
    1              0.000002   let s:last_errmsg = ''
    1              0.000001 endif
                            
                            " vimproc dll version check. "{{{
    1              0.000001 try
    1   0.000111   0.000010   let dll_version = vimproc#dll_version()
    1   0.000015   0.000008   if dll_version < vimproc#version()
                                call s:print_error(printf('Your vimproc binary version is "%d",'.
                                      \ ' but vimproc version is "%d".',
                                      \ dll_version, vimproc#version()))
                              endif
    1              0.000002 catch
                              call s:print_error(v:throwpoint)
                              call s:print_error(v:exception)
                              call s:print_error('Your vimproc binary is too old!')
                              call s:print_error('Please re-compile it.')
                            endtry
                            
    1              0.000001 unlet dll_version
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            " }}}
                            
                            " __END__
                            " vim:foldmethod=marker:fen:sw=2:sts=2

SCRIPT  /home/skl/.vim/bundle/vimproc.vim/autoload/vimproc/util.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000229

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " Last Modified: 20 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Saving 'cpoptions' {{{
    1              0.000010 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            " }}}
                            
    1              0.000010 let s:is_windows = has('win16') || has('win32') || has('win64')
    1              0.000005 let s:is_cygwin = has('win32unix')
    1              0.000015 let s:is_mac = !s:is_windows
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
                            
                            " iconv() wrapper for safety.
    1              0.000005 function! vimproc#util#iconv(expr, from, to) "{{{
                              if !has('iconv')
                                    \ || a:expr == '' || a:from == ''
                                    \ || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr
                            endfunction"}}}
    1              0.000005 function! vimproc#util#termencoding() "{{{
                              return 'char'
                            endfunction"}}}
    1              0.000003 function! vimproc#util#stdinencoding() "{{{
                              return exists('g:stdinencoding') && type(g:stdinencoding) == type("") ?
                                    \ g:stdinencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000003 function! vimproc#util#stdoutencoding() "{{{
                              return exists('g:stdoutencoding') && type(g:stdoutencoding) == type("") ?
                                    \ g:stdoutencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000003 function! vimproc#util#stderrencoding() "{{{
                              return exists('g:stderrencoding') && type(g:stderrencoding) == type("") ?
                                    \ g:stderrencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000003 function! vimproc#util#expand(path) "{{{
                              return vimproc#util#substitute_path_separator(
                                    \ (a:path =~ '^\~') ? substitute(a:path, '^\~', expand('~'), '') :
                                    \ (a:path =~ '^\$\h\w*') ? substitute(a:path,
                                    \               '^\$\h\w*', '\=eval(submatch(0))', '') :
                                    \ a:path)
                            endfunction"}}}
    1              0.000003 function! vimproc#util#is_windows() "{{{
                              return s:is_windows
                            endfunction"}}}
    1              0.000003 function! vimproc#util#is_mac() "{{{
                              return s:is_mac
                            endfunction"}}}
    1              0.000002 function! vimproc#util#is_cygwin() "{{{
                              return s:is_cygwin
                            endfunction"}}}
    1              0.000002 function! vimproc#util#has_lua() "{{{
                              " Note: Disabled if_lua feature if less than 7.3.885.
                              " Because if_lua has double free problem.
                              return has('lua') && (v:version > 703 || v:version == 703 && has('patch885'))
                            endfunction"}}}
    1              0.000003 function! vimproc#util#substitute_path_separator(path) "{{{
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction"}}}
                            
    1              0.000003 function! vimproc#util#uniq(list, ...) "{{{
                              let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(a:0 ? list[i][1] : list[i])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:0 ? map(list, 'v:val[0]') : list
                            endfunction"}}}
    1              0.000003 function! vimproc#util#set_default(var, val, ...)  "{{{
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let alternate_var = get(a:000, 0, '')
                            
                                let {a:var} = exists(alternate_var) ?
                                      \ {alternate_var} : a:val
                              endif
                            endfunction"}}}
                            
                            " Global options definition. "{{{
    1   0.000030   0.000010 call vimproc#util#set_default(
                                  \ 'g:stdinencoding', 'char')
    1   0.000023   0.000007 call vimproc#util#set_default(
                                  \ 'g:stdoutencoding', 'char')
    1   0.000022   0.000007 call vimproc#util#set_default(
                                  \ 'g:stderrencoding', 'char')
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000009 let &cpo = s:save_cpo
                            " }}}
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/candidates.vim
Sourced 1 time
Total time:   0.001032
 Self time:   0.001032

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: candidates.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 01 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000046 let s:save_cpo = &cpo
    1              0.000035 set cpo&vim
                            
    1              0.000028 function! unite#candidates#_recache(input, is_force) "{{{
                              let unite = unite#get_current_unite()
                            
                              " Save options.
                              let ignorecase_save = &ignorecase
                            
                              if unite#custom#get_profile(unite.profile_name, 'smartcase')
                                    \ && get(split(a:input, '\W'), -1, '') =~ '\u'
                                let &ignorecase = 0
                              else
                                let &ignorecase =
                                      \ unite#custom#get_profile(unite.profile_name, 'ignorecase')
                              endif
                            
                              let context = unite.context
                              let context.is_redraw = a:is_force
                              let context.is_changed = a:input !=# unite.last_input
                            
                              for source in unite.sources
                                let source.unite__candidates = []
                              endfor
                            
                              let inputs = unite#helper#get_substitute_input(a:input)
                              let context.is_list_input = len(inputs) > 1
                              for input in inputs
                                let context.input = input
                                call s:recache_candidates_loop(context, a:is_force)
                              endfor
                            
                              let filtered_count = 0
                            
                              for source in unite.sources
                                let source.unite__is_invalidate = 0
                            
                                if !context.no_buffer && source.max_candidates != 0
                                      \ && !context.unite__is_interactive
                                      \ && !unite.disabled_max_candidates
                                      \ && len(source.unite__candidates) > source.max_candidates
                                  " Filtering too many candidates.
                                  let source.unite__candidates =
                                        \ source.unite__candidates[: source.max_candidates - 1]
                            
                                  if context.verbose && filtered_count < &cmdheight
                                    echohl WarningMsg | echomsg printf(
                                          \ '[%s] Filtering too many candidates.', source.name)
                                          \ | echohl None
                                    let filtered_count += 1
                                  endif
                                endif
                            
                                " Call post_filter hook.
                                let source.unite__context.candidates =
                                      \ source.unite__candidates
                                call unite#helper#call_hook([source], 'on_post_filter')
                            
                                let source.unite__candidates =
                                      \ unite#init#_candidates_source(
                                      \   source.unite__context.candidates, source.name)
                              endfor
                            
                              " Update async state.
                              let unite.is_async =
                                    \ len(filter(copy(unite.sources),
                                    \           'v:val.unite__context.is_async')) > 0
                            
                              let &ignorecase = ignorecase_save
                            endfunction"}}}
                            
    1              0.000012 function! unite#candidates#gather(...) "{{{
                              let is_gather_all = get(a:000, 0, 0)
                            
                              let unite = unite#get_current_unite()
                              let unite.candidates = []
                              for source in unite.sources
                                let unite.candidates += source.unite__candidates
                              endfor
                            
                              if is_gather_all
                                let unite.candidates_pos = len(unite.candidates)
                              elseif unite.context.is_redraw || unite.candidates_pos == 0
                                let unite.candidates_pos = line('.') + winheight(0)
                              endif
                            
                              let candidates = unite#init#_candidates(
                                    \ unite.candidates[: unite.candidates_pos-1])
                            
                              " Post filter.
                              for filter_name in unite.post_filters
                                let candidates = unite#helper#call_filter(
                                      \ filter_name, candidates, unite.context)
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000013 function! unite#candidates#_gather_pos(offset) "{{{
                              let unite = unite#get_current_unite()
                              if unite.context.is_redraw || unite.candidates_pos == 0
                                return []
                              endif
                            
                              let unite = unite#get_current_unite()
                              let candidates = unite.candidates[unite.candidates_pos :
                                    \ unite.candidates_pos + a:offset - 1]
                            
                              " Post filter.
                              for filter_name in unite.post_filters
                                let candidates = unite#helper#call_filter(
                                      \ filter_name, candidates, unite.context)
                              endfor
                            
                              let unite.candidates_pos += len(candidates)
                            
                              return unite#init#_candidates(candidates)
                            endfunction"}}}
                            
    1              0.000015 function! s:recache_candidates_loop(context, is_force) "{{{
                              let unite = unite#get_current_unite()
                            
                              let input_len = unite#util#strchars(a:context.input)
                            
                              let custom = unite#custom#get()
                            
                              let candidate_sources = []
                              let unite.max_source_candidates = 0
                              for source in unite.sources
                                " Check required pattern length.
                                if input_len < source.required_pattern_length
                                  continue
                                endif
                            
                                " Set context.
                                let context = source.unite__context
                                let context.input = a:context.input
                                let context.source_name = source.name
                            
                                if source.required_pattern_length > 0
                                      \ && !source.is_forced
                                  " Forced redraw.
                                  let context.is_redraw = 1
                                  let source.is_forced = 1
                                else
                                  let context.is_redraw = a:context.is_redraw
                                endif
                                let context.is_changed = a:context.is_changed
                                let context.is_invalidate = source.unite__is_invalidate
                                let context.is_list_input = a:context.is_list_input
                                let context.input_list = split(context.input, '\\\@<! ', 1)
                                let context.path = get(filter(copy(context.input_list),
                                    \         "v:val !~ '^[!:]'"), 0, '')
                                let context.unite__max_candidates =
                                      \ (unite.disabled_max_candidates ? 0 : source.max_candidates)
                            
                                let source_candidates = s:get_source_candidates(source)
                            
                                let custom_source = get(custom.sources, source.name, {})
                                if source.ignore_pattern != '' && !context.unite__is_vimfiler
                                  call filter(source_candidates,
                                        \ "get(v:val, 'action__path', v:val.word)
                                        \             !~# source.ignore_pattern")
                                endif
                            
                                " Call pre_filter hook.
                                let context.candidates = source_candidates
                                call unite#helper#call_hook([source], 'on_pre_filter')
                            
                                " Set filters.
                                let matchers = []
                                let sorters = []
                                let prev_filters = []
                                let post_filters = []
                                for Filter in (context.unite__is_vimfiler ?
                                      \ [] : get(custom_source, 'filters', source.filters))
                                  if type(Filter) != type('')
                                    call add((empty(matchers) ?
                                          \ prev_filters : post_filters), Filter)
                            
                                    unlet Filter
                                    continue
                                  endif
                            
                                  let name = get(unite#get_filters(Filter),
                                        \              'name', '')
                                  if name == ''
                                    call unite#print_error(printf(
                                          \ 'Invalid filter name "%s" is detected.', Filter))
                                  elseif name =~# '\%(^\|_\)matcher_'
                                    call add(matchers, Filter)
                                  elseif name =~# '\%(^\|_\)sorter_'
                                    if name ==# 'sorter_default'
                                      let sorters += unite#filters#sorter_default#get()
                                    else
                                      call add(sorters, Filter)
                                    endif
                                  else
                                    call add((empty(matchers) ?
                                          \ prev_filters : post_filters), Filter)
                                  endif
                                  unlet Filter
                                endfor
                            
                                if sorters ==# ['sorter_nothing']
                                      \ || unite.context.unite__is_vimfiler
                                  let sorters = []
                                endif
                            
                                let context.unite__is_sort_nothing =
                                      \ empty(sorters) && context.unite__is_interactive
                                let source.unite__orig_len_candidates = len(source_candidates)
                                let unite.max_source_candidates +=
                                      \ (context.unite__is_sort_nothing
                                      \    && context.unite__max_candidates > 0) ?
                                      \ source.max_candidates : source.unite__orig_len_candidates
                            
                                " Call filters.
                                for Filter in prev_filters + matchers + sorters + post_filters
                                  if type(Filter) == type('')
                                    let source_candidates = unite#helper#call_filter(
                                          \ Filter, source_candidates, context)
                                  else
                                    let source_candidates = call(Filter,
                                          \ [source_candidates, context], source)
                                  endif
                            
                                  unlet Filter
                                endfor
                            
                                " Get execute_command.
                                let a:context.execute_command = context.execute_command
                            
                                let source.unite__candidates += source_candidates
                                let source.unite__len_candidates = len(source_candidates)
                                if !empty(source_candidates)
                                  call add(candidate_sources,
                                        \ unite#helper#convert_source_name(source.name))
                                endif
                              endfor
                            
                              if !a:context.hide_source_names && len(unite.sources) > 1
                                let unite.max_source_name =
                                      \ max(map(candidate_sources, 'len(v:val)')) + 1
                              endif
                            endfunction"}}}
                            
    1              0.000010 function! s:get_source_candidates(source) "{{{
                              let context = a:source.unite__context
                            
                              let funcname = 's:get_source_candidates()'
                              try
                                if context.unite__is_vimfiler
                                  if context.vimfiler__is_dummy
                                    let funcname = 'vimfiler_dummy_candidates'
                                    return has_key(a:source, 'vimfiler_dummy_candidates') ?
                                          \ copy(a:source.vimfiler_dummy_candidates(
                                          \           a:source.args, a:source.unite__context)) : []
                                  else
                                    let funcname = 'vimfiler_gather_candidates'
                                    return has_key(a:source, 'vimfiler_gather_candidates') ?
                                          \ copy(a:source.vimfiler_gather_candidates(
                                          \           a:source.args, a:source.unite__context)) : []
                                  endif
                                endif
                            
                                if context.is_redraw || a:source.unite__is_invalidate
                                  " Recaching.
                                  let a:source.unite__cached_candidates = []
                            
                                  let funcname = 'gather_candidates'
                                  if has_key(a:source, 'gather_candidates')
                                    let a:source.unite__cached_candidates +=
                                          \ copy(a:source.gather_candidates(a:source.args,
                                          \ a:source.unite__context))
                                  endif
                                endif
                            
                                if a:source.unite__context.is_async
                                  " Get asynchronous candidates.
                                  let funcname = 'async_gather_candidates'
                                  while 1
                                    let a:source.unite__cached_candidates +=
                                          \ a:source.async_gather_candidates(a:source.args, context)
                            
                                    if context.unite__is_interactive
                                          \ || !a:source.unite__context.is_async
                                      break
                                    endif
                                  endwhile
                                endif
                            
                                if has_key(a:source, 'change_candidates')
                                      \ && (context.is_redraw || context.is_changed
                                      \     || a:source.unite__is_invalidate)
                                  " Recaching.
                                  let funcname = 'change_candidates'
                                  let a:source.unite__cached_change_candidates =
                                        \ a:source.change_candidates(
                                        \     a:source.args, a:source.unite__context)
                                endif
                              catch
                                call unite#print_error(v:throwpoint)
                                call unite#print_error(v:exception)
                                call unite#print_error(
                                      \ '[unite.vim] Error occured in ' . funcname . '!')
                                call unite#print_error(
                                      \ '[unite.vim] Source name is ' . a:source.name)
                            
                                return []
                              endtry
                            
                              return a:source.unite__cached_candidates
                                    \ + a:source.unite__cached_change_candidates
                            endfunction"}}}
                            
    1              0.000035 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/neocomplete.vim/autoload/vital/_b6a796b/Data/String.vim
Sourced 1 time
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
                            " Utilities for string.
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000005 function! s:_vital_loaded(V)
                              let s:V = a:V
                              let s:L = s:V.import('Data.List')
                            endfunction
                            
    1              0.000002 function! s:_vital_depends()
                              return ['Data.List']
                            endfunction
                            
                            " Substitute a:from => a:to by string.
                            " To substitute by pattern, use substitute() instead.
    1              0.000002 function! s:replace(str, from, to)
                              return s:_replace(a:str, a:from, a:to, 'g')
                            endfunction
                            
                            " Substitute a:from => a:to only once.
                            " cf. s:replace()
    1              0.000003 function! s:replace_first(str, from, to)
                              return s:_replace(a:str, a:from, a:to, '')
                            endfunction
                            
                            " implement of replace() and replace_first()
    1              0.000003 function! s:_replace(str, from, to, flags)
                              return substitute(a:str, '\V'.escape(a:from, '\'), escape(a:to, '\'), a:flags)
                            endfunction
                            
    1              0.000003 function! s:scan(str, pattern)
                              let list = []
                              call substitute(a:str, a:pattern, '\=add(list, submatch(0)) == [] ? "" : ""', 'g')
                              return list
                            endfunction
                            
    1              0.000002 function! s:reverse(str)
                              return join(reverse(split(a:str, '.\zs')), '')
                            endfunction
                            
    1              0.000002 function! s:common_head(strs)
                              if empty(a:strs)
                                return ''
                              endif
                              let len = len(a:strs)
                              if len == 1
                                return a:strs[0]
                              endif
                              let strs = len == 2 ? a:strs : sort(copy(a:strs))
                              let pat = substitute(strs[0], '.', '[\0]', 'g')
                              return pat == '' ? '' : matchstr(strs[-1], '^\%[' . pat . ']')
                            endfunction
                            
                            " Split to two elements of List. ([left, right])
                            " e.g.: s:split3('neocomplcache', 'compl') returns ['neo', 'compl', 'cache']
    1              0.000002 function! s:split_leftright(expr, pattern)
                              let [left, _, right] = s:split3(a:expr, a:pattern)
                              return [left, right]
                            endfunction
                            
    1              0.000002 function! s:split3(expr, pattern)
                              let ERROR = ['', '', '']
                              if a:expr ==# '' || a:pattern ==# ''
                                return ERROR
                              endif
                              let begin = match(a:expr, a:pattern)
                              if begin is -1
                                return ERROR
                              endif
                              let end   = matchend(a:expr, a:pattern)
                              let left  = begin <=# 0 ? '' : a:expr[: begin - 1]
                              let right = a:expr[end :]
                              return [left, a:expr[begin : end-1], right]
                            endfunction
                            
                            " Slices into strings determines the number of substrings.
                            " e.g.: s:nsplit("neo compl cache", 2, '\s') returns ['neo', 'compl cache']
    1              0.000002 function! s:nsplit(expr, n, ...)
                              let pattern = get(a:000, 0, '\s')
                              let keepempty = get(a:000, 1, 1)
                              let ret = []
                              let expr = a:expr
                              if a:n <= 1
                                return [expr]
                              endif
                              while 1
                                let pos = match(expr, pattern)
                                if pos == -1
                                  if expr !~ pattern || keepempty
                                    call add(ret, expr)
                                  endif
                                  break
                                elseif pos >= 0
                                  let left = pos > 0 ? expr[:pos-1] : ''
                                  if pos > 0 || keepempty
                                    call add(ret, left)
                                  endif
                                  let ml = len(matchstr(expr, pattern))
                                  if pos == 0 && ml == 0
                                    let pos = 1
                                  endif
                                  let expr = expr[pos+ml :]
                                endif
                                if len(expr) == 0
                                  break
                                endif
                                if len(ret) == a:n - 1
                                  call add(ret, expr)
                                  break
                                endif
                              endwhile
                              return ret
                            endfunction
                            
                            " Returns the number of character in a:str.
                            " NOTE: This returns proper value
                            " even if a:str contains multibyte character(s).
                            " s:strchars(str) {{{
    1              0.000006 if exists('*strchars')
    1              0.000002   function! s:strchars(str)
                                return strchars(a:str)
                              endfunction
    1              0.000001 else
                              function! s:strchars(str)
                                return strlen(substitute(copy(a:str), '.', 'x', 'g'))
                              endfunction
                            endif "}}}
                            
                            " Returns the bool of contains any multibyte character in s:str
    1              0.000003 function! s:contains_multibyte(str) "{{{
                              return strlen(a:str) != s:strchars(a:str)
                            endfunction "}}}
                            
                            " Remove last character from a:str.
                            " NOTE: This returns proper value
                            " even if a:str contains multibyte character(s).
    1              0.000002 function! s:chop(str) "{{{
                              return substitute(a:str, '.$', '', '')
                            endfunction "}}}
                            
                            " Remove last \r,\n,\r\n from a:str.
    1              0.000001 function! s:chomp(str) "{{{
                              return substitute(a:str, '\%(\r\n\|[\r\n]\)$', '', '')
                            endfunction "}}}
                            
                            " wrap() and its internal functions
                            " * _split_by_wcswidth_once()
                            " * _split_by_wcswidth()
                            " * _concat()
                            " * wrap()
                            "
                            " NOTE _concat() is just a copy of Data.List.concat().
                            " FIXME don't repeat yourself
    1              0.000003 function! s:_split_by_wcswidth_once(body, x)
                              let fst = s:V.strwidthpart(a:body, a:x)
                              let snd = s:V.strwidthpart_reverse(a:body, s:V.wcswidth(a:body) - s:V.wcswidth(fst))
                              return [fst, snd]
                            endfunction
                            
    1              0.000003 function! s:_split_by_wcswidth(body, x)
                              let memo = []
                              let body = a:body
                              while s:V.wcswidth(body) > a:x
                                let [tmp, body] = s:_split_by_wcswidth_once(body, a:x)
                                call add(memo, tmp)
                              endwhile
                              call add(memo, body)
                              return memo
                            endfunction
                            
    1              0.000002 function! s:trim(str)
                              return matchstr(a:str,'^\s*\zs.\{-}\ze\s*$')
                            endfunction
                            
    1              0.000002 function! s:wrap(str,...)
                              let _columns = a:0 > 0 ? a:1 : &columns
                              return s:L.concat(
                                    \ map(split(a:str, '\r\n\|[\r\n]'), 's:_split_by_wcswidth(v:val, _columns - 1)'))
                            endfunction
                            
    1              0.000002 function! s:nr2byte(nr)
                              if a:nr < 0x80
                                return nr2char(a:nr)
                              elseif a:nr < 0x800
                                return nr2char(a:nr/64+192).nr2char(a:nr%64+128)
                              else
                                return nr2char(a:nr/4096%16+224).nr2char(a:nr/64%64+128).nr2char(a:nr%64+128)
                              endif
                            endfunction
                            
    1              0.000002 function! s:nr2enc_char(charcode)
                              if &encoding == 'utf-8'
                                return nr2char(a:charcode)
                              endif
                              let char = s:nr2byte(a:charcode)
                              if strlen(char) > 1
                                let char = strtrans(iconv(char, 'utf-8', &encoding))
                              endif
                              return char
                            endfunction
                            
    1              0.000002 function! s:nr2hex(nr)
                              let n = a:nr
                              let r = ""
                              while n
                                let r = '0123456789ABCDEF'[n % 16] . r
                                let n = n / 16
                              endwhile
                              return r
                            endfunction
                            
                            " If a ==# b, returns -1.
                            " If a !=# b, returns first index of diffrent character.
    1              0.000002 function! s:diffidx(a, b)
                              return a:a ==# a:b ? -1 : strlen(s:common_head([a:a, a:b]))
                            endfunction
                            
    1              0.000002 function! s:substitute_last(expr, pat, sub)
                              return substitute(a:expr, printf('.*\zs%s', a:pat), a:sub, '')
                            endfunction
                            
    1              0.000002 function! s:dstring(expr)
                              let x = substitute(string(a:expr), "^'\\|'$", '', 'g')
                              let x = substitute(x, "''", "'", 'g')
                              return printf('"%s"', escape(x, '"'))
                            endfunction
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/view.vim
Sourced 1 time
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: view.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 21 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000008 function! unite#view#_redraw_candidates(...) "{{{
                              let is_gather_all = get(a:000, 0, 0)
                            
                              call unite#view#_resize_window()
                            
                              let candidates = unite#candidates#gather(is_gather_all)
                            
                              let modifiable_save = &l:modifiable
                              setlocal modifiable
                            
                              let lines = unite#view#_convert_lines(candidates)
                              let pos = getpos('.')
                              let unite = unite#get_current_unite()
                              if len(lines) < len(unite.current_candidates)
                                silent! execute (unite.prompt_linenr+1).',$delete _'
                              endif
                              call setline(unite.prompt_linenr+1, lines)
                            
                              let &l:modifiable = l:modifiable_save
                            
                              let unite = unite#get_current_unite()
                              let context = unite.context
                              let unite.current_candidates = candidates
                            
                              if pos != getpos('.')
                                call setpos('.', pos)
                              endif
                            
                              if context.input == '' && context.log
                                " Move to bottom.
                                call cursor(line('$'), 0)
                              endif
                            
                              " Set syntax.
                              call s:set_syntax()
                            endfunction"}}}
    1              0.000004 function! unite#view#_redraw_line(...) "{{{
                              let linenr = a:0 > 0 ? a:1 : line('.')
                              if linenr <= unite#get_current_unite().prompt_linenr || &filetype !=# 'unite'
                                " Ignore.
                                return
                              endif
                            
                              let modifiable_save = &l:modifiable
                              setlocal modifiable
                            
                              let candidate = unite#get_unite_candidates()[linenr -
                                    \ (unite#get_current_unite().prompt_linenr+1)]
                              call setline(linenr, unite#view#_convert_lines([candidate])[0])
                            
                              let &l:modifiable = modifiable_save
                            endfunction"}}}
    1              0.000004 function! unite#view#_quick_match_redraw(quick_match_table) "{{{
                              let modifiable_save = &l:modifiable
                              setlocal modifiable
                            
                              call setline(unite#get_current_unite().prompt_linenr+1,
                                    \ unite#view#_convert_lines(
                                    \ unite#get_current_unite().current_candidates,
                                    \ a:quick_match_table))
                              redraw
                            
                              let &l:modifiable = modifiable_save
                            endfunction"}}}
                            
    1              0.000004 function! unite#view#_redraw(is_force, winnr, is_gather_all) "{{{
                              if unite#util#is_cmdwin()
                                return
                              endif
                            
                              if a:winnr > 0
                                " Set current unite.
                                let unite = getbufvar(winbufnr(a:winnr), 'unite')
                                let unite_save = unite#variables#current_unite()
                                let winnr_save = winnr()
                            
                                execute a:winnr 'wincmd w'
                            
                                let line_save = unite.prompt_linenr
                              endif
                            
                              try
                                if &filetype !=# 'unite'
                                  return
                                endif
                            
                                let unite = unite#get_current_unite()
                                let context = unite.context
                            
                                if !context.is_redraw
                                  let context.is_redraw = a:is_force
                                endif
                            
                                if context.is_redraw
                                  call unite#clear_message()
                                endif
                            
                                let input = unite#helper#get_input()
                                if !context.is_redraw && input ==# unite.last_input
                                      \ && !unite.is_async
                                      \ && !context.is_resize
                                      \ && !a:is_gather_all
                                  return
                                endif
                            
                                let is_gather_all = a:is_gather_all || context.log
                            
                                if context.is_redraw
                                      \ || input !=# unite.last_input
                                      \ || unite.is_async
                                  " Recaching.
                                  call unite#candidates#_recache(input, a:is_force)
                                endif
                            
                                let unite.last_input = input
                            
                                " Redraw.
                                call unite#view#_redraw_candidates(is_gather_all)
                                let unite.context.is_redraw = 0
                              finally
                                if a:winnr > 0
                                  if unite.prompt_linenr != line_save
                                    " Updated.
                                    normal! G
                                  endif
                            
                                  " Restore current unite.
                                  call unite#set_current_unite(unite_save)
                                  execute winnr_save 'wincmd w'
                                endif
                              endtry
                            
                              if context.auto_preview
                                call unite#view#_do_auto_preview()
                              endif
                              if context.auto_highlight
                                call unite#view#_do_auto_highlight()
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_set_highlight() "{{{
                              let unite = unite#get_current_unite()
                            
                              " Set highlight.
                              let match_prompt = escape(unite.prompt, '\/*~.^$[]')
                              silent! syntax clear uniteInputPrompt
                              execute 'syntax match uniteInputPrompt'
                                    \ '/^'.match_prompt.'/ contained'
                            
                              let marked_icon = unite#util#escape_pattern(g:unite_marked_icon)
                              execute 'syntax region uniteMarkedLine start=/^'.
                                    \ marked_icon.'/ end=''$'' keepend'
                            
                              let candidate_icon = unite#util#escape_pattern(g:unite_candidate_icon)
                              execute 'syntax region uniteNonMarkedLine start=/^'.
                                    \ candidate_icon.' / end=''$'' keepend'.
                                    \ ' contains=uniteCandidateMarker,'.
                                    \ 'uniteCandidateSourceName,uniteCandidateAbbr'
                              execute 'syntax match uniteCandidateMarker /^'.
                                    \ candidate_icon.' / contained'
                            
                              execute 'syntax match uniteInputLine'
                                    \ '/\%'.unite.prompt_linenr.'l.*/'
                                    \ 'contains=uniteInputPrompt,uniteInputPromptError,'.
                                    \ 'uniteInputCommand'
                            
                              silent! syntax clear uniteCandidateSourceName
                              if unite.max_source_name > 0
                                syntax match uniteCandidateSourceName
                                      \ /\%3c[[:alnum:]_\/-]\+/ contained
                              else
                                execute 'syntax match uniteCandidateSourceName /^'.
                                      \ candidate_icon.' / contained'
                              endif
                            
                              execute 'highlight default link uniteCandidateAbbr'
                                    \ g:unite_abbr_highlight
                            
                              " Set syntax.
                              for source in filter(copy(unite.sources), 'v:val.syntax != ""')
                                let name = unite.max_source_name > 0 ?
                                      \ unite#helper#convert_source_name(source.name) : ''
                            
                                execute 'highlight default link'
                                      \ source.syntax g:unite_abbr_highlight
                            
                                execute printf('syntax match %s "^['.g:unite_candidate_icon.' ] %s" '.
                                      \ 'nextgroup='.source.syntax.
                                      \ ' keepend contains=uniteCandidateMarker,%s',
                                      \ 'uniteSourceLine__'.source.syntax,
                                      \ (name == '' ? '' : name . '\>'),
                                      \ (name == '' ? '' : 'uniteCandidateSourceName')
                                      \ )
                            
                                call unite#helper#call_hook([source], 'on_syntax')
                              endfor
                            
                              call s:set_syntax()
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_resize_window() "{{{
                              if &filetype !=# 'unite' || winnr('$') == 1
                                return
                              endif
                            
                              let context = unite#get_context()
                              let unite = unite#get_current_unite()
                            
                              if context.no_split
                                let context.is_resize = 0
                                return
                              endif
                            
                              if context.unite__old_winwidth != 0
                                    \ && context.unite__old_winheight != 0
                                    \ && winheight(0) != context.unite__old_winheight
                                    \ && winwidth(0) != context.unite__old_winwidth
                                " Disabled auto resize.
                                let context.winwidth = 0
                                let context.winheight = 0
                                let context.is_resize = 1
                                return
                              endif
                            
                              if context.auto_resize && line('.') == unite.prompt_linenr
                                " Auto resize.
                                let max_len = unite.prompt_linenr + len(unite.candidates)
                                silent! execute 'resize' min([max_len, context.winheight])
                                if line('.') <= winheight(0)
                                  normal! zb
                                endif
                                if mode() ==# 'i' && col('.') == (col('$') - 1)
                                  startinsert!
                                endif
                            
                                let context.is_resize = 1
                              elseif context.vertical
                                    \ && context.unite__old_winwidth  == 0
                                    " \ && winwidth(winnr()) != context.winwidth
                                    " \ && (context.unite__old_winwidth  == 0 ||
                                    " \     winheight(winnr()) == context.unite__old_winheight)
                                execute 'vertical resize' context.winwidth
                            
                                let context.is_resize = 1
                              elseif !context.vertical
                                    \ && context.unite__old_winheight  == 0
                                    " \ && winheight(winnr()) != context.winheight
                                    " \ && (context.unite__old_winheight == 0 ||
                                    " \     winwidth(winnr()) == context.unite__old_winwidth)
                                execute 'resize' context.winheight
                            
                                let context.is_resize = 1
                              else
                                let context.is_resize = 0
                              endif
                            
                              let context.unite__old_winheight = winheight(winnr())
                              let context.unite__old_winwidth = winwidth(winnr())
                            endfunction"}}}
                            
    1              0.000004 function! unite#view#_convert_lines(candidates, ...) "{{{
                              let quick_match_table = get(a:000, 0, {})
                            
                              let unite = unite#get_current_unite()
                              let context = unite.context
                              let [max_width, max_source_name] =
                                    \ unite#helper#adjustments(winwidth(0)-1, unite.max_source_name, 2)
                              if unite.max_source_name == 0
                                let max_width -= 1
                              endif
                            
                              " Create key table.
                              let keys = {}
                              for [key, number] in items(quick_match_table)
                                let keys[number] = key . '|'
                              endfor
                            
                              return map(copy(a:candidates),
                                    \ "(v:val.is_dummy ? '  ' :
                                    \   v:val.unite__is_marked ? g:unite_marked_icon . ' ' :
                                    \   empty(quick_match_table) ? g:unite_candidate_icon . ' ' :
                                    \   get(keys, v:key, '  '))
                                    \ . (unite.max_source_name == 0 ? ''
                                    \   : unite#util#truncate(unite#helper#convert_source_name(
                                    \     (v:val.is_dummy ? '' : v:val.source)), max_source_name))
                                    \ . unite#util#truncate_wrap(v:val.unite__abbr, " . max_width
                                    \    .  ", (context.truncate ? 0 : max_width/2), '..')")
                            endfunction"}}}
                            
    1              0.000004 function! unite#view#_do_auto_preview() "{{{
                              let unite = unite#get_current_unite()
                            
                              if unite.preview_candidate == unite#helper#get_current_candidate()
                                return
                              endif
                            
                              let unite.preview_candidate = unite#helper#get_current_candidate()
                            
                              call unite#action#do('preview', [], {})
                            
                              " Restore window size.
                              let context = unite#get_context()
                              if s:has_preview_window()
                                call unite#view#_resize_window()
                              endif
                            endfunction"}}}
    1              0.000004 function! unite#view#_do_auto_highlight() "{{{
                              let unite = unite#get_current_unite()
                            
                              if unite.highlight_candidate == unite#helper#get_current_candidate()
                                return
                              endif
                              let unite.highlight_candidate = unite#helper#get_current_candidate()
                            
                              call unite#action#do('highlight', [], {})
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_switch_unite_buffer(buffer_name, context) "{{{
                              " Search unite window.
                              let winnr = unite#helper#get_unite_winnr(a:buffer_name)
                              if !a:context.no_split && winnr > 0
                                silent execute winnr 'wincmd w'
                                return
                              endif
                            
                              " Search unite buffer.
                              let bufnr = unite#helper#get_unite_bufnr(a:buffer_name)
                            
                              if !a:context.no_split && !a:context.unite__direct_switch
                                " Split window.
                                execute a:context.direction ((bufnr > 0) ?
                                      \ ((a:context.vertical) ? 'vsplit' : 'split') :
                                      \ ((a:context.vertical) ? 'vnew' : 'new'))
                              endif
                            
                              if bufnr > 0
                                silent noautocmd execute bufnr 'buffer'
                              else
                                if bufname('%') == ''
                                  noautocmd silent enew
                                endif
                                silent! noautocmd edit `=a:context.real_buffer_name`
                              endif
                            
                              call unite#handlers#_on_bufwin_enter(bufnr('%'))
                              doautocmd WinEnter
                              doautocmd BufWinEnter
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_close(buffer_name)  "{{{
                              let buffer_name = a:buffer_name
                              if buffer_name !~ '@\d\+$'
                                " Add postfix.
                                let prefix = '[unite] - '
                                let prefix .= buffer_name
                                let buffer_name .= unite#helper#get_postfix(
                                      \ prefix, 0, tabpagebuflist(tabpagenr()))
                              endif
                            
                              " Search unite window.
                              let quit_winnr = unite#helper#get_unite_winnr(a:buffer_name)
                            
                              if quit_winnr > 0
                                " Quit unite buffer.
                                silent execute quit_winnr 'wincmd w'
                                call unite#force_quit_session()
                              endif
                            
                              return quit_winnr > 0
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_init_cursor() "{{{
                              let unite = unite#get_current_unite()
                              let context = unite.context
                            
                              let positions = unite#custom#get_profile(
                                    \ unite.profile_name, 'unite__save_pos')
                              let key = unite#loaded_source_names_string()
                              let is_restore = has_key(positions, key) && context.select == 0 &&
                                    \   positions[key].candidate ==#
                                    \     unite#helper#get_current_candidate(positions[key].pos[1])
                            
                              if context.start_insert && !context.auto_quit
                                let unite.is_insert = 1
                            
                                call cursor(unite.prompt_linenr, 0)
                            
                                setlocal modifiable
                                startinsert!
                              else
                                let unite.is_insert = 0
                            
                                if is_restore
                                  " Restore position.
                                  call setpos('.', positions[key].pos)
                                else
                                  call cursor(unite#helper#get_current_candidate_linenr(0), 0)
                                endif
                            
                                normal! 0
                                stopinsert
                              endif
                            
                              if line('.') <= winheight(0)
                                normal! zb
                              endif
                            
                              if context.select != 0
                                " Select specified candidate.
                                call cursor(unite#helper#get_current_candidate_linenr(
                                      \ context.select), 0)
                              elseif context.input == '' && context.log
                                call unite#view#_redraw_candidates(1)
                              endif
                            
                              if context.no_focus
                                if winbufnr(winnr('#')) > 0
                                  wincmd p
                                else
                                  execute bufwinnr(unite.prev_bufnr).'wincmd w'
                                endif
                              endif
                            
                              if context.quick_match
                                call unite#mappings#_quick_match(0)
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_quit(is_force, ...)  "{{{
                              if &filetype !=# 'unite'
                                return
                              endif
                            
                              let is_all = get(a:000, 0, 0)
                            
                              " Save unite value.
                              let unite_save = unite#variables#current_unite()
                              call unite#set_current_unite(b:unite)
                              let unite = b:unite
                              let context = unite.context
                            
                              let key = unite#loaded_source_names_string()
                            
                              " Clear mark.
                              for source in unite#loaded_sources_list()
                                for candidate in source.unite__cached_candidates
                                  let candidate.unite__is_marked = 0
                                endfor
                              endfor
                            
                              " Save position.
                              let positions = unite#custom#get_profile(
                                    \ unite.profile_name, 'unite__save_pos')
                              if key != ''
                                let positions[key] = {
                                      \ 'pos' : getpos('.'),
                                      \ 'candidate' : unite#helper#get_current_candidate(),
                                      \ }
                            
                                if context.input != ''
                                  " Save input.
                                  let inputs = unite#custom#get_profile(
                                        \ unite.profile_name, 'unite__inputs')
                                  if !has_key(inputs, key)
                                    let inputs[key] = []
                                  endif
                                  call insert(filter(inputs[key],
                                        \ 'v:val !=# unite.context.input'), context.input)
                                endif
                              endif
                            
                              if a:is_force || !context.no_quit
                                let bufname = bufname('%')
                            
                                if winnr('$') == 1 || context.no_split
                                  call unite#util#alternate_buffer()
                                elseif is_all || !context.temporary
                                  close!
                                  if unite.winnr != winnr()
                                    execute unite.winnr . 'wincmd w'
                                  endif
                                  call unite#view#_resize_window()
                                endif
                            
                                call unite#handlers#_on_buf_unload(bufname)
                            
                                if !unite.has_preview_window
                                  let preview_windows = filter(range(1, winnr('$')),
                                        \ 'getwinvar(v:val, "&previewwindow") != 0')
                                  if !empty(preview_windows)
                                    " Close preview window.
                                    noautocmd pclose!
                            
                                  endif
                                endif
                            
                                call s:clear_previewed_buffer_list()
                            
                                if winnr('$') != 1 && !unite.context.temporary
                                  execute unite.win_rest_cmd
                                  execute unite.prev_winnr 'wincmd w'
                                endif
                              else
                                " Note: Except preview window.
                                let winnr = get(filter(range(1, winnr('$')),
                                      \ "winbufnr(v:val) == unite.prev_bufnr &&
                                      \  !getwinvar(v:val, '&previewwindow')"), 0, unite.prev_winnr)
                            
                                if winnr == winnr()
                                  new
                                else
                                  execute winnr 'wincmd w'
                                endif
                                let unite.prev_winnr = winnr()
                              endif
                            
                              if context.complete
                                if context.col < col('$')
                                  startinsert
                                else
                                  startinsert!
                                endif
                            
                                " Skip next auto completion.
                                if exists('*neocomplcache#skip_next_complete')
                                  call neocomplcache#skip_next_complete()
                                endif
                              else
                                redraw
                                stopinsert
                              endif
                            
                              " Restore unite.
                              call unite#set_current_unite(unite_save)
                            endfunction"}}}
                            
                            " Message output.
    1              0.000003 function! unite#view#_print_error(message) "{{{
                              let message = s:msg2list(a:message)
                              let unite = unite#get_current_unite()
                              if !empty(unite)
                                let unite.err_msgs += message
                              endif
                              for mes in message
                                echohl WarningMsg | echomsg mes | echohl None
                              endfor
                            endfunction"}}}
    1              0.000004 function! unite#view#_print_source_error(message, source_name) "{{{
                              call unite#view#_print_error(
                                    \ map(copy(s:msg2list(a:message)),
                                    \   "printf('[%s] %s', a:source_name, v:val)"))
                            endfunction"}}}
    1              0.000004 function! unite#view#_print_message(message) "{{{
                              let context = unite#get_context()
                              if get(context, 'silent', 0)
                                return
                              endif
                            
                              let unite = unite#get_current_unite()
                              let message = s:msg2list(a:message)
                              if !empty(unite)
                                let unite.msgs += message
                              endif
                              echohl Comment | call s:redraw_echo(message) | echohl None
                            endfunction"}}}
    1              0.000004 function! unite#view#_print_source_message(message, source_name) "{{{
                              call unite#view#_print_message(
                                    \ map(copy(s:msg2list(a:message)),
                                    \    "printf('[%s] %s', a:source_name, v:val)"))
                            endfunction"}}}
    1              0.000003 function! unite#view#_clear_message() "{{{
                              let unite = unite#get_current_unite()
                              let unite.msgs = []
                              redraw
                            endfunction"}}}
                            
    1              0.000004 function! unite#view#_get_status_string() "{{{
                              return !exists('b:unite') ? '' : ((b:unite.is_async ? '[async] ' : '') .
                                    \ join(unite#helper#loaded_source_names_with_args(), ', '))
                            endfunction"}}}
                            
    1              0.000003 function! unite#view#_add_previewed_buffer_list(bufnr) "{{{
                              let unite = unite#get_current_unite()
                              call add(unite.previewd_buffer_list, a:bufnr)
                            endfunction"}}}
    1              0.000003 function! unite#view#_remove_previewed_buffer_list(bufnr) "{{{
                              let unite = unite#get_current_unite()
                              call filter(unite.previewd_buffer_list, 'v:val != a:bufnr')
                            endfunction"}}}
                            
    1              0.000004 function! s:clear_previewed_buffer_list() "{{{
                              let unite = unite#get_current_unite()
                              for bufnr in unite.previewd_buffer_list
                                if buflisted(bufnr)
                                  silent execute 'bdelete!' bufnr
                                endif
                              endfor
                            
                              let unite.previewd_buffer_list = []
                            endfunction"}}}
                            
    1              0.000002 function! s:set_syntax() "{{{
                              let unite = unite#get_current_unite()
                              let source_padding = 3
                            
                              let abbr_head = unite.max_source_name+source_padding
                              silent! syntax clear uniteCandidateAbbr
                              execute 'syntax region uniteCandidateAbbr' 'start=/\%'
                                    \ .(abbr_head).'c/ end=/$/ keepend contained'
                            
                              " Set syntax.
                              for source in filter(copy(unite.sources), 'v:val.syntax != ""')
                                silent! execute 'syntax clear' source.syntax
                                execute 'syntax region' source.syntax
                                      \ 'start=// end=/$/ keepend contained'
                              endfor
                            endfunction"}}}
                            
    1              0.000002 function! s:has_preview_window() "{{{
                              return len(filter(range(1, winnr('$')),
                                    \    'getwinvar(v:val, "&previewwindow")')) > 0
                            endfunction"}}}
                            
    1              0.000002 function! s:msg2list(expr) "{{{
                              return type(a:expr) ==# type([]) ? a:expr : split(a:expr, '\n')
                            endfunction"}}}
                            
    1              0.000002 function! s:redraw_echo(expr) "{{{
                              if has('vim_starting')
                                echo join(s:msg2list(a:expr), "\n")
                                return
                              endif
                            
                              let msg = s:msg2list(a:expr)
                              let height = max([1, &cmdheight])
                              for i in range(0, len(msg)-1, height)
                                redraw
                                echo join(msg[i : i+height-1], "\n")
                              endfor
                            endfunction"}}}
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/vimproc.vim/autoload/vimproc/parser.vim
Sourced 1 time
Total time:   0.000818
 Self time:   0.000818

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: parser.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 21 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Saving 'cpoptions' {{{
    1              0.000011 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            " }}}
                            
                            " For vimshell parser.
    1              0.000006 function! vimproc#parser#parse_pipe(statement) "{{{
                              let commands = []
                              for cmdline in vimproc#parser#split_pipe(a:statement)
                                " Split args.
                                let cmdline = s:parse_cmdline(cmdline)
                            
                                " Parse redirection.
                                if cmdline =~ '[<>]'
                                  let [fd, cmdline] = s:parse_redirection(cmdline)
                                else
                                  let fd = { 'stdin' : '', 'stdout' : '', 'stderr' : '' }
                                endif
                            
                                for key in ['stdout', 'stderr']
                                  if fd[key] == '' || fd[key] =~ '^>'
                                    continue
                                  endif
                            
                                  if fd[key] ==# '/dev/clip'
                                    " Clear.
                                    let @+ = ''
                                  elseif fd[key] ==# '/dev/quickfix'
                                    " Clear quickfix.
                                    call setqflist([])
                                  endif
                                endfor
                            
                                call add(commands, {
                                      \ 'args' : vimproc#parser#split_args(cmdline),
                                      \ 'fd' : fd
                                      \})
                              endfor
                            
                              return commands
                            endfunction"}}}
    1              0.000003 function! s:parse_cmdline(cmdline) "{{{
                              let cmdline = a:cmdline
                            
                              " Expand block.
                              if cmdline =~ '{'
                                let cmdline = s:parse_block(cmdline)
                              endif
                            
                              " Expand tilde.
                              if cmdline =~ '\~'
                                let cmdline = s:parse_tilde(cmdline)
                              endif
                            
                              " Expand filename.
                              if cmdline =~ ' ='
                                let cmdline = s:parse_equal(cmdline)
                              endif
                            
                              " Expand variables.
                              if cmdline =~ '\$'
                                let cmdline = s:parse_variables(cmdline)
                              endif
                            
                              " Expand wildcard.
                              if cmdline =~ '[[*?]\|\\[()|]'
                                let cmdline = s:parse_wildcard(cmdline)
                              endif
                            
                              return s:parse_tilde(cmdline)
                            endfunction"}}}
    1              0.000004 function! vimproc#parser#parse_statements(script) "{{{
                              if type(a:script) == type('')  && a:script =~ '^\s*:'
                                return [ { 'statement' : a:script, 'condition' : 'always' } ]
                              endif
                            
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              let statements = []
                              let statement = ''
                              let i = 0
                              while i < max
                                if script[i] == ';'
                                  if statement != ''
                                    call add(statements,
                                          \ { 'statement' : statement,
                                          \   'condition' : 'always',
                                          \})
                                  endif
                                  let statement = ''
                                  let i += 1
                                elseif script[i] == '&'
                                  if i+1 < max && script[i+1] == '&'
                                    if statement != ''
                                      call add(statements,
                                            \ { 'statement' : statement,
                                            \   'condition' : 'true',
                                            \})
                                    endif
                                    let statement = ''
                                    let i += 2
                                  else
                                    let statement .= script[i]
                            
                                    let i += 1
                                  endif
                                elseif script[i] == '|'
                                  if i+1 < max && script[i+1] == '|'
                                    if statement != ''
                                      call add(statements,
                                            \ { 'statement' : statement,
                                            \   'condition' : 'false',
                                            \})
                                    endif
                                    let statement = ''
                                    let i += 2
                                  else
                                    let statement .= script[i]
                            
                                    let i += 1
                                  endif
                                elseif script[i] == "'"
                                  " Single quote.
                                  let [string, i] = s:skip_single_quote(script, i)
                                  let statement .= string
                                elseif script[i] == '"'
                                  " Double quote.
                                  let [string, i] = s:skip_double_quote(script, i)
                                  let statement .= string
                                elseif script[i] == '`'
                                  " Back quote.
                                  let [string, i] = s:skip_back_quote(script, i)
                                  let statement .= string
                                elseif script[i] == '\'
                                  " Escape.
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  let statement .= '\' . script[i]
                                  let i += 1
                                elseif script[i] == '#'
                                  " Comment.
                                  break
                                else
                                  let statement .= script[i]
                                  let i += 1
                                endif
                              endwhile
                            
                              if statement !~ '^\s*$'
                                call add(statements,
                                      \ { 'statement' : statement,
                                      \   'condition' : 'always',
                                      \})
                              endif
                            
                              return statements
                            endfunction"}}}
                            
    1              0.000004 function! vimproc#parser#split_statements(script) "{{{
                              return map(vimproc#parser#parse_statements(a:script),
                                    \ 'v:val.statement')
                            endfunction"}}}
    1              0.000003 function! vimproc#parser#split_args(script) "{{{
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              let args = []
                              let arg = ''
                              let i = 0
                              while i < max
                                if script[i] == "'"
                                  " Single quote.
                                  let [arg_quote, i] = s:parse_single_quote(script, i)
                                  let arg .= arg_quote
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '"'
                                  " Double quote.
                                  let [arg_quote, i] = s:parse_double_quote(script, i)
                                  let arg .= arg_quote
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '`'
                                  " Back quote.
                                  let head = i > 0 ? script[: i-1] : []
                                  let [arg_quote, i] = s:parse_back_quote(script, i)
                            
                                  " Re-parse script.
                                  return vimproc#parser#split_args(
                                        \ head + split(arg_quote, '\zs') + script[i :])
                                elseif script[i] == '\'
                                  " Escape.
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  let arg .= script[i]
                                  let i += 1
                                elseif script[i] == '#'
                                  " Comment.
                                  break
                                elseif script[i] != ' '
                                  let arg .= script[i]
                                  let i += 1
                                else
                                  " Space.
                                  if arg != ''
                                    call add(args, arg)
                                  endif
                            
                                  let arg = ''
                            
                                  let i += 1
                                endif
                              endwhile
                            
                              if arg != ''
                                call add(args, arg)
                              endif
                            
                              return args
                            endfunction"}}}
    1              0.000004 function! vimproc#parser#split_args_through(script) "{{{
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              let args = []
                              let arg = ''
                              let i = 0
                              while i < max
                                if script[i] == "'"
                                  " Single quote.
                                  let [string, i] = s:skip_single_quote(script, i)
                                  let arg .= string
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '"'
                                  " Double quote.
                                  let [string, i] = s:skip_double_quote(script, i)
                                  let arg .= string
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '`'
                                  " Back quote.
                                  let [string, i] = s:skip_back_quote(script, i)
                                  let arg .= string
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '\'
                                  " Escape.
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  let arg .= '\'.script[i]
                                  let i += 1
                                elseif script[i] != ' '
                                  let arg .= script[i]
                                  let i += 1
                                else
                                  " Space.
                                  if arg != ''
                                    call add(args, arg)
                                  endif
                            
                                  let arg = ''
                            
                                  let i += 1
                                endif
                              endwhile
                            
                              if arg != ''
                                call add(args, arg)
                              endif
                            
                              return args
                            endfunction"}}}
    1              0.000004 function! vimproc#parser#split_pipe(script) "{{{
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              let command = ''
                            
                              let i = 0
                              let commands = []
                              while i < max
                                if script[i] == '|'
                                  " Pipe.
                                  call add(commands, command)
                            
                                  " Search next command.
                                  let command = ''
                                  let i += 1
                                elseif script[i] == "'"
                                  " Single quote.
                                  let [string, i] = s:skip_single_quote(script, i)
                                  let command .= string
                                elseif script[i] == '"'
                                  " Double quote.
                                  let [string, i] = s:skip_double_quote(script, i)
                                  let command .= string
                                elseif script[i] == '`'
                                  " Back quote.
                                  let [string, i] = s:skip_back_quote(script, i)
                                  let command .= string
                                elseif script[i] == '\' && i + 1 < max
                                  " Escape.
                                  let command .= '\' . script[i+1]
                                  let i += 2
                                else
                                  let command .= script[i]
                                  let i += 1
                                endif
                              endwhile
                            
                              call add(commands, command)
                            
                              return commands
                            endfunction"}}}
    1              0.000004 function! vimproc#parser#split_commands(script) "{{{
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              let commands = []
                              let command = ''
                              let i = 0
                              while i < max
                                if script[i] == '\'
                                  " Escape.
                                  let command .= script[i]
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  let command .= script[i]
                                  let i += 1
                                elseif script[i] == '|'
                                  if command != ''
                                    call add(commands, command)
                                  endif
                                  let command = ''
                            
                                  let i += 1
                                else
                            
                                  let command .= script[i]
                                  let i += 1
                                endif
                              endwhile
                            
                              if command != ''
                                call add(commands, command)
                              endif
                            
                              return commands
                            endfunction"}}}
    1              0.000003 function! vimproc#parser#expand_wildcard(wildcard) "{{{
                              " Check wildcard.
                              let i = 0
                              let max = len(a:wildcard)
                              let script = ''
                              let found = 0
                              while i < max
                                if a:wildcard[i] == '*' || a:wildcard[i] == '?' || a:wildcard[i] == '['
                                  let found = 1
                                  break
                                else
                                  let [script, i] = s:skip_else(script, a:wildcard, i)
                                endif
                              endwhile
                            
                              if !found
                                return [ a:wildcard ]
                              endif
                            
                              let wildcard = a:wildcard
                            
                              " Exclude wildcard.
                              let exclude = matchstr(wildcard, '\\\@<!\~\zs.\+$')
                              let exclude_wilde = []
                              if exclude != ''
                                " Truncate wildcard.
                                let wildcard = wildcard[: len(wildcard)-len(exclude)-2]
                                let exclude_wilde = vimproc#parser#expand_wildcard(exclude)
                              endif
                            
                              " Modifier.
                              let modifier = matchstr(wildcard, '\\\@<!(\zs.\+\ze)$')
                              if modifier != ''
                                " Truncate wildcard.
                                let wildcard = wildcard[: len(wildcard)-len(modifier)-3]
                              endif
                            
                              " Expand wildcard.
                              let expanded = split(escape(substitute(
                                    \ glob(wildcard, 1), '\\', '/', 'g'), ' '), '\n')
                              if empty(expanded)
                                " Use original string.
                                return [ a:wildcard ]
                              else
                                " Check exclude wildcard.
                                let candidates = expanded
                                let expanded = []
                                for candidate in candidates
                                  let found = 0
                            
                                  for ex in exclude_wilde
                                    if candidate ==# ex
                                      let found = 1
                                      break
                                    endif
                                  endfor
                            
                                  if !found
                                    call add(expanded, candidate)
                                  endif
                                endfor
                              endif
                            
                              if modifier != ''
                                " Check file modifier.
                                let i = 0
                                let max = len(modifier)
                                while i < max
                                  if modifier[i] ==# '/'
                                    " Directory.
                                    let expr = 'getftype(v:val) ==# "dir"'
                                  elseif modifier[i] ==# '.'
                                    " Normal.
                                    let expr = 'getftype(v:val) ==# "file"'
                                  elseif modifier[i] ==# '@'
                                    " Link.
                                    let expr = 'getftype(v:val) ==# "link"'
                                  elseif modifier[i] ==# '='
                                    " Socket.
                                    let expr = 'getftype(v:val) ==# "socket"'
                                  elseif modifier[i] ==# 'p'
                                    " FIFO Pipe.
                                    let expr = 'getftype(v:val) ==# "pipe"'
                                  elseif modifier[i] ==# '*'
                                    " Executable.
                                    let expr = 'getftype(v:val) ==# "pipe"'
                                  elseif modifier[i] ==# '%'
                                    " Device.
                            
                                    if modifier[i :] =~# '^%[bc]'
                                      if modifier[i] ==# 'b'
                                        " Block device.
                                        let expr = 'getftype(v:val) ==# "bdev"'
                                      else
                                        " Character device.
                                        let expr = 'getftype(v:val) ==# "cdev"'
                                      endif
                            
                                      let i += 1
                                    else
                                      let expr = 'getftype(v:val) ==# "bdev" || getftype(v:val) ==# "cdev"'
                                    endif
                                  else
                                    " Unknown.
                                    return []
                                  endif
                            
                                  call filter(expanded, expr)
                                  let i += 1
                                endwhile
                              endif
                            
                              return filter(expanded, 'v:val != "." && v:val != ".."')
                            endfunction"}}}
                            
                            " Parse helper.
    1              0.000003 function! s:parse_block(script) "{{{
                              let script = ''
                            
                              let i = 0
                              let max = len(a:script)
                              while i < max
                                if a:script[i] == '{'
                                  " Block.
                                  let head = matchstr(a:script[: i-1], '[^[:blank:]]*$')
                                  " Truncate script.
                                  let script = script[: -len(head)-1]
                                  let block = matchstr(a:script, '{\zs.*[^\\]\ze}', i)
                                  let foot = join(vimproc#parser#split_args(s:parse_cmdline(
                                        \ a:script[matchend(a:script, '{.*[^\\]}', i) :])))
                                  if block == ''
                                    throw 'Exception: Block is not found.'
                                  elseif block =~ '^\d\+\.\.\d\+$'
                                    " Range block.
                                    let start = matchstr(block, '^\d\+')
                                    let end = matchstr(block, '\d\+$')
                                    let zero = len(matchstr(block, '^0\+'))+1
                                    let pattern = '%0' . zero . 'd'
                                    for b in range(start, end)
                                      " Concat.
                                      let script .= head . printf(pattern, b) . foot . ' '
                                    endfor
                                  else
                                    " Normal block.
                                    for b in split(block, ',', 1)
                                      " Concat.
                                      let script .= head . escape(b, ' ') . foot . ' '
                                    endfor
                                  endif
                                  return script
                                else
                                  let [script, i] = s:skip_else(script, a:script, i)
                                endif
                              endwhile
                            
                              return script
                            endfunction"}}}
    1              0.000002 function! s:parse_tilde(script) "{{{
                              let script = ''
                            
                              let i = 0
                              let max = len(a:script)
                              while i < max
                                if a:script[i] == ' ' && a:script[i+1] == '~'
                                  " Tilde.
                                  " Expand home directory.
                                  let script .= ' ' . escape(substitute($HOME, '\\', '/', 'g'), '\ ')
                                  let i += 2
                            
                                elseif i == 0 && a:script[i] == '~'
                                  " Tilde.
                                  " Expand home directory.
                                  let script .= escape(substitute($HOME, '\\', '/', 'g'), '\ ')
                                  let i += 1
                                else
                                  let [script, i] = s:skip_else(script, a:script, i)
                                endif
                              endwhile
                            
                              return script
                            endfunction"}}}
    1              0.000003 function! s:parse_equal(script) "{{{
                              let script = ''
                            
                              let i = 0
                              let max = len(a:script)
                              while i < max
                                if a:script[i] == ' ' && a:script[i+1] == '='
                                  " Expand filename.
                                  let prog = matchstr(a:script, '^=\zs[^[:blank:]]*', i+1)
                                  if prog == ''
                                    let [script, i] = s:skip_else(script, a:script, i)
                                  else
                                    let filename = vimproc#get_command_name(prog)
                                    if filename == ''
                                      throw printf('Error: File "%s" is not found.', prog)
                                    else
                                      let script .= filename
                                    endif
                            
                                    " Consume `a:script` until an end of `prog`.
                                    " 
                                    " e.g.
                                    "   'echo  =ls hoge'  ->  'echo  =ls hoge'
                                    "         ^                         ^
                                    let i += strlen(a:script[i] . a:script[i+1] . prog)
                                  endif
                                else
                                  let [script, i] = s:skip_else(script, a:script, i)
                                endif
                              endwhile
                            
                              return script
                            endfunction"}}}
    1              0.000002 function! s:parse_variables(script) "{{{
                              let script = ''
                            
                              let i = 0
                              let max = len(a:script)
                              try
                                while i < max
                                  if a:script[i] == '$' && a:script[i :] =~ '^$$\?\h'
                                    " Eval variables.
                                    let variable_name = matchstr(a:script, '^$$\?\zs\h\w*', i)
                                    if exists('b:vimshell')
                                      " For vimshell.
                                      let script_head = a:script[i :]
                                      if script_head =~ '^$\l' &&
                                            \ has_key(b:vimshell.variables, variable_name)
                                        let script .= b:vimshell.variables[variable_name]
                                      elseif script_head =~ '^\$\$' &&
                                            \ has_key(b:vimshell.system_variables, variable_name)
                                        let script .= b:vimshell.system_variables[variable_name]
                                      elseif script_head =~ '^$\h'
                                        let script .= vimproc#util#substitute_path_separator(
                                              \ eval('$' . variable_name))
                                      endif
                                    else
                                      let script .= vimproc#util#substitute_path_separator(
                                            \ eval(matchstr(a:script, '^$\h\w*', i)))
                                    endif
                            
                                    let i = matchend(a:script, '^$$\?\h\w*', i)
                                  else
                                    let [script, i] = s:skip_else(script, a:script, i)
                                  endif
                                endwhile
                              catch /^Vim\%((\a\+)\)\=:E15/
                                " Parse error.
                                return a:script
                              endtry
                            
                              return script
                            endfunction"}}}
    1              0.000003 function! s:parse_wildcard(script) "{{{
                              let script = ''
                              for arg in vimproc#parser#split_args_through(a:script)
                                let script .= join(vimproc#parser#expand_wildcard(arg)) . ' '
                              endfor
                            
                              return script
                            endfunction"}}}
    1              0.000003 function! s:parse_redirection(script) "{{{
                              let script = ''
                              let fd = { 'stdin' : '', 'stdout' : '', 'stderr' : '' }
                            
                              let i = 0
                              let max = len(a:script)
                              while i < max
                                if a:script[i] == '<'
                                  " Input redirection.
                                  let fd.stdin = matchstr(a:script, '<\s*\zs\f*', i)
                                  let i = matchend(a:script, '<\s*\zs\f*', i)
                                elseif a:script[i] =~ '^[12]' && a:script[i :] =~ '^[12]>' 
                                  " Output redirection.
                                  let i += 2
                                  if a:script[i-2] == 1
                                    let fd.stdout = matchstr(a:script, '^\s*\zs\f*', i)
                                  else
                                    let fd.stderr = matchstr(a:script, '^\s*\zs\(\f\+\|&\d\+\)', i)
                                    if fd.stderr ==# '&1'
                                      " Redirection to stdout.
                                      let fd.stderr = '/dev/stdout'
                                    endif
                                  endif
                            
                                  let i = matchend(a:script, '^\s*\zs\(\f\+\|&\d\+\)', i)
                                elseif a:script[i] == '>'
                                  " Output redirection.
                                  if a:script[i :] =~ '^>&'
                                    " Output stderr.
                                    let i += 2
                                    let fd.stderr = matchstr(a:script, '^\s*\zs\f*', i)
                                  elseif a:script[i :] =~ '^>>'
                                    " Append stdout.
                                    let i += 2
                                    let fd.stdout = '>' . matchstr(a:script, '^\s*\zs\f*', i)
                                  else
                                    " Output stdout.
                                    let i += 1
                                    let fd.stdout = matchstr(a:script, '^\s*\zs\f*', i)
                                  endif
                            
                                  let i = matchend(a:script, '^\s*\zs\f*', i)
                                else
                                  let [script, i] = s:skip_else(script, a:script, i)
                                endif
                              endwhile
                            
                              return [fd, script]
                            endfunction"}}}
                            
    1              0.000003 function! s:parse_single_quote(script, i) "{{{
                              if a:script[a:i] != "'"
                                return ['', a:i]
                              endif
                            
                              let arg = ''
                              let i = a:i + 1
                              let max = len(a:script)
                              while i < max
                                if a:script[i] == "'"
                                  if i+1 < max && a:script[i+1] == "'"
                                    " Escape quote.
                                    let arg .= "'"
                                    let i += 2
                                  else
                                    " Quote end.
                                    return [arg, i+1]
                                  endif
                                else
                                  let arg .= a:script[i]
                                  let i += 1
                                endif
                              endwhile
                            
                              throw 'Exception: Quote ('') is not found.'
                            endfunction"}}}
    1              0.000003 function! s:parse_double_quote(script, i) "{{{
                              if a:script[a:i] != '"'
                                return ['', a:i]
                              endif
                            
                              let escape_sequences = {
                                    \ 'a' : "\<C-g>", 'b' : "\<BS>",
                                    \ 't' : "\<Tab>", 'r' : "\<CR>",
                                    \ 'n' : "\<LF>",  'e' : "\<Esc>",
                                    \ '\' : '\',  '?' : '?',
                                    \ '"' : '"',  "'" : "'",
                                    \ '`' : '`',  '$' : '$',
                                    \}
                              let arg = ''
                              let i = a:i + 1
                              let script = type(a:script) == type([]) ?
                                    \ a:script : split(a:script, '\zs')
                              let max = len(script)
                              while i < max
                                if script[i] == '"'
                                  " Quote end.
                                  return [arg, i+1]
                                elseif script[i] == '$'
                                  " Eval variables.
                                  let var = matchstr(join(script[i :], ''), '^$\h\w*')
                                  if var != ''
                                    let arg .= s:parse_variables(var)
                                    let i += len(var)
                                  else
                                    let arg .= '$'
                                    let i += 1
                                  endif
                                elseif script[i] == '`'
                                  " Backquote.
                                  let [arg_quote, i] = s:parse_back_quote(script, i)
                                  let arg .= arg_quote
                                elseif script[i] == '\'
                                  " Escape.
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  if script[i] == 'x'
                                    let num = matchstr(join(script[i+1 :], ''), '^\x\+')
                                    let arg .= nr2char(str2nr(num, 16))
                                    let i += len(num)
                                  elseif has_key(escape_sequences, script[i])
                                    let arg .= escape_sequences[script[i]]
                                  else
                                    let arg .= '\' . script[i]
                                  endif
                                  let i += 1
                                else
                                  let arg .= script[i]
                                  let i += 1
                                endif
                              endwhile
                            
                              throw 'Exception: Quote (") is not found.'
                            endfunction"}}}
    1              0.000003 function! s:parse_back_quote(script, i) "{{{
                              if a:script[a:i] != '`'
                                return ['', a:i]
                              endif
                            
                              let arg = ''
                              let max = len(a:script)
                              if a:i + 1 < max && a:script[a:i + 1] == '='
                                " Vim eval quote.
                                let i = a:i + 2
                            
                                while i < max
                                  if a:script[i] == '\'
                                    " Escape.
                                    let i += 1
                            
                                    if i >= max
                                      throw 'Exception: Join to next line (\).'
                                    endif
                            
                                    let arg .= '\' . a:script[i]
                                    let i += 1
                                  elseif a:script[i] == '`'
                                      " Quote end.
                                      return [eval(arg), i+1]
                                  else
                                    let arg .= a:script[i]
                                    let i += 1
                                  endif
                                endwhile
                              else
                                " Eval quote.
                                let i = a:i + 1
                            
                                while i < max
                                  if a:script[i] == '`'
                                    " Quote end.
                                    return [substitute(vimproc#system(arg), '\n$', '', ''), i+1]
                                  else
                                    let arg .= a:script[i]
                                    let i += 1
                                  endif
                                endwhile
                              endif
                            
                              throw 'Exception: Quote (`) is not found.'
                            endfunction"}}}
                            
                            " Skip helper.
    1              0.000002 function! s:skip_single_quote(script, i) "{{{
                              let max = len(a:script)
                              let string = ''
                              let i = a:i
                            
                              " a:script[i] is always "'" when this function is called
                              if i >= max || a:script[i] != ''''
                                throw 'Exception: Quote ('') is not found.'
                              endif
                              let string .= a:script[i]
                              let i += 1
                            
                              while i < max
                                if a:script[i] == ''''
                                  if i+1 < max && a:script[i+1] == ''''
                                    " Escape quote.
                                    let string .= a:script[i]
                                    let i += 1
                                  else
                                    break
                                  endif
                                endif
                            
                                let string .= a:script[i]
                                let i += 1
                              endwhile
                            
                              if i < max
                                " must end with "'"
                                if a:script[i] != ''''
                                  throw 'Exception: Quote ('') is not found.'
                                endif
                                let string .= a:script[i]
                                let i += 1
                              endif
                            
                              return [string, i]
                            endfunction"}}}
    1              0.000003 function! s:skip_double_quote(script, i) "{{{
                              let max = len(a:script)
                              let string = ''
                              let i = a:i
                            
                              " a:script[i] is always '"' when this function is called
                              if i >= max || a:script[i] != '"'
                                throw 'Exception: Quote (") is not found.'
                              endif
                              let string .= a:script[i]
                              let i += 1
                            
                              while i < max
                                if a:script[i] == '\'
                                      \ && i+1 < max && a:script[i+1] == '"'
                                  " Escape quote.
                                  let string .= a:script[i]
                                  let i += 1
                            
                                elseif a:script[i] == '"'
                                  break
                                endif
                            
                                let string .= a:script[i]
                                let i += 1
                              endwhile
                            
                              if i < max
                                " must end with '"'
                                if a:script[i] != '"'
                                  throw 'Exception: Quote (") is not found.'
                                endif
                                let string .= a:script[i]
                                let i += 1
                              endif
                            
                              return [string, i]
                            endfunction"}}}
    1              0.000003 function! s:skip_back_quote(script, i) "{{{
                              let max = len(a:script)
                              let string = ''
                              let i = a:i
                            
                              " a:script[i] is always '`' when this function is called
                              if a:script[i] != '`'
                                throw 'Exception: Quote (`) is not found.'
                              endif
                              let string .= a:script[i]
                              let i += 1
                            
                              while i < max && a:script[i] != '`'
                                let string .= a:script[i]
                                let i += 1
                              endwhile
                            
                              if i < max
                                " must end with "`"
                                if a:script[i] != '`'
                                  throw 'Exception: Quote (`) is not found.'
                                endif
                                let string .= a:script[i]
                                let i += 1
                              endif
                            
                              return [string, i]
                            endfunction"}}}
    1              0.000003 function! s:skip_else(args, script, i) "{{{
                              if a:script[a:i] == "'"
                                " Single quote.
                                let [string, i] = s:skip_single_quote(a:script, a:i)
                                let script = a:args . string
                              elseif a:script[a:i] == '"'
                                " Double quote.
                                let [string, i] = s:skip_double_quote(a:script, a:i)
                                let script = a:args . string
                              elseif a:script[a:i] == '`'
                                " Back quote.
                                let [string, i] = s:skip_back_quote(a:script, a:i)
                                let script = a:args . string
                              elseif a:script[a:i] == '\'
                                " Escape.
                                let script = a:args . '\' . a:script[a:i+1]
                                let i = a:i + 2
                              else
                                let script = a:args . a:script[a:i]
                                let i = a:i + 1
                              endif
                            
                              return [script, i]
                            endfunction"}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000012 let &cpo = s:save_cpo
                            " }}}
                            " vim:foldmethod=marker:fen:sw=2:sts=2

SCRIPT  /home/skl/.vim/bundle/vimproc.vim/autoload/vimproc/filepath.vim
Sourced 1 time
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
                            " This file from vital.vim.
                            " https://github.com/vim-jp/vital.vim
                            
                            " You should check the following related builtin functions.
                            " fnamemodify()
                            " resolve()
                            " simplify()
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000007 let s:path_sep_pattern = (exists('+shellslash') ? '[\\/]' : '/') . '\+'
    1              0.000009 let s:is_windows = has('win16') || has('win32') || has('win64')
    1              0.000005 let s:is_cygwin = has('win32unix')
    1              0.000053 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!executable('xdg-open') && system('uname') =~? '^darwin'))
                            
                            " Get the directory separator.
    1              0.000004 function! s:separator()
                              return !exists('+shellslash') || &shellslash ? '/' : '\'
                            endfunction
                            
                            " Get the path separator.
    1              0.000004 let s:path_separator = s:is_windows ? ';' : ':'
    1              0.000003 function! s:path_separator()
                              return s:path_separator
                            endfunction
                            
                            " Get the path extensions
    1              0.000002 function! s:path_extensions()
                              if !exists('s:path_extensions')
                                if s:is_windows
                                  if exists('$PATHEXT')
                                    let pathext = $PATHEXT
                                  else
                                    " get default PATHEXT
                                    let pathext = matchstr(system('set pathext'), '^pathext=\zs.*\ze\n', 'i')
                                  endif
                                  let s:path_extensions = map(split(pathext, s:path_separator), 'tolower(v:val)')
                                elseif s:is_cygwin
                                  " cygwin is not use $PATHEXT
                                  let s:path_extensions = ['', '.exe']
                                else
                                  let s:path_extensions = ['']
                                endif
                              endif
                              return s:path_extensions
                            endfunction
                            
                            " Convert all directory separators to "/".
    1              0.000003 function! s:unify_separator(path)
                              return substitute(a:path, s:path_sep_pattern, '/', 'g')
                            endfunction
                            
                            " Get the full path of command.
    1              0.000002 function! s:which(command, ...)
                              let pathlist = a:command =~# s:path_sep_pattern ? [''] :
                              \              !a:0                  ? split($PATH, s:path_separator) :
                              \              type(a:1) == type([]) ? copy(a:1) :
                              \                                      split(a:1, s:path_separator)
                              let pathlist = vimproc#util#uniq(pathlist)
                            
                              let pathext = s:path_extensions()
                              if index(pathext, '.' . tolower(fnamemodify(a:command, ':e'))) != -1
                                let pathext = ['']
                              endif
                            
                              let dirsep = s:separator()
                              for dir in pathlist
                                let head = dir ==# '' ? '' : dir . dirsep
                                for ext in pathext
                                  let full = fnamemodify(head . a:command . ext, ':p')
                                  if getftype(full) ==# 'link' && s:is_windows
                                    let full = resolve(full)
                                  endif
                            
                                  if executable(full)
                                    if s:is_case_tolerant()
                                      let full = glob(substitute(
                                      \               vimproc#util#substitute_path_separator(
                                      \ toupper(full)), '\u:\@!', '[\0\L\0]', 'g'), 1)
                                    endif
                                    if full != ''
                                      return full
                                    endif
                                  endif
                                endfor
                              endfor
                            
                              return ''
                            endfunction
                            
                            " Split the path with directory separator.
                            " Note that this includes the drive letter of MS Windows.
    1              0.000003 function! s:split(path)
                              return split(a:path, s:path_sep_pattern)
                            endfunction
                            
                            " Join the paths.
                            " join('foo', 'bar')            => 'foo/bar'
                            " join('foo/', 'bar')           => 'foo/bar'
                            " join('/foo/', ['bar', 'buz/']) => '/foo/bar/buz/'
    1              0.000002 function! s:join(...)
                              let sep = s:separator()
                              let path = ''
                              for part in a:000
                                let path .= sep .
                                \ (type(part) is type([]) ? call('s:join', part) :
                                \                           part)
                                unlet part
                              endfor
                              return substitute(path[1 :], s:path_sep_pattern, sep, 'g')
                            endfunction
                            
                            " Check if the path is absolute path.
    1              0.000002 if s:is_windows
                              function! s:is_absolute(path)
                                return a:path =~? '^[a-z]:[/\]'
                              endfunction
                            else
    1              0.000002   function! s:is_absolute(path)
                                return a:path[0] ==# '/'
                              endfunction
    1              0.000001 endif
                            
                            " Return the parent directory of the path.
                            " NOTE: fnamemodify(path, ':h') does not return the parent directory
                            " when path[-1] is the separator.
    1              0.000003 function! s:dirname(path)
                              let path = a:path
                              let orig = a:path
                            
                              let path = s:remove_last_separator(path)
                              if path == ''
                                return orig    " root directory
                              endif
                            
                              let path = fnamemodify(path, ':h')
                              return path
                            endfunction
                            
                            " Remove the separator at the end of a:path.
    1              0.000003 function! s:remove_last_separator(path)
                              let sep = s:separator()
                              let pat = (sep == '\' ? '\\' : '/') . '\+$'
                              return substitute(a:path, pat, '', '')
                            endfunction
                            
                            
                            " Return true if filesystem ignores alphabetic case of a filename.
                            " Return false otherwise.
    1              0.000015 let s:is_case_tolerant = filereadable(expand('<sfile>:r') . '.VIM')
    1              0.000003 function! s:is_case_tolerant()
                              return s:is_case_tolerant
                            endfunction
                            
    1              0.000006 function! vimproc#filepath#which(command, path)
                              return s:which(a:command, a:path)
                            endfunction
                            
    1              0.000009 let &cpo = s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/filters/matcher_regexp.vim
Sourced 1 time
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: matcher_regexp.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 29 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000007 function! unite#filters#matcher_regexp#define() "{{{
                              return s:matcher
                            endfunction"}}}
                            
    1              0.000008 let s:matcher = {
                                  \ 'name' : 'matcher_regexp',
                                  \ 'description' : 'regular expression matcher',
                                  \}
                            
    1              0.000003 function! s:matcher.filter(candidates, context) "{{{
                              if a:context.input == ''
                                return unite#filters#filter_matcher(
                                      \ a:candidates, '', a:context)
                              endif
                            
                              let candidates = a:candidates
                              for input in a:context.input_list
                                let a:context.input = input
                                let candidates = unite#filters#matcher_regexp#regexp_matcher(
                                      \ candidates, input, a:context)
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000006 function! unite#filters#matcher_regexp#regexp_matcher(candidates, input, context) "{{{
                              let expr = unite#filters#matcher_regexp#get_expr(a:input, a:context)
                            
                              try
                                return unite#filters#filter_matcher(a:candidates, expr, a:context)
                              catch
                                return []
                              endtry
                            endfunction"}}}
    1              0.000005 function! unite#filters#matcher_regexp#get_expr(input, context) "{{{
                              let input = a:input
                            
                              if input =~ '^!'
                                if input == '!'
                                  return '1'
                                endif
                            
                                " Exclusion match.
                                let expr = 'v:val.word !~ '.string(input[1:])
                              elseif input =~ '^:'
                                " Executes command.
                                let a:context.execute_command = input[1:]
                                return '1'
                              elseif input !~ '[~\\.^$\[\]*]'
                                if unite#util#has_lua()
                                  let expr = 'if_lua'
                                else
                                  " Optimized filter.
                                  let input = substitute(input, '\\\(.\)', '\1', 'g')
                                  let expr = &ignorecase ?
                                        \ printf('stridx(tolower(v:val.word), %s) != -1',
                                        \    string(tolower(input))) :
                                        \ printf('stridx(v:val.word, %s) != -1',
                                        \    string(input))
                                endif
                              else
                                let expr = 'v:val.word =~ '.string(input)
                              endif
                            
                              return expr
                            endfunction"}}}
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/filters/converter_default.vim
Sourced 1 time
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: converter_default.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 Oct 2012.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000006 function! unite#filters#converter_default#define() "{{{
                              return s:converter
                            endfunction"}}}
                            
    1              0.000008 let s:converter = {
                                  \ 'name' : 'converter_default',
                                  \ 'description' : 'default converter',
                                  \}
                            
    1              0.000004 function! s:converter.filter(candidates, context) "{{{
                              let candidates = a:candidates
                              for default in s:default_converters
                                let filter = unite#get_filters(default)
                                if !empty(filter)
                                  let candidates = filter.filter(candidates, a:context)
                                endif
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
                            
    1              0.000004 let s:default_converters = ['converter_nothing']
    1              0.000004 function! unite#filters#converter_default#get() "{{{
                              return s:default_converters
                            endfunction"}}}
    1              0.000005 function! unite#filters#converter_default#use(converters) "{{{
                              let s:default_converters = type(a:converters) == type([]) ?
                                    \ a:converters : [a:converters]
                            endfunction"}}}
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/filters.vim
Sourced 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: filters.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 29 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " filter() for matchers.
    1              0.000006 function! unite#filters#filter_matcher(list, expr, context) "{{{
                              if a:context.unite__max_candidates <= 0 ||
                                    \ !a:context.unite__is_interactive ||
                                    \ len(a:context.input_list) > 1
                            
                                return a:expr == '' ? a:list :
                                      \ (a:expr ==# 'if_lua') ?
                                      \   unite#filters#lua_matcher(
                                      \      a:list, a:context, &ignorecase) :
                                      \ (a:expr ==# 'if_lua_fuzzy') ?
                                      \   unite#filters#lua_fuzzy_matcher(
                                      \      a:list, a:context, &ignorecase) :
                                      \ filter(a:list, a:expr)
                              endif
                            
                              if a:expr == ''
                                return a:list[: a:context.unite__max_candidates - 1]
                              endif
                            
                              let _ = []
                              let len = 0
                            
                              let max = a:context.unite__max_candidates
                              let offset = max*4
                              for cnt in range(0, len(a:list) / offset)
                                let list = a:list[cnt*offset : cnt*offset + offset]
                                let list =
                                      \ (a:expr ==# 'if_lua') ?
                                      \   unite#filters#lua_matcher(list, a:context, &ignorecase) :
                                      \ (a:expr ==# 'if_lua_fuzzy') ?
                                      \   unite#filters#lua_fuzzy_matcher(list, a:context, &ignorecase) :
                                      \ filter(list, a:expr)
                                let len += len(list)
                                let _ += list
                            
                                if len >= max
                                  break
                                endif
                              endfor
                            
                              return _[: max]
                            endfunction"}}}
    1              0.000005 function! unite#filters#lua_matcher(candidates, context, ignorecase) "{{{
                              if !has('lua')
                                return []
                              endif
                            
                              let input = substitute(a:context.input, '\\ ', ' ', 'g')
                              let input = substitute(input, '\\\(.\)', '\1', 'g')
                              if a:ignorecase
                                let input = tolower(input)
                              endif
                            
                              lua << EOF
                            do
                              local input = vim.eval('input')
                              local candidates = vim.eval('a:candidates')
                              if (vim.eval('a:ignorecase') ~= 0) then
                                for i = #candidates-1, 0, -1 do
                                  if (string.find(string.lower(candidates[i].word), input, 1, true) == nil) then
                                    candidates[i] = nil
                                  end
                                end
                              else
                                for i = #candidates-1, 0, -1 do
                                  if (string.find(candidates[i].word, input, 1, true) == nil) then
                                    candidates[i] = nil
                                  end
                                end
                              end
                            end
                            EOF
                            
                              return a:candidates
                            endfunction"}}}
    1              0.000004 function! unite#filters#lua_fuzzy_matcher(candidates, context, ignorecase) "{{{
                              if !has('lua')
                                return []
                              endif
                            
                              let pattern = unite#filters#fuzzy_escape(a:context.input)
                            
                              lua << EOF
                            do
                              local pattern = vim.eval('pattern')
                              local input = vim.eval('a:context.input')
                              local candidates = vim.eval('a:candidates')
                              if vim.eval('&ignorecase') ~= 0 then
                                pattern = string.lower(pattern)
                                input = string.lower(input)
                                for i = #candidates-1, 0, -1 do
                                  local word = string.lower(candidates[i].word)
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              else
                                for i = #candidates-1, 0, -1 do
                                  local word = candidates[i].word
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              end
                            end
                            EOF
                            
                              return a:candidates
                            endfunction"}}}
                            
    1              0.000004 function! unite#filters#fuzzy_escape(string) "{{{
                              " Escape string for lua regexp.
                              return substitute(unite#filters#escape(a:string),
                                    \ '[[:alnum:]._/-]', '\0.*', 'g')
                            endfunction"}}}
                            
    1              0.000004 function! unite#filters#escape(string) "{{{
                              " Escape string for lua regexp.
                              return substitute(a:string,
                                    \ '[%\[\]().*+?^$-]', '%\0', 'g')
                            endfunction"}}}
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/filters/sorter_rank.vim
Sourced 1 time
Total time:   0.000346
 Self time:   0.000346

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: sorter_rank.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 08 Aug 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000036 let s:save_cpo = &cpo
    1              0.000017 set cpo&vim
                            
    1              0.000011 function! unite#filters#sorter_rank#define() "{{{
                              return s:sorter
                            endfunction"}}}
                            
    1              0.000012 let s:sorter = {
                                  \ 'name' : 'sorter_rank',
                                  \ 'description' : 'sort by matched rank order',
                                  \}
                            
    1              0.000005 function! s:sorter.filter(candidates, context) "{{{
                              if a:context.input == '' || !has('float') || empty(a:candidates)
                                return a:candidates
                              endif
                            
                              " Initialize.
                              for candidate in a:candidates
                                let candidate.filter__rank = 0
                              endfor
                            
                              " let is_path = has_key(a:candidates[0], 'action__path')
                            
                              for input in split(a:context.input, '\\\@<! ')
                                let input = substitute(substitute(input, '\\ ', ' ', 'g'),
                                      \ '\*', '', 'g')
                            
                                " Calc rank.
                                let l1 = len(input)
                            
                                " for candidate in a:candidates
                                "   let word = is_path ? fnamemodify(candidate.word, ':t') : candidate.word
                                "   let index = stridx(word, input[0])
                                "   let candidate.filter__rank +=
                                "         \ len(word) + (index > 0 ? index * 2 : len(word))
                                " endfor
                            
                                if unite#util#has_lua()
                                  for candidate in a:candidates
                                    let candidate.filter__rank +=
                                          \ s:calc_word_distance_lua(input, candidate.word, l1)
                                  endfor
                                else
                                  for candidate in a:candidates
                                    let candidate.filter__rank +=
                                          \ s:calc_word_distance(input, candidate.word, l1)
                                  endfor
                                endif
                              endfor
                            
                              return unite#util#has_lua() ?
                                    \ s:sort_lua(a:candidates) :
                                    \ unite#util#sort_by(a:candidates, 'v:val.filter__rank')
                            endfunction"}}}
                            
    1              0.000006 function! s:calc_word_distance(str1, str2, l1) "{{{
                              return 
                            
                              let l2 = len(a:str2)
                              let p1 = range(l2+1)
                              let p2 = []
                            
                              for i in range(l2+1)
                                call add(p2, 0)
                              endfor
                            
                              for i in range(a:l1)
                                let p2[0] = p1[0] + 1
                                for j in range(l2)
                                  let p2[j+1] = min([p1[j+1] + 1, p2[j]+1])
                                endfor
                                let [p1, p2] = [p2, p1]
                              endfor
                            
                              " echomsg string([a:str1, a:str2, p1[l2]])
                              return p1[l2]
                            endfunction"}}}
                            
    1              0.000006 function! s:calc_word_distance_lua(str1, str2, l1) "{{{
                              lua << EOF
                              local str1 = vim.eval('a:str1')
                              local str2 = vim.eval('a:str2')
                              local l1 = vim.eval('a:l1')
                              local l2 = string.len(str2)
                              local p1 = {}
                              local p2 = {}
                            
                              local cnt = 0
                              for i = 0, l2+1 do
                                p1[i] = cnt
                                p2[i] = 0
                            
                                cnt = cnt + 1
                              end
                            
                              for i = 0, l1 do
                                p2[0] = p1[0] + 1
                                for j = 0, l2 do
                                  p2[j+1] = math.min(p1[j+1] + 1, p2[j]+1)
                                end
                              end
                            
                              vim.command('let distance = ' .. p1[l2])
                            EOF
                            
                              " echomsg string([a:str1, a:str2, distance])
                              return distance
                            endfunction"}}}
                            
    1              0.000004 function! s:sort_lua(candidates) "{{{
                              lua << EOF
                            do
                              local candidates = vim.eval('a:candidates')
                              local t = {}
                              for i = 1, #candidates do
                                t[i] = candidates[i-1]
                              end
                              table.sort(t, function(a, b)
                                    return a.filter__rank < b.filter__rank
                                  end)
                              for i = 0, #candidates-1 do
                                candidates[i] = t[i+1]
                              end
                            end
                            EOF
                              " echomsg string(map(copy(a:candidates), '[v:val.word, v:val.filter__rank]'))
                              return a:candidates
                            endfunction"}}}
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/filters/converter_nothing.vim
Sourced 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: converter_nothing.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 22 Apr 2011.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000007 function! unite#filters#converter_nothing#define() "{{{
                              return s:converter
                            endfunction"}}}
                            
    1              0.000007 let s:converter = {
                                  \ 'name' : 'converter_nothing',
                                  \ 'description' : 'nothing converter',
                                  \}
                            
    1              0.000003 function! s:converter.filter(candidates, context) "{{{
                              " Nothing.
                              return a:candidates
                            endfunction"}}}
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/mappings.vim
Sourced 1 time
Total time:   0.000741
 Self time:   0.000741

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mappings.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 Nov 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " Define default mappings.
    1              0.000006 function! unite#mappings#define_default_mappings() "{{{
                              " Plugin keymappings "{{{
                              nnoremap <silent><buffer> <Plug>(unite_exit)
                                    \ :<C-u>call <SID>exit()<CR>
                              nnoremap <silent><buffer> <Plug>(unite_all_exit)
                                    \ :<C-u>call <SID>all_exit()<CR>
                              nnoremap <silent><buffer> <Plug>(unite_choose_action)
                                    \ :<C-u>call <SID>choose_action()<CR>
                              nnoremap <expr><buffer> <Plug>(unite_insert_enter)
                                    \ <SID>insert_enter('i')
                              nnoremap <expr><buffer> <Plug>(unite_insert_head)
                                    \ <SID>insert_enter('A'.
                                    \  (repeat("\<Left>", len(substitute(
                                    \    unite#helper#get_input(), '.', 'x', 'g')))))
                              nnoremap <expr><buffer> <Plug>(unite_append_enter)
                                    \ <SID>insert_enter('a')
                              nnoremap <expr><buffer> <Plug>(unite_append_end)
                                    \ <SID>insert_enter('A')
                              nnoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate)
                                    \ :<C-u>call <SID>toggle_mark('j')<CR>
                              nnoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate_up)
                                    \ :<C-u>call <SID>toggle_mark('k')<CR>
                              nnoremap <silent><buffer> <Plug>(unite_redraw)
                                    \ :<C-u>call <SID>redraw()<CR>
                              nnoremap <silent><buffer> <Plug>(unite_rotate_next_source)
                                    \ :<C-u>call <SID>rotate_source(1)<CR>
                              nnoremap <silent><buffer> <Plug>(unite_rotate_previous_source)
                                    \ :<C-u>call <SID>rotate_source(0)<CR>
                              nnoremap <silent><buffer> <Plug>(unite_print_candidate)
                                    \ :<C-u>call <SID>print_candidate()<CR>
                              nnoremap <silent><buffer> <Plug>(unite_print_message_log)
                                    \ :<C-u>call <SID>print_message_log()<CR>
                              nnoremap <buffer><expr> <Plug>(unite_cursor_top)
                                    \ unite#get_current_unite().prompt_linenr.'G0z.'
                              nnoremap <silent><buffer> <Plug>(unite_cursor_bottom)
                                    \ :<C-u>call <SID>redraw_all_candidates()<CR>G
                              nnoremap <buffer><expr> <Plug>(unite_loop_cursor_down)
                                    \ <SID>loop_cursor_down(0)
                              nnoremap <buffer><expr> <Plug>(unite_skip_cursor_down)
                                    \ <SID>loop_cursor_down(1)
                              nnoremap <buffer><silent> <Plug>(unite_next_screen)
                                    \ :<C-u>call <SID>move_screen(1)<CR>
                              nnoremap <buffer><silent> <Plug>(unite_next_half_screen)
                                    \ :<C-u>call <SID>move_half_screen(1)<CR>
                              nnoremap <silent><buffer> <Plug>(unite_quick_match_default_action)
                                    \ :<C-u>call unite#mappings#_quick_match(0)<CR>
                              nnoremap <silent><buffer> <Plug>(unite_quick_match_choose_action)
                                    \ :<C-u>call unite#mappings#_quick_match(1)<CR>
                              nnoremap <silent><buffer> <Plug>(unite_input_directory)
                                    \ :<C-u>call <SID>input_directory()<CR>
                              nnoremap <silent><buffer><expr> <Plug>(unite_do_default_action)
                                    \ unite#do_action(unite#get_current_unite().context.default_action)
                              nnoremap <silent><buffer> <Plug>(unite_delete_backward_path)
                                    \ :<C-u>call <SID>normal_delete_backward_path()<CR>
                              nnoremap <silent><buffer> <Plug>(unite_restart)
                                    \ :<C-u>call <SID>restart()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_toggle_mark_all_candidates)
                                    \ :<C-u>call <SID>toggle_mark_all_candidates()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_toggle_transpose_window)
                                    \ :<C-u>call <SID>toggle_transpose_window()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_toggle_auto_preview)
                                    \ :<C-u>call <SID>toggle_auto_preview()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_toggle_auto_highlight)
                                    \ :<C-u>call <SID>toggle_auto_highlight()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_narrowing_path)
                                    \ :<C-u>call <SID>narrowing_path()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_narrowing_input_history)
                                    \ :<C-u>call <SID>narrowing_input_history()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_narrowing_dot)
                                    \ :<C-u>call <SID>narrowing_dot()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_disable_max_candidates)
                                    \ :<C-u>call <SID>disable_max_candidates()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_quick_help)
                                    \ :<C-u>call <SID>quick_help()<CR>
                              nnoremap <buffer><silent> <Plug>(unite_new_candidate)
                                    \ :<C-u>call <SID>do_new_candidate_action()<CR>
                            
                              vnoremap <buffer><silent> <Plug>(unite_toggle_mark_selected_candidates)
                                    \ :<C-u>call <SID>toggle_mark_candidates(getpos("'<")[1]
                                    \  - unite#get_current_unite().prompt_linenr-1,
                                    \ getpos("'>")[1] - unite#get_current_unite().prompt_linenr - 1)<CR>
                            
                              inoremap <silent><buffer> <Plug>(unite_exit)
                                    \ <ESC>:<C-u>call <SID>exit()<CR>
                              inoremap <silent><expr><buffer> <Plug>(unite_insert_leave)
                                    \ "\<ESC>0".((line('.') <= unite#get_current_unite().prompt_linenr) ?
                                    \ (unite#get_current_unite().prompt_linenr+1)."G" : "")
                                    \ . ":call unite#redraw()\<CR>"
                              inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_char)
                                    \ <SID>smart_imap("\<ESC>:\<C-u>call \<SID>all_exit()\<CR>",
                                    \ (unite#helper#get_input() == '' ?
                                    \ "\<ESC>:\<C-u>call \<SID>all_exit()\<CR>" : "\<C-h>"))
                              inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_line)
                                    \ <SID>smart_imap('', repeat("\<C-h>",
                                    \     col('.')-(len(unite#get_current_unite().prompt)+1)))
                              inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_word)
                                    \ <SID>smart_imap('', "\<C-w>")
                              inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_path)
                                    \ <SID>smart_imap('', <SID>delete_backward_path())
                              inoremap <expr><buffer> <Plug>(unite_select_next_line)
                                    \ pumvisible() ? "\<C-n>" : <SID>loop_cursor_down(0)
                              inoremap <silent><buffer> <Plug>(unite_skip_previous_line)
                                    \ <ESC>:call unite#mappings#loop_cursor_up_call(1, 'i')<CR>
                              inoremap <expr><buffer> <Plug>(unite_select_next_page)
                                    \ pumvisible() ? "\<PageDown>" : repeat("\<Down>", winheight(0))
                              inoremap <expr><buffer> <Plug>(unite_select_previous_page)
                                    \ pumvisible() ? "\<PageUp>" : repeat("\<Up>", winheight(0))
                              inoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate)
                                    \ <C-o>:<C-u>call <SID>toggle_mark('j')<CR>
                              inoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate_up)
                                    \ <C-o>:<C-u>call <SID>toggle_mark('k')<CR>
                              inoremap <silent><buffer> <Plug>(unite_choose_action)
                                    \ <C-o>:<C-u>call <SID>choose_action()<CR>
                              inoremap <expr><buffer> <Plug>(unite_move_head)
                                    \ <SID>smart_imap("\<ESC>".<SID>insert_enter('A'),
                                    \   repeat("\<Left>", len(substitute(
                                    \     unite#helper#get_input(), '.', 'x', 'g'))))
                              inoremap <silent><buffer> <Plug>(unite_quick_match_default_action)
                                    \ <C-o>:<C-u>call unite#mappings#_quick_match(0)<CR>
                              inoremap <silent><buffer> <Plug>(unite_quick_match_choose_action)
                                    \ <C-o>:<C-u>call unite#mappings#_quick_match(1)<CR>
                              inoremap <silent><buffer> <Plug>(unite_input_directory)
                                    \ <C-o>:<C-u>call <SID>input_directory()<CR>
                              inoremap <silent><buffer><expr> <Plug>(unite_do_default_action)
                                    \ unite#do_action(unite#get_current_unite().context.default_action)
                              inoremap <silent><buffer> <Plug>(unite_toggle_transpose_window)
                                    \ <C-o>:<C-u>call <SID>toggle_transpose_window()<CR>
                              inoremap <silent><buffer> <Plug>(unite_toggle_auto_preview)
                                    \ <C-o>:<C-u>call <SID>toggle_auto_preview()<CR>
                              inoremap <silent><buffer> <Plug>(unite_toggle_auto_highlight)
                                    \ <C-o>:<C-u>call <SID>toggle_auto_highlight()<CR>
                              inoremap <silent><buffer> <Plug>(unite_narrowing_path)
                                    \ <C-o>:<C-u>call <SID>narrowing_path()<CR>
                              inoremap <silent><buffer> <Plug>(unite_narrowing_input_history)
                                    \ <C-o>:<C-u>call <SID>narrowing_input_history()<CR>
                              inoremap <silent><buffer> <Plug>(unite_disable_max_candidates)
                                    \ <C-o>:<C-u>call <SID>disable_max_candidates()<CR>
                              inoremap <silent><buffer> <Plug>(unite_redraw)
                                    \ <C-o>:<C-u>call <SID>redraw()<CR>
                              inoremap <buffer><silent> <Plug>(unite_new_candidate)
                                    \ <C-o>:<C-u>call <SID>do_new_candidate_action()<CR>
                              inoremap <silent><buffer> <Plug>(unite_print_message_log)
                                    \ <C-o>:<C-u>call <SID>print_message_log()<CR>
                              "}}}
                            
                              if exists('g:unite_no_default_keymappings')
                                    \ && g:unite_no_default_keymappings
                                return
                              endif
                            
                              " Normal mode key-mappings.
                              nmap <buffer> i         <Plug>(unite_insert_enter)
                              nmap <buffer> I         <Plug>(unite_insert_head)
                              nmap <buffer> A         <Plug>(unite_append_end)
                              nmap <buffer> q         <Plug>(unite_exit)
                              nmap <buffer> Q         <Plug>(unite_all_exit)
                              nmap <buffer> <CR>      <Plug>(unite_do_default_action)
                              nmap <buffer> <Space>   <Plug>(unite_toggle_mark_current_candidate)
                              nmap <buffer> <S-Space> <Plug>(unite_toggle_mark_current_candidate_up)
                              nmap <buffer> <Tab>     <Plug>(unite_choose_action)
                              nmap <buffer> <C-n>     <Plug>(unite_rotate_next_source)
                              nmap <buffer> <C-p>     <Plug>(unite_rotate_previous_source)
                              nmap <buffer> <C-g>     <Plug>(unite_print_message_log)
                              nmap <buffer> <C-l>     <Plug>(unite_redraw)
                              nmap <buffer> gg        <Plug>(unite_cursor_top)
                              nmap <buffer> G         <Plug>(unite_cursor_bottom)
                              nmap <buffer> j         <Plug>(unite_loop_cursor_down)
                              nmap <buffer> <Down>    <Plug>(unite_loop_cursor_down)
                              nmap <buffer> k         <Plug>(unite_loop_cursor_up)
                              nmap <buffer> <Up>      <Plug>(unite_loop_cursor_up)
                              nmap <buffer> J         <Plug>(unite_skip_cursor_down)
                              nmap <buffer> K         <Plug>(unite_skip_cursor_up)
                              nmap <buffer> <C-h>     <Plug>(unite_delete_backward_path)
                              nmap <buffer> <C-r>     <Plug>(unite_restart)
                              nmap <buffer> *         <Plug>(unite_toggle_mark_all_candidates)
                              nmap <buffer> M         <Plug>(unite_disable_max_candidates)
                              nmap <buffer> ?         <Plug>(unite_quick_help)
                              nmap <buffer> N         <Plug>(unite_new_candidate)
                              nmap <buffer> .         <Plug>(unite_narrowing_dot)
                            
                              nmap <silent><buffer><expr> a
                                    \ unite#smart_map("\<Plug>(unite_append_enter)",
                                    \                 "\<Plug>(unite_choose_action)")
                              nnoremap <silent><buffer><expr> d
                                    \ unite#smart_map('d', unite#do_action('delete'))
                              nnoremap <silent><buffer><expr> b
                                    \ unite#smart_map('b', unite#do_action('bookmark'))
                              nnoremap <silent><buffer><expr> e
                                    \ unite#smart_map('e', unite#do_action('edit'))
                              nnoremap <silent><buffer><expr> p
                                    \ unite#do_action('preview')
                              nmap <silent><buffer><expr> x
                                    \ unite#smart_map('x', "\<Plug>(unite_quick_match_default_action)")
                              nnoremap <silent><buffer><expr> t
                                    \ unite#smart_map('t', unite#do_action('tabopen'))
                              nnoremap <silent><buffer><expr> yy
                                    \ unite#smart_map('yy', unite#do_action('yank'))
                            
                              " Visual mode key-mappings.
                              xmap <buffer> <Space>
                                    \ <Plug>(unite_toggle_mark_selected_candidates)
                            
                              " Insert mode key-mappings.
                              imap <buffer> <TAB>     <Plug>(unite_choose_action)
                              imap <buffer> <C-n>     <Plug>(unite_select_next_line)
                              imap <buffer> <Down>     <Plug>(unite_select_next_line)
                              imap <buffer> <C-p>     <Plug>(unite_select_previous_line)
                              imap <buffer> <Up>     <Plug>(unite_select_previous_line)
                              imap <buffer> <C-f>     <Plug>(unite_select_next_page)
                              imap <buffer> <C-b>     <Plug>(unite_select_previous_page)
                              imap <buffer> <CR>      <Plug>(unite_do_default_action)
                              imap <buffer> <C-h>     <Plug>(unite_delete_backward_char)
                              imap <buffer> <BS>      <Plug>(unite_delete_backward_char)
                              imap <buffer> <C-u>     <Plug>(unite_delete_backward_line)
                              imap <buffer> <C-w>     <Plug>(unite_delete_backward_word)
                              imap <buffer> <C-a>     <Plug>(unite_move_head)
                              imap <buffer> <Home>    <Plug>(unite_move_head)
                              imap <buffer> <C-l>     <Plug>(unite_redraw)
                              if has('gui_running')
                                imap <buffer> <ESC>     <Plug>(unite_insert_leave)
                              endif
                              imap <buffer> <C-g>     <Plug>(unite_exit)
                            
                              imap <silent><buffer><expr> <Space>
                                    \ unite#smart_map(' ', "\<Plug>(unite_toggle_mark_current_candidate)")
                              imap <silent><buffer><expr> <S-Space>
                                    \ unite#smart_map(' ', "\<Plug>(unite_toggle_mark_current_candidate_up)")
                            
                              inoremap <silent><buffer><expr> <C-d>
                                    \ unite#do_action('delete')
                              inoremap <silent><buffer><expr> <C-e>
                                    \ unite#do_action('edit')
                              inoremap <silent><buffer><expr> <C-t>
                                    \ unite#do_action('tabopen')
                              inoremap <silent><buffer><expr> <C-y>
                                    \ unite#do_action('yank')
                            endfunction"}}}
                            
    1              0.000005 function! unite#mappings#narrowing(word) "{{{
                              setlocal modifiable
                              let unite = unite#get_current_unite()
                              let unite.input = escape(a:word, ' *')
                              let prompt_linenr = unite.prompt_linenr
                              call setline(prompt_linenr, unite.prompt . unite.input)
                              call unite#redraw()
                            
                              call cursor(prompt_linenr, 0)
                              startinsert!
                            endfunction"}}}
                            
    1              0.000003 function! unite#mappings#do_action(...) "{{{
                              return call('unite#action#do', a:000)
                            endfunction"}}}
                            
    1              0.000003 function! unite#mappings#get_current_filters() "{{{
                              let unite = unite#get_current_unite()
                              return unite.post_filters
                            endfunction"}}}
    1              0.000004 function! unite#mappings#set_current_filters(filters) "{{{
                              let unite = unite#get_current_unite()
                              let unite.post_filters = a:filters
                              let unite.context.is_redraw = 1
                              return mode() ==# 'i' ? "\<C-r>\<ESC>" : "g\<ESC>"
                            endfunction"}}}
                            
    1              0.000004 function! s:smart_imap(lhs, rhs) "{{{
                              return line('.') != unite#get_current_unite().prompt_linenr ||
                                    \ col('.') <= (unite#util#wcswidth(unite#get_current_unite().prompt)) ?
                                    \ a:lhs : a:rhs
                            endfunction"}}}
    1              0.000002 function! s:smart_imap2(lhs, rhs) "{{{
                              return line('.') <= (len(unite#get_current_unite().prompt)+1) ?
                                   \ a:lhs : a:rhs
                            endfunction"}}}
                            
    1              0.000002 function! s:do_new_candidate_action() "{{{
                              if empty(unite#helper#get_current_candidate())
                                " Get source name.
                                if len(unite#get_sources()) != 1
                                  call unite#print_error('[unite] No candidates and multiple sources.')
                                  return
                                endif
                            
                                " Dummy candidate.
                                let candidates = unite#init#_candidates_source([{}],
                                      \ unite#get_sources()[0].name)
                              else
                                let candidates = [unite#helper#get_current_candidate()]
                              endif
                            
                              return unite#action#do('unite__new_candidate', candidates)
                            endfunction"}}}
                            
                            " key-mappings functions.
    1              0.000002 function! s:exit() "{{{
                              let context = unite#get_context()
                            
                              call unite#force_quit_session()
                            
                              if context.tab && winnr('$') == 1 && !context.temporary
                                " Close window.
                                close
                              endif
                            endfunction"}}}
    1              0.000002 function! s:all_exit() "{{{
                              call unite#all_quit_session()
                            endfunction"}}}
    1              0.000002 function! s:restart() "{{{
                              let unite = unite#get_current_unite()
                              let context = unite.context
                              let context.resume = 0
                              let context.is_restart = 1
                              let sources = map(deepcopy(unite.sources),
                                    \ 'empty(v:val.args) ? v:val.name : [v:val.name] + v:val.args')
                              call unite#force_quit_session()
                              call unite#start(sources, context)
                            endfunction"}}}
    1              0.000002 function! s:delete_backward_path() "{{{
                              let cur_text =
                                    \ (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))
                              let path = matchstr(cur_text[
                                    \ len(unite#get_context().prompt):], '[^/]*.$')
                              return repeat("\<C-h>", unite#util#strchars(path))
                            endfunction"}}}
    1              0.000003 function! s:normal_delete_backward_path() "{{{
                              let modifiable_save = &l:modifiable
                              setlocal modifiable
                              call setline(unite#get_current_unite().prompt_linenr,
                                    \ substitute(getline(unite#get_current_unite().prompt_linenr)[
                                    \    len(unite#get_current_unite().prompt):],
                                    \                 '[^/]*.$', '', ''))
                              call unite#redraw()
                              let &l:modifiable = modifiable_save
                            endfunction"}}}
    1              0.000002 function! s:toggle_mark(...) "{{{
                              let candidate = unite#helper#get_current_candidate()
                              if empty(candidate) || get(candidate, 'is_dummy', 0)
                                return
                              endif
                            
                              let candidate.unite__is_marked = !candidate.unite__is_marked
                              let candidate.unite__marked_time = localtime()
                            
                              let prompt_linenr = unite#get_current_unite().prompt_linenr
                            
                              call unite#view#_redraw_line()
                            
                              let map = get(a:000, 0, '')
                              if map == ''
                                return
                              endif
                            
                              while 1
                                if map ==# 'j'
                                  if line('.') != line('$')
                                    normal! j
                                  endif
                                elseif map ==# 'k'
                                  if line('.') > prompt_linenr
                                    normal! k
                                  endif
                                endif
                            
                                let candidate = unite#helper#get_current_candidate()
                                if (map ==# 'j' && line('.') <= prompt_linenr ||
                                      \ map ==# 'k' && line('.') == line('$')) ||
                                      \ !get(candidate, 'is_dummy', 0)
                                  break
                                endif
                              endwhile
                            endfunction"}}}
    1              0.000003 function! s:toggle_mark_all_candidates() "{{{
                              call s:redraw_all_candidates()
                              call s:toggle_mark_candidates(0,
                                    \     len(unite#get_unite_candidates()) - 1)
                            endfunction"}}}
    1              0.000003 function! s:toggle_mark_candidates(start, end) "{{{
                              if a:start < 0 || a:end >= len(unite#get_unite_candidates())
                                " Ignore.
                                return
                              endif
                            
                              let unite = unite#get_current_unite()
                              let offset = unite.prompt_linenr+1
                              let cnt = a:start
                              while cnt <= a:end
                                let candidate = unite#get_unite_candidates()[cnt]
                                let candidate.unite__is_marked = !candidate.unite__is_marked
                                let candidate.unite__marked_time = localtime()
                            
                                call unite#view#_redraw_line(cnt + offset)
                            
                                let cnt += 1
                              endwhile
                            endfunction"}}}
    1              0.000003 function! s:quick_help() "{{{
                              let unite = unite#get_current_unite()
                            
                              call unite#start_temporary([['mapping', bufnr('%')]], {}, 'mapping-help')
                            endfunction"}}}
    1              0.000002 function! s:choose_action() "{{{
                              let unite = unite#get_current_unite()
                              if line('$') < (unite.prompt_linenr+1)
                                " Ignore.
                                return
                              endif
                            
                              let candidates = unite#helper#get_marked_candidates()
                              if empty(candidates)
                                let candidates = [ unite#helper#get_current_candidate() ]
                              endif
                            
                              call unite#mappings#_choose_action(candidates)
                            endfunction"}}}
    1              0.000004 function! unite#mappings#_choose_action(candidates, ...) "{{{
                              call filter(a:candidates,
                                    \ '!has_key(v:val, "is_dummy") || !v:val.is_dummy')
                              if empty(a:candidates)
                                return
                              endif
                            
                              let unite = unite#get_current_unite()
                              let context = deepcopy(get(a:000, 0, {}))
                              let context.source__sources = unite.sources
                              let context.buffer_name = 'action'
                              let context.profile_name = 'action'
                              let context.start_insert = 1
                            
                              call call((has_key(context, 'vimfiler__current_directory') ?
                                    \ 'unite#start' : 'unite#start_temporary'),
                                    \ [[[unite#sources#action#define(), a:candidates]], context])
                            endfunction"}}}
    1              0.000002 function! s:insert_enter(key) "{{{
                              setlocal modifiable
                            
                              let unite = unite#get_current_unite()
                              if line('.') != unite.prompt_linenr
                                    \ || col('.') <= len(unite.prompt)
                                return unite.prompt_linenr.'GzbA'
                              endif
                              return a:key
                            endfunction"}}}
    1              0.000001 function! s:redraw() "{{{
                              call unite#clear_message()
                            
                              let unite = unite#get_current_unite()
                              call unite#force_redraw()
                            endfunction"}}}
    1              0.000002 function! s:rotate_source(is_next) "{{{
                              let unite = unite#get_current_unite()
                            
                              for source in unite#loaded_sources_list()
                                let unite.sources = a:is_next ?
                                      \ add(unite.sources[1:], unite.sources[0]) :
                                      \ insert(unite.sources[: -2], unite.sources[-1])
                            
                                if !empty(unite.sources[0].unite__candidates)
                                  break
                                endif
                              endfor
                            
                              call unite#view#_redraw_candidates()
                            endfunction"}}}
    1              0.000004 function! s:print_candidate() "{{{
                              if line('.') <= unite#get_current_unite().prompt_linenr
                                " Ignore.
                                return
                              endif
                            
                              let candidate = unite#helper#get_current_candidate()
                              echo 'abbr: ' . candidate.unite__abbr
                              echo 'word: ' . candidate.word
                            endfunction"}}}
    1              0.000002 function! s:print_message_log() "{{{
                              for msg in unite#get_current_unite().msgs
                                echohl Comment | echo msg | echohl None
                              endfor
                              for msg in unite#get_current_unite().err_msgs
                                echohl WarningMsg | echo msg | echohl None
                              endfor
                            endfunction"}}}
    1              0.000003 function! s:insert_selected_candidate() "{{{
                              if line('.') <= unite#get_current_unite().prompt_linenr
                                " Ignore.
                                return
                              endif
                            
                              let candidate = unite#helper#get_current_candidate()
                              call unite#mappings#narrowing(candidate.word)
                            endfunction"}}}
    1              0.000004 function! unite#mappings#_quick_match(is_choose) "{{{
                              if !empty(unite#helper#get_marked_candidates())
                                call unite#util#print_error('Marked candidates is detected.')
                                return
                              endif
                            
                              let quick_match_table = s:get_quick_match_table()
                              call unite#view#_quick_match_redraw(quick_match_table)
                            
                              if mode() !~# '^c'
                                echo 'Input quick match key: '
                              endif
                              let char = ''
                            
                              while char == ''
                                let char = nr2char(getchar())
                              endwhile
                            
                              redraw
                              echo ''
                            
                              call unite#view#_redraw_candidates()
                            
                              let unite = unite#get_current_unite()
                            
                              if !has_key(quick_match_table, char)
                                    \ || quick_match_table[char] >= len(unite.current_candidates)
                                call unite#util#print_error('Canceled.')
                                return
                              endif
                            
                              let candidate = unite.current_candidates[quick_match_table[char]]
                              if candidate.is_dummy
                                call unite#util#print_error('Canceled.')
                                return
                              endif
                            
                              if a:is_choose
                                call unite#mappings#_choose_action([candidate])
                              else
                                call unite#action#do(
                                      \ unite.context.default_action, [candidate])
                              endif
                            endfunction"}}}
    1              0.000002 function! s:input_directory() "{{{
                              let path = unite#substitute_path_separator(
                                    \ input('Input narrowing directory: ',
                                    \         unite#helper#get_input(), 'dir'))
                              let path = path.(path == '' || path =~ '/$' ? '' : '/')
                              call unite#mappings#narrowing(path)
                            endfunction"}}}
    1              0.000003 function! s:loop_cursor_down(is_skip_not_matched) "{{{
                              let is_insert = mode() ==# 'i'
                              let prompt_linenr = unite#get_current_unite().prompt_linenr
                            
                              if line('.') <= prompt_linenr && !is_insert
                                return line('.') == line('$') &&
                                      \ empty(unite#get_unite_candidates()) ? '2G' : 'j'
                              endif
                            
                              if line('.') == line('$')
                                " Loop.
                                if is_insert
                                  return "\<C-Home>\<End>".repeat("\<Down>", prompt_linenr-1)."\<End>"
                                else
                                  return prompt_linenr.'G0z.'
                                endif
                              endif
                            
                              let num = line('.') - (prompt_linenr + 1)
                              let cnt = 1
                              if line('.') <= prompt_linenr
                                let cnt += prompt_linenr - line('.')
                              endif
                              if is_insert && line('.') == prompt_linenr
                                let cnt += 1
                              endif
                            
                              while 1
                                let candidate = get(unite#get_unite_candidates(), num + cnt, {})
                                if !empty(candidate) && (candidate.is_dummy
                                      \ || (a:is_skip_not_matched && !candidate.is_matched))
                                  let cnt += 1
                                  continue
                                endif
                            
                                break
                              endwhile
                            
                              if is_insert
                                return "\<Home>" . repeat("\<Down>", cnt)
                              else
                                return repeat('j', cnt)
                              endif
                            endfunction"}}}
    1              0.000005 function! unite#mappings#loop_cursor_up_call(is_skip_not_matched, mode) "{{{
                              let is_insert = a:mode ==# 'i'
                              let prompt_linenr = unite#get_current_unite().prompt_linenr
                            
                              if !is_insert && line('.') > prompt_linenr
                                call cursor(line('.') - 1, 0)
                                return
                              endif
                            
                              " Loop.
                            
                              call s:redraw_all_candidates()
                            
                              if is_insert
                                noautocmd startinsert
                              endif
                            
                              call cursor(line('$'), 1)
                            endfunction"}}}
    1              0.000005 function! unite#mappings#loop_cursor_up_expr(is_skip_not_matched) "{{{
                              let is_insert = mode() ==# 'i'
                              let prompt_linenr = unite#get_current_unite().prompt_linenr
                            
                              let num = line('.') - (prompt_linenr + 1)
                              let cnt = 1
                              if line('.') <= prompt_linenr
                                let cnt += prompt_linenr - line('.')
                              endif
                              if is_insert && line('.') == prompt_linenr+2
                                let cnt += 1
                              endif
                            
                              while 1
                                let candidate = get(unite#get_unite_candidates(), num - cnt, {})
                                if num >= cnt && !empty(candidate) && (candidate.is_dummy
                                      \ || (a:is_skip_not_matched && !candidate.is_matched))
                                  let cnt += 1
                                  continue
                                endif
                            
                                break
                              endwhile
                            
                              if num < 0
                                if is_insert
                                  return "\<C-Home>\<End>".repeat("\<Down>", prompt_linenr)."\<Home>"
                                else
                                  return prompt_linenr.'G0z.'
                                endif
                              endif
                            
                              if is_insert
                                if line('.') <= prompt_linenr + 2
                                  return repeat("\<Up>", cnt) . "\<End>"
                                else
                                  return "\<Home>" . repeat("\<Up>", cnt)
                                endif
                              else
                                return repeat('k', cnt)
                              endif
                            endfunction"}}}
    1              0.000002 function! s:toggle_transpose_window() "{{{
                              " Toggle vertical/horizontal view.
                              let context = unite#get_context()
                              let direction = context.vertical ?
                                    \ (context.direction ==# 'topleft' ? 'K' : 'J') :
                                    \ (context.direction ==# 'topleft' ? 'H' : 'L')
                            
                              execute 'silent wincmd ' . direction
                            
                              let context.vertical = !context.vertical
                            endfunction"}}}
    1              0.000002 function! s:toggle_auto_preview() "{{{
                              let context = unite#get_context()
                              let context.auto_preview = !context.auto_preview
                            
                              if !context.auto_preview
                                    \ && !unite#get_current_unite().has_preview_window
                                " Close preview window.
                                noautocmd pclose!
                              endif
                            endfunction"}}}
    1              0.000002 function! s:toggle_auto_highlight() "{{{
                              let context = unite#get_context()
                              let context.auto_highlight = !context.auto_highlight
                            endfunction"}}}
    1              0.000003 function! s:disable_max_candidates() "{{{
                              let unite = unite#get_current_unite()
                              let unite.disabled_max_candidates = 1
                            
                              call unite#force_redraw()
                              call s:redraw_all_candidates()
                            endfunction"}}}
    1              0.000002 function! s:narrowing_path() "{{{
                              if line('.') <= unite#get_current_unite().prompt_linenr
                                " Ignore.
                                return
                              endif
                            
                              let candidate = unite#helper#get_current_candidate()
                              call unite#mappings#narrowing(has_key(candidate, 'action__path')?
                                    \ candidate.action__path : candidate.word)
                            endfunction"}}}
    1              0.000002 function! s:narrowing_input_history() "{{{
                              call unite#start_temporary(
                                    \ [unite#sources#history_input#define()],
                                    \ { 'old_source_names_string' : unite#loaded_source_names_string() },
                                    \ 'history/input')
                            endfunction"}}}
    1              0.000002 function! s:redraw_all_candidates() "{{{
                              let unite = unite#get_current_unite()
                              if len(unite.candidates) != len(unite.current_candidates)
                                call unite#redraw(0, 1)
                              endif
                            endfunction"}}}
    1              0.000003 function! s:narrowing_dot() "{{{
                              call unite#mappings#narrowing(unite#helper#get_input().'.')
                            endfunction"}}}
                            
    1              0.000002 function! s:get_quick_match_table() "{{{
                              let offset = line('.') - unite#get_current_unite().prompt_linenr - 1
                              if offset < 0
                                let offset = 0
                              endif
                            
                              let table = deepcopy(g:unite_quick_match_table)
                              for key in keys(table)
                                let table[key] += offset
                              endfor
                              return table
                            endfunction"}}}
                            "}}}
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/syntax/unite.vim
Sourced 1 time
Total time:   0.000907
 Self time:   0.000270

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: syntax/unite.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 13 Jun 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000004 if version < 700
                              syntax clear
                            elseif exists('b:current_syntax')
                              finish
                            endif
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000036 syntax match uniteQuickMatchLine /^.|.*/
                                  \ contains=uniteQuickMatchTrigger,uniteCandidateSourceName,uniteCandidateAbbr
    1              0.000005 syntax match uniteQuickMatchTrigger /^.|/ contained
    1              0.000010 syntax match uniteInputCommand /\\\@<! :\S\+/ contained
                            
    1              0.000009 highlight default link uniteError  Error
                            
    1              0.000004 highlight default link uniteQuickMatchTrigger  Special
    1              0.000008 highlight default link uniteMarkedLine  Statement
    1              0.000004 highlight default link uniteCandidateSourceName  Type
    1              0.000008 highlight default link uniteCandidateMarker  Special
    1              0.000007 highlight default link uniteCandidateInputKeyword  Function
                            
                            " The following definitions are for <Plug>(unite-choose-action).
    1              0.000004 highlight default link uniteChooseAction  NONE
    1              0.000035 highlight default link uniteChooseCandidate  NONE
    1              0.000010 highlight default link uniteChooseKey  SpecialKey
    1              0.000004 highlight default link uniteChooseMessage  NONE
    1              0.000008 highlight default link uniteChoosePrompt  uniteSourcePrompt
    1              0.000007 highlight default link uniteChooseSource  uniteSourceNames
                            
    1              0.000007 highlight default link uniteInputPrompt  Identifier
    1              0.000008 highlight default link uniteInputPromptError  Error
    1              0.000004 highlight default link uniteInputCommand  Statement
                            
    1              0.000004 let b:current_syntax = 'unite'
                            
    1   0.000648   0.000011 call unite#view#_set_highlight()
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/action.vim
Sourced 1 time
Total time:   0.001774
 Self time:   0.001774

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: action.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 Nov 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000052 let s:save_cpo = &cpo
    1              0.000032 set cpo&vim
                            
    1              0.000022 function! unite#action#get_action_table(source_name, kind, self_func, ...) "{{{
                              let is_parents_action = get(a:000, 0, 0)
                              let source_table = get(a:000, 1, {})
                            
                              let action_table = {}
                              for kind_name in unite#util#convert2list(a:kind)
                                call extend(action_table,
                                      \ s:get_action_table(a:source_name,
                                      \                kind_name, a:self_func,
                                      \                is_parents_action, source_table))
                              endfor
                            
                              return action_table
                            endfunction"}}}
                            
    1              0.000014 function! unite#action#get_alias_table(source_name, kind, ...) "{{{
                              let source_table = get(a:000, 0, {})
                              let alias_table = {}
                              for kind_name in unite#util#convert2list(a:kind)
                                call extend(alias_table,
                                      \ s:get_alias_table(a:source_name, kind_name, source_table))
                              endfor
                            
                              return alias_table
                            endfunction"}}}
                            
    1              0.000012 function! unite#action#get_default_action(source_name, kind) "{{{
                              let kinds = unite#util#convert2list(a:kind)
                            
                              return s:get_default_action(a:source_name, kinds[-1])
                            endfunction"}}}
                            
    1              0.000015 function! s:get_action_table(source_name, kind_name, self_func, is_parents_action, source_table) "{{{
                              let kind = unite#get_kinds(a:kind_name)
                              let source = empty(a:source_table) ?
                                    \ unite#get_sources(a:source_name) :
                                    \ unite#util#get_name(a:source_table, a:source_name, {})
                              if empty(source)
                                call unite#print_error('[unite.vim] source "' . a:source_name . '" is not found.')
                                return {}
                              endif
                              if empty(kind)
                                call unite#print_error('[unite.vim] kind "' . a:kind_name . '" is not found.')
                                return {}
                              endif
                            
                              let action_table = {}
                            
                              let source_kind = 'source/'.a:source_name.'/'.a:kind_name
                              let source_kind_wild = 'source/'.a:source_name.'/*'
                            
                              let custom = unite#custom#get()
                            
                              if !a:is_parents_action
                                " Source/kind custom actions.
                                if has_key(custom.actions, source_kind)
                                  let action_table = s:extend_actions(a:self_func, action_table,
                                        \ custom.actions[source_kind], 'custom/'.source.name.'/'.kind.name)
                                endif
                            
                                " Source/kind actions.
                                if has_key(source.action_table, a:kind_name)
                                  let action_table = s:extend_actions(a:self_func, action_table,
                                        \ source.action_table[a:kind_name], source.name.'/'.kind.name)
                                endif
                            
                                " Source/* custom actions.
                                if has_key(custom.actions, source_kind_wild)
                                  let action_table = s:extend_actions(a:self_func, action_table,
                                        \ custom.actions[source_kind_wild], 'custom/source/'.source.name)
                                endif
                            
                                " Source/* actions.
                                if has_key(source.action_table, '*')
                                  let action_table = s:extend_actions(a:self_func, action_table,
                                        \ source.action_table['*'], 'source/'.source.name)
                                endif
                            
                                " Kind custom actions.
                                if has_key(custom.actions, a:kind_name)
                                  let action_table = s:extend_actions(a:self_func, action_table,
                                        \ custom.actions[a:kind_name], 'custom/'.kind.name)
                                endif
                            
                                " Kind actions.
                                let action_table = s:extend_actions(a:self_func, action_table,
                                      \ kind.action_table, kind.name)
                              endif
                            
                              " Parents actions.
                              for parent in source.parents
                                let parent_kind = unite#get_kinds(parent)
                                let action_table = s:extend_actions(a:self_func, action_table,
                                      \ parent_kind.action_table, parent)
                              endfor
                              for parent in kind.parents
                                let action_table = s:extend_actions(a:self_func, action_table,
                                      \ unite#action#get_action_table(a:source_name, parent,
                                      \                    a:self_func, 0, a:source_table))
                              endfor
                            
                              if !a:is_parents_action
                                " Kind aliases.
                                call s:filter_alias_action(action_table, kind.alias_table,
                                      \ kind.name)
                            
                                " Kind custom aliases.
                                if has_key(custom.aliases, a:kind_name)
                                  call s:filter_alias_action(action_table, custom.aliases[a:kind_name],
                                        \ 'custom/'.kind.name)
                                endif
                            
                                " Source/* aliases.
                                if has_key(source.alias_table, '*')
                                  call s:filter_alias_action(action_table, source.alias_table['*'],
                                        \ 'source/'.source.name)
                                endif
                            
                                " Source/* custom aliases.
                                if has_key(custom.aliases, source_kind_wild)
                                  call s:filter_alias_action(action_table, custom.aliases[source_kind_wild],
                                        \ 'custom/source/'.source.name)
                                endif
                            
                                " Source/kind aliases.
                                if has_key(custom.aliases, source_kind)
                                  call s:filter_alias_action(action_table, custom.aliases[source_kind],
                                        \ 'source/'.source.name.'/'.kind.name)
                                endif
                            
                                " Source/kind custom aliases.
                                if has_key(source.alias_table, a:kind_name)
                                  call s:filter_alias_action(action_table, source.alias_table[a:kind_name],
                                        \ 'custom/source/'.source.name.'/'.kind.name)
                                endif
                              endif
                            
                              " Initialize action.
                              for [action_name, action] in items(action_table)
                                if !has_key(action, 'name')
                                  let action.name = action_name
                                endif
                                if !has_key(action, 'from')
                                  let action.from = ''
                                endif
                                if !has_key(action, 'description')
                                  let action.description = ''
                                endif
                                if !has_key(action, 'is_quit')
                                  let action.is_quit = 1
                                endif
                                if !has_key(action, 'is_start')
                                  let action.is_start = 0
                                endif
                                if !has_key(action, 'is_tab')
                                  let action.is_tab = 0
                                endif
                                if !has_key(action, 'is_selectable')
                                  let action.is_selectable = 0
                                endif
                                if !has_key(action, 'is_invalidate_cache')
                                  let action.is_invalidate_cache = 0
                                endif
                                if !has_key(action, 'is_listed')
                                  let action.is_listed =
                                        \ (action.name !~ '^unite__\|^vimfiler__')
                                endif
                              endfor
                            
                              " Filtering nop action.
                              return filter(action_table, 'v:key !=# "nop"')
                            endfunction"}}}
                            
    1              0.000015 function! s:get_alias_table(source_name, kind_name, source_table) "{{{
                              let kind = unite#get_kinds(a:kind_name)
                              let source = empty(a:source_table) ?
                                    \ unite#get_sources(a:source_name) :
                                    \ unite#util#get_name(a:source_table, a:source_name, {})
                              if empty(source)
                                call unite#print_error('[unite.vim] source "' . a:source_name . '" is not found.')
                                return {}
                              endif
                            
                              let table = kind.alias_table
                            
                              let source_kind = 'source/'.a:source_name.'/'.a:kind_name
                              let source_kind_wild = 'source/'.a:source_name.'/*'
                            
                              let custom = unite#custom#get()
                            
                              " Kind custom aliases.
                              if has_key(custom.aliases, a:kind_name)
                                let table = extend(table, custom.aliases[a:kind_name])
                              endif
                            
                              " Source/* aliases.
                              if has_key(source.alias_table, '*')
                                let table = extend(table, source.alias_table['*'])
                              endif
                            
                              " Source/* custom aliases.
                              if has_key(custom.aliases, source_kind_wild)
                                let table = extend(table, custom.aliases[source_kind_wild])
                              endif
                            
                              " Source/kind aliases.
                              if has_key(custom.aliases, source_kind)
                                let table = extend(table, custom.aliases[source_kind])
                              endif
                            
                              " Source/kind custom aliases.
                              if has_key(source.alias_table, a:kind_name)
                                let table = extend(table, source.alias_table[a:kind_name])
                              endif
                            
                              return table
                            endfunction"}}}
                            
    1              0.000010 function! s:get_default_action(source_name, kind_name) "{{{
                              let source = unite#get_all_sources(a:source_name)
                              if empty(source)
                                return ''
                              endif
                            
                              let source_kind = 'source/'.a:source_name.'/'.a:kind_name
                              let source_kind_wild = 'source/'.a:source_name.'/*'
                            
                              let custom = unite#custom#get()
                            
                              " Source/kind custom default actions.
                              if has_key(custom.default_actions, source_kind)
                                return custom.default_actions[source_kind]
                              endif
                            
                              " Source custom default actions.
                              if has_key(source.default_action, a:kind_name)
                                return source.default_action[a:kind_name]
                              endif
                            
                              " Source/* custom default actions.
                              if has_key(custom.default_actions, source_kind_wild)
                                return custom.default_actions[source_kind_wild]
                              endif
                            
                              " Source/* default actions.
                              if has_key(source.default_action, '*')
                                return source.default_action['*']
                              endif
                            
                              " Kind custom default actions.
                              if has_key(custom.default_actions, a:kind_name)
                                return custom.default_actions[a:kind_name]
                              endif
                            
                              " Kind default actions.
                              let kind = unite#get_kinds(a:kind_name)
                              return get(kind, 'default_action', '')
                            endfunction"}}}
                            
    1              0.000016 function! unite#action#take(action_name, candidate, is_parent_action) "{{{
                              let candidate_head = type(a:candidate) == type([]) ?
                                    \ a:candidate[0] : a:candidate
                            
                              let action_table = unite#action#get_action_table(
                                    \ candidate_head.source, candidate_head.kind,
                                    \ unite#get_self_functions()[-3], a:is_parent_action)
                            
                              let action_name =
                                    \ a:action_name ==# 'default' ?
                                    \ unite#action#get_default_action(
                                    \   candidate_head.source, candidate_head.kind)
                                    \ : a:action_name
                            
                              if !has_key(action_table, a:action_name)
                                " throw 'unite.vim: no such action ' . a:action_name
                                return 1
                              endif
                            
                              let action = action_table[a:action_name]
                              " Convert candidates.
                              call action.func(
                                    \ (action.is_selectable && type(a:candidate) != type([])) ?
                                    \ [a:candidate] : a:candidate)
                            endfunction"}}}
                            
    1              0.000011 function! unite#action#do(action_name, ...) "{{{
                              if &filetype == 'vimfiler' && has_key(b:vimfiler, 'unite')
                                " Restore unite condition in vimfiler.
                                call unite#set_current_unite(b:vimfiler.unite)
                              endif
                            
                              call unite#redraw()
                            
                              let candidates = get(a:000, 0,
                                    \ unite#helper#get_marked_candidates())
                              let new_context = get(a:000, 1, {})
                              let sources = get(a:000, 2, {})
                            
                              let unite = unite#get_current_unite()
                              if empty(candidates)
                                let num = (line('.') <= unite.prompt_linenr) ? 0 :
                                      \ (line('.') - (unite.prompt_linenr + 1))
                                if line('$') - (unite.prompt_linenr + 1) < num
                                  " Ignore.
                                  return []
                                endif
                            
                                let candidates = [ unite#helper#get_current_candidate() ]
                              endif
                            
                              let candidates = filter(copy(candidates),
                                    \ "!empty(v:val) && !get(v:val, 'is_dummy', 0)")
                              if empty(candidates)
                                return []
                              endif
                            
                              let action_tables = s:get_candidates_action_table(
                                    \ a:action_name, candidates, sources)
                            
                              if !empty(new_context)
                                " Set new context.
                                let new_context = extend(
                                      \ deepcopy(unite#get_context()), new_context)
                                let old_context = unite#set_context(new_context)
                                let unite = unite#get_current_unite()
                              endif
                            
                              let context = unite#get_context()
                            
                              " Execute action.
                              let is_quit = 0
                              let is_redraw = 0
                              let _ = []
                              for table in action_tables
                                " Check quit flag.
                                if table.action.is_quit && unite.profile_name !=# 'action'
                                      \ && !table.action.is_start
                                      \ && !(table.action.is_tab && context.no_quit)
                                  call unite#all_quit_session(0)
                                  let is_quit = 1
                                endif
                            
                                if table.action.is_start && !empty(unite#helper#get_marked_candidates())
                                  call s:clear_marks(candidates)
                                  call unite#force_redraw()
                                  let is_redraw = 0
                                elseif table.action.is_selectable
                                  let is_redraw = 1
                                endif
                            
                                try
                                  call add(_, table.action.func(table.candidates))
                                catch /^Vim\%((\a\+)\)\=:E325/
                                  " Ignore catch.
                                  call unite#print_error(v:exception)
                                  call unite#print_error('Warning: Swap file was found while executing action!')
                                  call unite#print_error('Action name is ' . table.action.name)
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error('Error occured while executing action!')
                                  call unite#print_error('Action name is ' . table.action.name)
                                endtry
                            
                                " Executes command.
                                if context.execute_command != ''
                                  execute context.execute_command
                                endif
                            
                                " Check invalidate cache flag.
                                if table.action.is_invalidate_cache
                                  for source_name in table.source_names
                                    call unite#helper#invalidate_cache(source_name)
                                  endfor
                            
                                  let is_redraw = 1
                                endif
                              endfor
                            
                              if (!is_quit || unite.context.no_quit) && unite.context.keep_focus
                                let winnr = bufwinnr(unite.bufnr)
                            
                                if winnr > 0
                                  " Restore focus.
                                  execute winnr 'wincmd w'
                                endif
                              endif
                            
                              if !empty(new_context)
                                " Restore context.
                                let unite.context = old_context
                              endif
                            
                              if is_redraw && !empty(filter(range(1, winnr('$')),
                                      \ "getwinvar(v:val, '&filetype') ==# 'vimfiler'"))
                                " Redraw vimfiler buffer.
                                call vimfiler#force_redraw_all_vimfiler(1)
                              endif
                            
                              if !is_quit && is_redraw
                                call s:clear_marks(candidates)
                                call unite#force_redraw()
                              endif
                            
                              return _
                            endfunction"}}}
                            
    1              0.000014 function! unite#action#do_candidates(action_name, candidates, ...) "{{{
                              let context = get(a:000, 0, {})
                              let context = unite#init#_context(context)
                              let context.unite__is_interactive = 0
                              let context.unite__disable_hooks = 1
                              call unite#set_context(context)
                            
                              return unite#action#do(
                                    \ a:action_name, a:candidates, context)
                            endfunction"}}}
                            
    1              0.000015 function! unite#action#_get_candidate_action_table(candidate, sources) "{{{
                              let Self = unite#get_self_functions()[-1]
                            
                              return unite#action#get_action_table(
                                    \ a:candidate.source, a:candidate.kind, Self, 0, a:sources)
                            endfunction"}}}
                            
    1              0.000011 function! s:get_candidates_action_table(action_name, candidates, sources) "{{{
                              let action_tables = []
                              let Self = unite#get_self_functions()[-1]
                              for candidate in a:candidates
                                let action_table = unite#action#_get_candidate_action_table(
                                      \ candidate, a:sources)
                            
                                let action_name = a:action_name
                                if action_name ==# 'default'
                                  " Get default action.
                                  let action_name = unite#action#get_default_action(
                                        \ candidate.source, candidate.kind)
                                endif
                            
                                if action_name == ''
                                  " Ignore.
                                  return []
                                endif
                            
                                if !has_key(action_table, action_name)
                                  call unite#util#print_error(
                                        \ candidate.unite__abbr . '(' . candidate.source . ')')
                                  call unite#util#print_error(
                                        \ 'No such action : ' . action_name)
                            
                                  return []
                                endif
                            
                                let action = action_table[action_name]
                            
                                " Check selectable flag.
                                if !action.is_selectable && len(a:candidates) > 1
                                  call unite#util#print_error(
                                        \ candidate.unite__abbr . '(' . candidate.source . ')')
                                  call unite#util#print_error(
                                        \ 'Not selectable action : ' . action_name)
                                  return []
                                endif
                            
                                let found = 0
                                for table in action_tables
                                  if action == table.action
                                    " Add list.
                                    call add(table.candidates, candidate)
                                    call add(table.source_names, candidate.source)
                                    let found = 1
                                    break
                                  endif
                                endfor
                            
                                if !found
                                  " Add action table.
                                  call add(action_tables, {
                                        \ 'action' : action,
                                        \ 'source_names' : [candidate.source],
                                        \ 'candidates' : (!action.is_selectable ? candidate : [candidate]),
                                        \ })
                                endif
                              endfor
                            
                              return action_tables
                            endfunction"}}}
                            
    1              0.000011 function! s:extend_actions(self_func, action_table1, action_table2, ...) "{{{
                              let filterd_table = s:filter_self_func(a:action_table2, a:self_func)
                            
                              if a:0 > 0
                                for action in values(filterd_table)
                                  let action.from = a:1
                                endfor
                              endif
                            
                              return extend(a:action_table1, filterd_table, 'keep')
                            endfunction"}}}
    1              0.000011 function! s:filter_alias_action(action_table, alias_table, from) "{{{
                              for [alias_name, alias_action] in items(a:alias_table)
                                if alias_action ==# 'nop'
                                  if has_key(a:action_table, alias_name)
                                    " Delete nop action.
                                    call remove(a:action_table, alias_name)
                                  endif
                                elseif has_key(a:action_table, alias_action)
                                  let a:action_table[alias_name] = copy(a:action_table[alias_action])
                                  let a:action_table[alias_name].from = a:from
                                  let a:action_table[alias_name].name = alias_name
                                endif
                              endfor
                            endfunction"}}}
    1              0.000009 function! s:filter_self_func(action_table, self_func) "{{{
                              return filter(copy(a:action_table),
                                    \ printf("string(v:val.func) !=# \"function('%s')\"", a:self_func))
                            endfunction"}}}
    1              0.000008 function! s:clear_marks(candidates) "{{{
                              for candidate in a:candidates
                                let candidate.unite__is_marked = 0
                              endfor
                            endfunction"}}}
                            
    1              0.000036 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/file.vim
Sourced 1 time
Total time:   0.015049
 Self time:   0.001255

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: file.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 25 Nov 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000018 let s:save_cpo = &cpo
    1              0.000015 set cpo&vim
                            
                            " Global options definition. "{{{
    1   0.000165   0.000121 call unite#util#set_default(
                                  \ 'g:unite_kind_file_delete_file_command',
                                  \ unite#util#is_windows() && !executable('rm') ? '' :
                                  \ executable('trash-put') ? 'trash-put $srcs' :
                                  \ executable('rmtrash') ? 'rmtrash $srcs' :
                                  \ 'rm $srcs')
    1   0.000081   0.000047 call unite#util#set_default(
                                  \ 'g:unite_kind_file_delete_directory_command',
                                  \ unite#util#is_windows() && !executable('rm') ? '' :
                                  \ executable('trash-put') ? 'trash-put $srcs' :
                                  \ executable('rmtrash') ? 'rmtrash $srcs' :
                                  \ 'rm -r $srcs')
    1   0.000046   0.000018 call unite#util#set_default(
                                  \ 'g:unite_kind_file_copy_file_command',
                                  \ unite#util#is_windows() && !executable('cp') ? '' :
                                  \ 'cp -p $srcs $dest')
    1   0.000048   0.000019 call unite#util#set_default(
                                  \ 'g:unite_kind_file_copy_directory_command',
                                  \ unite#util#is_windows() && !executable('cp') ? '' :
                                  \ 'cp -p -r $srcs $dest')
    1   0.000048   0.000020 call unite#util#set_default(
                                  \ 'g:unite_kind_file_move_command',
                                  \ unite#util#is_windows() && !executable('mv') ?
                                  \  'move /Y $srcs $dest' : 'mv $srcs $dest')
    1   0.000044   0.000018 call unite#util#set_default('g:unite_kind_file_use_trashbox',
                                  \ unite#util#is_windows() && unite#util#has_vimproc())
                            "}}}
                            
    1              0.000007 function! unite#kinds#file#define() "{{{
                              return s:kind
                            endfunction"}}}
                            
    1   0.013621   0.000016 let s:System = unite#util#get_vital().import('System.File')
                            
    1              0.000011 let s:kind = {
                                  \ 'name' : 'file',
                                  \ 'default_action' : 'open',
                                  \ 'action_table' : {},
                                  \ 'alias_table' : { 'unite__new_candidate' : 'vimfiler__newfile' },
                                  \ 'parents' : ['openable', 'cdable', 'uri'],
                                  \}
                            
                            " Actions "{{{
    1              0.000006 let s:kind.action_table.open = {
                                  \ 'description' : 'open files',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000005 function! s:kind.action_table.open.func(candidates) "{{{
                              for candidate in a:candidates
                                if buflisted(unite#util#escape_file_searching(
                                      \ candidate.action__path))
                                  execute 'buffer' bufnr(unite#util#escape_file_searching(
                                      \ candidate.action__path))
                                else
                                  call s:execute_command('edit', candidate)
                                endif
                            
                                doautocmd BufWinEnter
                            
                                call unite#remove_previewed_buffer_list(
                                      \ bufnr(unite#util#escape_file_searching(
                                      \       candidate.action__path)))
                              endfor
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.preview = {
                                  \ 'description' : 'preview file',
                                  \ 'is_quit' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.preview.func(candidate) "{{{
                              let buflisted = buflisted(
                                    \ unite#util#escape_file_searching(
                                    \ a:candidate.action__path))
                              if filereadable(a:candidate.action__path)
                                " If execute this command, unite.vim will be affected by events.
                                noautocmd silent execute 'pedit!'
                                      \ fnameescape(a:candidate.action__path)
                            
                                let prev_winnr = winnr('#')
                                let winnr = winnr()
                                wincmd P
                                doautoall BufRead
                                setlocal nomodified
                                execute prev_winnr.'wincmd w'
                                execute winnr.'wincmd w'
                              endif
                            
                              if !buflisted
                                call unite#add_previewed_buffer_list(
                                    \ bufnr(unite#util#escape_file_searching(
                                    \       a:candidate.action__path)))
                              endif
                            endfunction"}}}
                            
    1              0.000008 let s:kind.action_table.mkdir = {
                                  \ 'description' : 'make this directory and parents directory',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.mkdir.func(candidate) "{{{
                              let dirname = input('New directory name: ',
                                    \ a:candidate.action__path, 'dir')
                              redraw
                            
                              if dirname == ''
                                echo 'Canceled.'
                                return
                              endif
                            
                              if filereadable(dirname) || isdirectory(dirname)
                                echo dirname . ' is already exists.'
                              else
                                call mkdir(dirname, 'p')
                              endif
                            endfunction"}}}
                            
    1              0.000008 let s:kind.action_table.rename = {
                                  \ 'description' : 'rename files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.rename.func(candidates) "{{{
                              for candidate in a:candidates
                                let filename = unite#util#substitute_path_separator(
                                      \ unite#util#expand(input(printf('New file name: %s -> ',
                                      \ candidate.action__path), candidate.action__path)))
                                redraw
                                if filename != '' && filename !=# candidate.action__path
                                  call unite#kinds#file#do_rename(candidate.action__path, filename)
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.backup = {
                                  \ 'description' : 'backup files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.backup.func(candidates) "{{{
                              for candidate in a:candidates
                                let filename = candidate.action__path . '.' . strftime('%y%m%d_%H%M')
                            
                                call unite#sources#file#copy_files(filename, [candidate])
                              endfor
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.wunix = {
                                  \ 'description' : 'write by unix fileformat',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.wunix.func(candidates) "{{{
                              let current_bufnr = bufnr('%')
                            
                              for candidate in a:candidates
                                let is_listed = buflisted(
                                      \ unite#util#escape_file_searching(candidate.action__path))
                                call s:kind.action_table.open.func([candidate])
                                write ++fileformat=mac
                                if is_listed
                                  call s:kind.action_table.open.func([candidate])
                                else
                                  let bufnr = bufnr(unite#util#escape_file_searching(candidate.action__path))
                                  silent execute bufnr 'bdelete'
                                endif
                              endfor
                            
                              execute 'buffer' current_bufnr
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.diff = {
                                  \ 'description' : 'diff with the other candidate or current buffer',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000004 function! s:kind.action_table.diff.func(candidates)
                              if !empty(filter(copy(a:candidates), 'isdirectory(v:val.action__path)'))
                                echo 'Invalid files.'
                                return
                              endif
                            
                              if len(a:candidates) == 1
                                " :vimdiff with current buffer.
                                let winnr = winnr()
                            
                                if &filetype ==# 'vimfiler'
                                  " Move to other window.
                                  wincmd w
                                endif
                            
                                try
                                  " Use selected candidates or current buffer.
                                  if &filetype ==# 'vimfiler'
                                    let file = get(vimfiler#get_marked_files(), 0, vimfiler#get_file())
                                    if empty(file) || isdirectory(file.action__path)
                                      echo 'Invalid candidate is detected.'
                                      return
                                    elseif len(vimfiler#get_marked_files()) > 1
                                      echo 'Too many candidates!'
                                      return
                                    endif
                            
                                    let path = file.action__path
                                  else
                                    let path = bufname('%')
                                  endif
                                finally
                                  if winnr() != winnr
                                    " Restore window.
                                    execute winnr.'wincmd w'
                                  endif
                                endtry
                            
                                execute 'tabnew' path
                            
                                let t:title = 'vimdiff'
                                call s:execute_command('vert diffsplit', a:candidates[0])
                              elseif len(a:candidates) == 2
                                " :vimdiff the other candidate.
                                call s:execute_command('tabnew', a:candidates[0])
                                let t:title = 'vimdiff'
                                call s:execute_command('vert diffsplit', a:candidates[1])
                              else
                                echo 'Too many candidates!'
                              endif
                            endfunction
                            
    1              0.000006 let s:kind.action_table.dirdiff = {
                                  \ 'description' : ':DirDiff with the other candidate',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.dirdiff.func(candidates)
                              if !exists(':DirDiff')
                                echo 'DirDiff.vim is not installed.'
                                return
                              endif
                            
                              if len(a:candidates) != 2
                                echo 'Candidates must be 2.'
                              else
                                " :DirDiff the other candidate.
                                tabnew
                                let t:title = 'DirDiff'
                                execute 'DirDiff' a:candidates[0].action__directory
                                      \ a:candidates[1].action__directory
                              endif
                            endfunction
                            
                            " For grep.
    1              0.000008 let s:kind.action_table.grep = {
                                  \   'description': 'grep this files',
                                  \   'is_quit': 1,
                                  \   'is_invalidate_cache': 1,
                                  \   'is_selectable': 1,
                                  \   'is_start' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.grep.func(candidates) "{{{
                              call unite#start_script([
                                    \ ['grep', map(copy(a:candidates),
                                    \ 'string(substitute(v:val.action__path, "/$", "", "g"))'),
                                    \ ]], { 'no_quit' : 1, 'no_empty' : 1 })
                            endfunction "}}}
                            
    1              0.000009 let s:kind.action_table.grep_directory = {
                                  \   'description': 'grep this directories',
                                  \   'is_quit': 1,
                                  \   'is_invalidate_cache': 1,
                                  \   'is_selectable': 1,
                                  \   'is_start' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.grep_directory.func(candidates) "{{{
                              call unite#start_script([
                                    \ ['grep', map(copy(a:candidates), 'string(v:val.action__directory)'),
                                    \ ]], { 'no_quit' : 1, 'no_empty' : 1 })
                            endfunction "}}}
                            
                            " For vimfiler.
    1              0.000007 let s:kind.action_table.vimfiler__move = {
                                  \ 'description' : 'move files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_selectable' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__move.func(candidates) "{{{
                              if !unite#util#input_yesno('Really move files?')
                                echo 'Canceled.'
                                return
                              endif
                            
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(), 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                if g:unite_kind_file_move_command == ''
                                  call unite#print_error("Please install mv.exe.")
                                  return 1
                                endif
                            
                                let context = unite#get_context()
                                let dest_dir = get(context, 'action__directory', '')
                                if dest_dir == ''
                                  let dest_dir = unite#util#input_directory(
                                        \ 'Input destination directory: ')
                                endif
                            
                                if dest_dir == ''
                                  return
                                elseif isdirectory(dest_dir) && dest_dir !~ '/$'
                                  let dest_dir .= '/'
                                endif
                                let context.action__directory = dest_dir
                            
                                let dest_drive = matchstr(dest_dir, '^\a\+\ze:')
                            
                                let candidates = []
                                for candidate in a:candidates
                                  let filename = candidate.action__path
                            
                                  if isdirectory(filename) && unite#util#is_windows()
                                        \ && matchstr(filename, '^\a\+\ze:') !=? dest_drive
                                    call s:move_to_other_drive(candidate, filename)
                                  else
                                    call add(candidates, candidate)
                                  endif
                                endfor
                            
                                if dest_dir =~ '^\h\w\+:'
                                  " Use protocol move method.
                                  let protocol = matchstr(dest_dir, '^\h\w\+')
                                  call unite#sources#{protocol}#move_files(
                                        \ dest_dir, candidates)
                                else
                                  call unite#kinds#file#do_action(
                                        \ candidates, dest_dir, 'move')
                                endif
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000010 let s:kind.action_table.move =
                                  \ deepcopy(s:kind.action_table.vimfiler__move)
    1              0.000003 let s:kind.action_table.move.is_listed = 1
    1              0.000002 function! s:kind.action_table.move.func(candidates) "{{{
                              return s:kind.action_table.vimfiler__move.func(a:candidates)
                            endfunction"}}}
                            
    1              0.000010 let s:kind.action_table.vimfiler__copy = {
                                  \ 'description' : 'copy files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_selectable' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000003 function! s:kind.action_table.vimfiler__copy.func(candidates) "{{{
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(), 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                if g:unite_kind_file_copy_file_command == ''
                                      \ || g:unite_kind_file_copy_directory_command == ''
                                  call unite#print_error("Please install cp.exe.")
                                  return 1
                                endif
                            
                                let context = unite#get_context()
                                let dest_dir = get(context, 'action__directory', '')
                                if dest_dir == ''
                                  let dest_dir = unite#util#input_directory(
                                        \ 'Input destination directory: ')
                                endif
                            
                                if dest_dir == ''
                                  return
                                elseif isdirectory(dest_dir) && dest_dir !~ '/$'
                                  let dest_dir .= '/'
                                endif
                            
                                if dest_dir =~ '^\h\w\+:'
                                  " Use protocol move method.
                                  let protocol = matchstr(dest_dir, '^\h\w\+')
                                  call unite#sources#{protocol}#copy_files(dest_dir, a:candidates)
                                else
                                  call unite#kinds#file#do_action(a:candidates, dest_dir, 'copy')
                                endif
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
    1              0.000003 function! s:check_copy_func(filename) "{{{
                              return isdirectory(a:filename) ?
                                    \ 'copy_directory' : 'copy_file'
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.copy = deepcopy(s:kind.action_table.vimfiler__copy)
    1              0.000003 let s:kind.action_table.copy.is_listed = 1
    1              0.000002 function! s:kind.action_table.copy.func(candidates) "{{{
                              return s:kind.action_table.vimfiler__copy.func(a:candidates)
                            endfunction"}}}
                            
    1              0.000008 let s:kind.action_table.vimfiler__delete = {
                                  \ 'description' : 'delete files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_selectable' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000003 function! s:kind.action_table.vimfiler__delete.func(candidates) "{{{
                              if g:unite_kind_file_delete_file_command == ''
                                    \ || g:unite_kind_file_delete_directory_command == ''
                                call unite#print_error("Please install rm.exe.")
                                return 1
                              endif
                            
                              if !unite#util#input_yesno('Really force delete files?')
                                echo 'Canceled.'
                                return
                              endif
                            
                              call unite#kinds#file#do_action(a:candidates, '', 'delete')
                            endfunction"}}}
    1              0.000003 function! s:check_delete_func(filename) "{{{
                              return isdirectory(a:filename) ?
                                    \ 'delete_directory' : 'delete_file'
                            endfunction"}}}
                            
    1              0.000008 let s:kind.action_table.vimfiler__rename = {
                                  \ 'description' : 'rename files',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__rename.func(candidate) "{{{
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(), 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                let context = unite#get_context()
                                let filename = has_key(context, 'action__filename') ?
                                      \ context.action__filename :
                                      \ input(printf('New file name: %s -> ',
                                      \       a:candidate.action__path), a:candidate.action__path)
                            
                                if !has_key(context, 'action__filename')
                                  redraw
                                endif
                            
                                if filename != '' && filename !=# a:candidate.action__path
                                  call unite#kinds#file#do_rename(a:candidate.action__path, filename)
                                endif
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.vimfiler__newfile = {
                                  \ 'description' : 'make this file',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__newfile.func(candidate) "{{{
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(),
                                    \   'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                let filenames = input('New files name(comma separated): ',
                                      \               '', 'file')
                                if filenames == ''
                                  redraw
                                  echo 'Canceled.'
                                  return
                                endif
                            
                                for filename in split(filenames, ',')
                                  lcd `=vimfiler_current_dir`
                            
                                  if filereadable(filename)
                                    redraw
                                    call unite#print_error(filename . ' is already exists.')
                                    continue
                                  endif
                            
                                  let dir = fnamemodify(filename, ':h')
                                  if dir != '' && !isdirectory(dir)
                                    " Auto create directory.
                                    call mkdir(dir, 'p')
                                  endif
                            
                                  let file = unite#sources#file#create_file_dict(
                                        \ filename, filename !~ '^\%(/\|\a\+:/\)')
                                  let file.source = 'file'
                            
                                  call writefile([], filename)
                            
                                  call unite#action#do(
                                        \ (vimfiler_current_dir == '' ? 'open' : g:vimfiler_edit_action),
                                        \ [file], { 'no_quit' : 1 })
                            
                                  execute 'doautocmd BufNewFile' fnameescape(filename)
                                endfor
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.vimfiler__shell = {
                                  \ 'description' : 'popup shell',
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000003 function! s:kind.action_table.vimfiler__shell.func(candidate) "{{{
                              if !exists(':VimShellPop')
                                shell
                                return
                              endif
                            
                              call vimshell#init#_start(a:candidate.action__directory,
                                    \ { 'popup' : 1, 'toggle' : 0 })
                            
                              let files = unite#get_context().vimfiler__files
                              if !empty(files)
                                call setline(line('.'), getline('.') . ' ' . join(files))
                                normal! l
                              endif
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.vimfiler__shellcmd = {
                                  \ 'description' : 'execute shell command',
                                  \ 'is_listed' : 0,
                                  \ 'is_start' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__shellcmd.func(candidate) "{{{
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(), 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                                let command = unite#get_context().vimfiler__command
                                let output = split(unite#util#system(command), '\n\|\r\n')
                            
                                if !empty(output)
                                  call unite#start_script([['output', output]])
                                endif
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000009 let s:kind.action_table.vimfiler__mkdir = {
                                  \ 'description' : 'make this directory and parents directory',
                                  \ 'is_quit' : 0,
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_listed' : 0,
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__mkdir.func(candidates) "{{{
                              let context = unite#get_context()
                              let vimfiler_current_dir = get(context, 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                let dirnames = split(input(
                                      \ 'New directory names(comma separated): ', '', 'dir'), ',')
                                redraw
                            
                                if empty(dirnames)
                                  echo 'Canceled.'
                                  return
                                endif
                            
                                for dirname in dirnames
                                  let dirname = unite#util#substitute_path_separator(
                                        \ fnamemodify(dirname, ':p'))
                            
                                  if filereadable(dirname) || isdirectory(dirname)
                                    redraw
                                    call unite#print_error(dirname . ' is already exists.')
                                    continue
                                  endif
                            
                                  call mkdir(dirname, 'p')
                                endfor
                            
                                " Move marked files.
                                if !get(context, 'vimfiler__is_dummy', 1) && len(dirnames) == 1
                                  call unite#sources#file#move_files(dirname, a:candidates)
                                endif
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.vimfiler__execute = {
                                  \ 'description' : 'open files with associated program',
                                  \ 'is_selectable' : 1,
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__execute.func(candidates) "{{{
                              let vimfiler_current_dir =
                                    \ get(unite#get_context(), 'vimfiler__current_directory', '')
                              if vimfiler_current_dir == ''
                                let vimfiler_current_dir = getcwd()
                              endif
                              let current_dir = getcwd()
                            
                              try
                                lcd `=vimfiler_current_dir`
                            
                                for candidate in a:candidates
                                  let path = candidate.action__path
                                  if unite#util#is_windows() && path =~ '^//'
                                    " substitute separator for UNC.
                                    let path = substitute(path, '/', '\\', 'g')
                                  endif
                            
                                  call s:System.open(path)
                                endfor
                              finally
                                if isdirectory(current_dir)
                                  lcd `=current_dir`
                                endif
                              endtry
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.vimfiler__write = {
                                  \ 'description' : 'save file',
                                  \ 'is_listed' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler__write.func(candidate) "{{{
                              let context = unite#get_context()
                              let lines = getline(context.vimfiler__line1, context.vimfiler__line2)
                            
                              if context.vimfiler__eventname ==# 'FileAppendCmd'
                                " Append.
                                let lines = readfile(a:candidate.action__path) + lines
                              endif
                              call writefile(lines, a:candidate.action__path)
                            endfunction"}}}
                            "}}}
                            
    1              0.000004 function! s:execute_command(command, candidate) "{{{
                              let dir = unite#util#path2directory(a:candidate.action__path)
                              " Auto make directory.
                              if dir !~ '^\a\+:' && !isdirectory(dir) && unite#util#input_yesno(
                                    \   printf('"%s" does not exist. Create?', dir))
                                call mkdir(dir, 'p')
                              endif
                            
                              call unite#util#smart_execute_command(
                                    \ a:command, unite#util#substitute_path_separator(
                                    \   fnamemodify(a:candidate.action__path, ':~:.')))
                            endfunction"}}}
    1              0.000003 function! s:external(command, dest_dir, src_files) "{{{
                              let dest_dir = a:dest_dir
                              if dest_dir =~ '[^:]/$'
                                " Delete last /.
                                let dest_dir = dest_dir[: -2]
                              endif
                            
                              let src_files = map(a:src_files, 'substitute(v:val, "[^:]\zs/$", "", "")')
                              let command_line = g:unite_kind_file_{a:command}_command
                            
                              " Substitute pattern.
                              let command_line = substitute(command_line,
                                    \'\$srcs\>', escape(join(
                                    \   map(src_files, '''"''.v:val.''"''')), '&'), 'g')
                              let command_line = substitute(command_line,
                                    \'\$dest\>', escape('"'.dest_dir.'"', '&'), 'g')
                              let command_line = escape(command_line, '`')
                            
                              let output = unite#util#system(command_line)
                            
                              return unite#util#get_last_status()
                            endfunction"}}}
    1              0.000003 function! s:input_overwrite_method(dest, src) "{{{
                              redraw
                              echo 'File is already exists!'
                              echo printf('dest: %s %d bytes %s', a:dest, getfsize(a:dest),
                                    \ strftime('%y/%m/%d %H:%M', getftime(a:dest)))
                              echo printf('src:  %s %d bytes %s', a:src, getfsize(a:src),
                                    \ strftime('%y/%m/%d %H:%M', getftime(a:src)))
                            
                              echo 'Please select overwrite method(Upper case is all).'
                              let method = ''
                              while method !~? '^\%(f\%[orce]\|t\%[ime]\|u\%[nderbar]\|n\%[o]\|r\%[ename]\)$'
                                " Retry.
                                let method = input('f[orce]/t[ime]/u[nderbar]/n[o]/r[ename] : ',
                                    \ '', 'customlist,unite#kinds#file#complete_overwrite_method')
                              endwhile
                            
                              redraw
                            
                              return method
                            endfunction"}}}
    1              0.000007 function! unite#kinds#file#complete_overwrite_method(arglead, cmdline, cursorpos) "{{{
                              return filter(['force', 'time', 'underbar', 'no', 'rename'],
                                    \ 'stridx(v:val, a:arglead) == 0')
                            endfunction"}}}
    1              0.000003 function! s:move_to_other_drive(candidate, filename) "{{{
                              " move command doesn't supported directory over drive move in Windows.
                              if g:unite_kind_file_copy_file_command == ''
                                    \ || g:unite_kind_file_copy_directory_command == ''
                                call unite#print_error("Please install cp.exe.")
                                return 1
                              elseif g:unite_kind_file_delete_file_command == ''
                                      \ || g:unite_kind_file_delete_directory_command == ''
                                call unite#print_error("Please install rm.exe.")
                                return 1
                              endif
                            
                              if s:kind.action_table.vimfiler__copy.func([a:candidate])
                                call unite#print_error('Failed file move: ' . a:filename)
                                return 1
                              endif
                            
                              if s:kind.action_table.vimfiler__delete.func([a:candidate])
                                call unite#print_error('Failed file delete: ' . a:filename)
                                return 1
                              endif
                            endfunction"}}}
    1              0.000003 function! s:check_over_write(dest_dir, filename, overwrite_method, is_reset_method) "{{{
                              let is_reset_method = a:is_reset_method
                              let dest_filename = a:dest_dir . fnamemodify(a:filename, ':t')
                              let is_continue = 0
                              let filename = fnamemodify(a:filename, ':t')
                              let overwrite_method = a:overwrite_method
                            
                              if filereadable(dest_filename) || isdirectory(dest_filename) "{{{
                                if overwrite_method == ''
                                  let overwrite_method =
                                        \ s:input_overwrite_method(dest_filename, a:filename)
                                  if overwrite_method =~ '^\u'
                                    " Same overwrite.
                                    let is_reset_method = 0
                                  endif
                                endif
                            
                                if overwrite_method =~? '^f'
                                  " Ignore.
                                elseif overwrite_method =~? '^t'
                                  if getftime(a:filename) <= getftime(dest_filename)
                                    let is_continue = 1
                                  endif
                                elseif overwrite_method =~? '^u'
                                  let filename .= '_'
                                elseif overwrite_method =~? '^n'
                                  if is_reset_method
                                    let overwrite_method = ''
                                  endif
                            
                                  let is_continue = 1
                                elseif overwrite_method =~? '^r'
                                  let filename =
                                        \ input(printf('New name: %s -> ', filename), filename, 'file')
                                endif
                            
                                if is_reset_method
                                  let overwrite_method = ''
                                endif
                              endif"}}}
                            
                              let dest_filename = a:dest_dir . fnamemodify(filename, ':t')
                            
                              if dest_filename ==#
                                    \ a:dest_dir . fnamemodify(a:filename, ':t')
                                let dest_filename = a:dest_dir
                              endif
                            
                              return [dest_filename, overwrite_method, is_reset_method, is_continue]
                            endfunction"}}}
    1              0.000004 function! unite#kinds#file#do_rename(old_filename, new_filename) "{{{
                              if a:old_filename ==# a:new_filename
                                return
                              endif
                            
                              if a:old_filename !=? a:new_filename &&
                                    \ (filereadable(a:new_filename) || isdirectory(a:new_filename))
                                " Failed.
                                call unite#print_error(
                                      \ printf('file: "%s" is already exists!', a:new_filename))
                                return
                              endif
                            
                              " Convert to relative path.
                              let old_filename = substitute(fnamemodify(a:old_filename, ':p'),
                                    \ '[/\\]$', '', '')
                              let directory = unite#util#substitute_path_separator(
                                    \ fnamemodify(old_filename, ':h'))
                              let current_dir_save = getcwd()
                              lcd `=directory`
                            
                              let hidden_save = &l:hidden
                              try
                                let old_filename = unite#util#substitute_path_separator(
                                      \ fnamemodify(a:old_filename, ':.'))
                                let new_filename = unite#util#substitute_path_separator(
                                      \ fnamemodify(a:new_filename, ':.'))
                            
                                let bufnr = bufnr(unite#util#escape_file_searching(old_filename))
                                if bufnr > 0
                                  setlocal hidden
                            
                                  " Buffer rename.
                                  let bufnr_save = bufnr('%')
                                  noautocmd execute 'buffer' bufnr
                                  saveas! `=new_filename`
                                  noautocmd execute 'buffer' bufnr_save
                                endif
                            
                                if rename(old_filename, new_filename)
                                  call unite#print_error(
                                        \ printf('Failed file rename: "%s" to "%s".',
                                        \   a:old_filename, a:new_filename))
                                endif
                              finally
                                " Restore path.
                                if isdirectory(current_dir_save)
                                  lcd `=current_dir_save`
                                endif
                                let &l:hidden = hidden_save
                              endtry
                            endfunction"}}}
    1              0.000002 function! s:filename2candidate(filename) "{{{
                              return {
                                    \ 'action__directory' :
                                    \       unite#util#path2directory(a:filename),
                                    \ 'action__path' : a:filename,
                                    \ }
                            endfunction"}}}
                            
    1              0.000004 function! unite#kinds#file#do_action(candidates, dest_dir, action_name) "{{{
                              let overwrite_method = ''
                              let is_reset_method = 1
                            
                              let cnt = 1
                              let max = len(a:candidates)
                            
                              echo ''
                              redraw
                            
                              for candidate in a:candidates
                                let filename = candidate.action__path
                            
                                if a:action_name == 'move' || a:action_name == 'copy'
                                  " Overwrite check.
                                  let [dest_filename, overwrite_method,
                                        \ is_reset_method, is_continue] =
                                        \ s:check_over_write(a:dest_dir, filename,
                                        \    overwrite_method, is_reset_method)
                                  if is_continue
                                    let cnt += 1
                                    continue
                                  endif
                                else
                                  let dest_filename = ''
                                endif
                            
                                " Print progress.
                                echo printf('%d%% %s %s',
                                      \ ((cnt*100) / max), a:action_name,
                                      \ (filename . (dest_filename == '' ? '' :
                                      \              ' -> ' . dest_filename)))
                                redraw
                            
                                if a:action_name == 'delete'
                                      \ && g:unite_kind_file_use_trashbox && unite#util#is_windows()
                                      \ && unite#util#has_vimproc() && exists('*vimproc#delete_trash')
                                  " Environment check.
                                  let ret = vimproc#delete_trash(filename)
                                  if ret
                                    call unite#print_error(printf('Failed file %s: %s',
                                          \ a:action_name, filename))
                                    call unite#print_error(printf('Error code is %d', ret))
                                  endif
                                else
                                  let command = a:action_name
                            
                                  if a:action_name ==# 'copy'
                                    let command = s:check_copy_func(filename)
                                  elseif a:action_name ==# 'delete'
                                    let command = s:check_delete_func(filename)
                                  endif
                            
                                  if s:external(command, dest_filename, [filename])
                                    call unite#print_error(printf('Failed file %s: %s',
                                          \ a:action_name, filename))
                                  endif
                                endif
                            
                                let cnt += 1
                              endfor
                            
                              echo ''
                              redraw
                            endfunction"}}}
                            
    1              0.000003 function! s:SID_PREFIX()
                              return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
                            endfunction
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/vital/_b6a796b/System/File.vim
Sourced 1 time
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
                            " Utilities for file copy/move/mkdir/etc.
                            
    1              0.000026 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000010 let s:is_unix = has('unix')
    1              0.000018 let s:is_windows = has("win16") || has("win95") || has("win32") || has("win64")
    1              0.000007 let s:is_cygwin = has('win32unix')
    1              0.000026 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
                            
                            " Open a file.
    1              0.000008 function! s:open(filename) "{{{
                              let filename = fnamemodify(a:filename, ':p')
                            
                              " Detect desktop environment.
                              if s:is_windows
                                " For URI only.
                                let filename = iconv(filename, &encoding, 'char')
                                silent execute '!start rundll32 url.dll,FileProtocolHandler' filename
                              elseif s:is_cygwin
                                " Cygwin.
                                call system(printf('%s %s', 'cygstart',
                                      \ shellescape(filename)))
                              elseif executable('xdg-open')
                                " Linux.
                                call system(printf('%s %s &', 'xdg-open',
                                      \ shellescape(filename)))
                              elseif exists('$KDE_FULL_SESSION') && $KDE_FULL_SESSION ==# 'true'
                                " KDE.
                                call system(printf('%s %s &', 'kioclient exec',
                                      \ shellescape(filename)))
                              elseif exists('$GNOME_DESKTOP_SESSION_ID')
                                " GNOME.
                                call system(printf('%s %s &', 'gnome-open',
                                      \ shellescape(filename)))
                              elseif executable('exo-open')
                                " Xfce.
                                call system(printf('%s %s &', 'exo-open',
                                      \ shellescape(filename)))
                              elseif s:is_mac && executable('open')
                                " Mac OS.
                                call system(printf('%s %s &', 'open',
                                      \ shellescape(filename)))
                              else
                                " Give up.
                                throw 'Not supported.'
                              endif
                            endfunction "}}}
                            
                            
                            " Move a file.
                            " Dispatch s:move_exe() or s:move_vim().
    1              0.000005 function! s:move(src, dest) "{{{
                              if executable('mv')
                                return s:move_exe(a:src, a:dest)
                              else
                                return s:move_vim(a:src, a:dest)
                              endif
                            endfunction "}}}
                            
                            " Move a file.
                            " Implemented by external program.
                            " TODO: Support non-*nix like system.
    1              0.000004 function! s:move_exe(src, dest)
                              if !executable('mv') | return 0 | endif
                              silent execute '!mv' shellescape(a:src) shellescape(a:dest)
                              if v:shell_error
                                return 0
                              endif
                              return 1
                            endfunction
                            
                            " Move a file.
                            " Implemented by pure vimscript.
    1              0.000004 function! s:move_vim(src, dest) "{{{
                              return !rename(a:src, a:dest)
                            endfunction "}}}
                            
                            " Copy a file.
                            " Dispatch s:copy_exe() or s:copy_vim().
    1              0.000005 function! s:copy(src, dest) "{{{
                              if executable('cp')
                                return s:copy_exe(a:src, a:dest)
                              else
                                return s:copy_vim(a:src, a:dest)
                              endif
                            endfunction "}}}
                            
                            " Copy a file.
                            " Implemented by external program.
                            " TODO: Support non-*nix like system.
    1              0.000004 function! s:copy_exe(src, dest)
                              if !executable('cp') | return 0 | endif
                              silent execute '!cp' shellescape(a:src) shellescape(a:dest)
                              if v:shell_error
                                return 0
                              endif
                              return 1
                            endfunction
                            
                            " Copy a file.
                            " Implemented by pure vimscript.
    1              0.000003 function! s:copy_vim(src, dest) "{{{
                              let ret = writefile(readfile(a:src, "b"), a:dest, "b")
                              if ret == -1
                                return 0
                              endif
                              return 1
                            endfunction "}}}
                            
                            " mkdir() but does not throw an exception.
                            " Returns true if success.
                            " Returns false if failure.
    1              0.000003 function! s:mkdir_nothrow(...) "{{{
                              silent! return call('mkdir', a:000)
                            endfunction "}}}
                            
                            
                            " Delete a file/directory.
    1              0.000003 if s:is_unix
    1              0.000004   function! s:rmdir(path, ...)
                                let flags = a:0 ? a:1 : ''
                                let cmd = flags =~# 'r' ? 'rm -r' : 'rmdir'
                                let cmd .= flags =~# 'f' && cmd ==# 'rm -r' ? ' -f' : ''
                                let ret = system(cmd . ' ' . shellescape(a:path))
                                if v:shell_error
                                  throw substitute(iconv(ret, 'char', &encoding), '\n', '', 'g')
                                endif
                              endfunction
                            
    1              0.000002 elseif s:is_windows
                              function! s:rmdir(path, ...)
                                let flags = a:0 ? a:1 : ''
                                if &shell =~? "sh$"
                                  let cmd = flags =~# 'r' ? 'rm -r' : 'rmdir'
                                  let cmd .= flags =~# 'f' && cmd ==# 'rm -r' ? ' -f' : ''
                                  let ret = system(cmd . ' ' . shellescape(a:path))
                                else
                                  " 'f' flag does not make sense.
                                  let cmd = 'rmdir /Q'
                                  let cmd .= flags =~# 'r' ? ' /S' : ''
                                  let ret = system(cmd . ' "' . a:path . '"')
                                endif
                                if v:shell_error
                                  throw substitute(iconv(ret, 'char', &encoding), '\n', '', 'g')
                                endif
                              endfunction
                            
                            else
                              function! s:rmdir(path, ...)
                                throw 'vital: System.File.rmdir(): your platform is not supported'
                              endfunction
                            endif
                            
                            
    1              0.000022 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/openable.vim
Sourced 1 time
Total time:   0.000334
 Self time:   0.000282

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: openable.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " Variables  "{{{
    1   0.000031   0.000010 call unite#util#set_default('g:unite_kind_openable_persist_open_blink_time', '250m')
    1   0.000023   0.000007 call unite#util#set_default('g:unite_kind_openable_cd_command', 'cd')
    1   0.000021   0.000006 call unite#util#set_default('g:unite_kind_openable_lcd_command', 'lcd')
                            "}}}
    1              0.000005 function! unite#kinds#openable#define() "{{{
                              return s:kind
                            endfunction"}}}
                            
    1              0.000007 let s:kind = {
                                  \ 'name' : 'openable',
                                  \ 'action_table': {},
                                  \}
                            
                            " Actions "{{{
    1              0.000007 let s:kind.action_table.tabopen = {
                                  \ 'description' : 'tabopen items',
                                  \ 'is_selectable' : 1,
                                  \ 'is_tab' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.tabopen.func(candidates) "{{{
                              for candidate in a:candidates
                                tabnew
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.tabdrop = {
                                  \ 'description' : 'open files by ":tab drop" command',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.tabdrop.func(candidates) "{{{
                              let bufpath = unite#util#substitute_path_separator(expand('%:p'))
                            
                              for candidate in a:candidates
                                if bufpath !=# candidate.action__path
                                  call unite#util#smart_execute_command('tab drop',
                                        \ candidate.action__path)
                            
                                  call unite#remove_previewed_buffer_list(
                                        \ bufnr(unite#util#escape_file_searching(
                                        \       candidate.action__path)))
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.switch = {
                                  \ 'description' : 'switch files by ":sbuffer" command',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.switch.func(candidates) "{{{
                              let bufpath = unite#util#substitute_path_separator(expand('%:p'))
                            
                              for candidate in a:candidates
                                if bufpath !=# candidate.action__path
                                  call unite#util#smart_execute_command('sbuffer',
                                        \ candidate.action__path)
                            
                                  call unite#remove_previewed_buffer_list(
                                        \ bufnr(unite#util#escape_file_searching(
                                        \       candidate.action__path)))
                                endif
                              endfor
                            endfunction"}}}
                            
                            
    1              0.000005 let s:kind.action_table.split = {
                                  \ 'description' : 'horizontal split open items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.split.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('split')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.vsplit = {
                                  \ 'description' : 'vertical split open items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.vsplit.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('vsplit')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.left = {
                                  \ 'description' : 'vertical left split items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.left.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('leftabove vsplit')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.right = {
                                  \ 'description' : 'vertical right split open items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.right.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('rightbelow vsplit')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.above = {
                                  \ 'description' : 'horizontal above split open items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.above.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('leftabove split')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.below = {
                                  \ 'description' : 'horizontal below split open items',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.below.func(candidates) "{{{
                              for candidate in a:candidates
                                call unite#util#command_with_restore_cursor('rightbelow split')
                                call unite#take_action('open', candidate)
                              endfor
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.persist_open = {
                                  \ 'description' : 'persistent open',
                                  \ 'is_quit'     : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.persist_open.func(candidate) "{{{
                              let unite = unite#get_current_unite()
                            
                              let current_winnr = winnr()
                            
                              let winnr = bufwinnr(unite.prev_bufnr)
                              if winnr < 0
                                let winnr = unite.prev_winnr
                              endif
                              if winnr == winnr() || winnr < 0
                                call unite#util#command_with_restore_cursor('new')
                              else
                                execute winnr 'wincmd w'
                              endif
                              let unite.prev_winnr = winnr()
                            
                              call unite#take_action('open', a:candidate)
                              let unite.prev_bufnr = bufnr('%')
                            
                              if g:unite_kind_openable_persist_open_blink_time != ''
                                normal! V
                                redraw!
                                execute 'sleep ' . g:unite_kind_openable_persist_open_blink_time
                                execute "normal! \<ESC>"
                              endif
                            
                              let unite_winnr = bufwinnr(unite.bufnr)
                              if unite_winnr < 0
                                let unite_winnr = current_winnr
                              endif
                              if unite_winnr > 0
                                execute unite_winnr 'wincmd w'
                              endif
                            endfunction"}}}
                            
                            "}}}
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/common.vim
Sourced 1 time
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: common.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 11 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000005 function! unite#kinds#common#define() "{{{
                              return s:kind
                            endfunction"}}}
                            
    1              0.000008 let s:kind = {
                                  \ 'name' : 'common',
                                  \ 'default_action' : 'nop',
                                  \ 'action_table': {},
                                  \ 'parents': [],
                                  \}
                            
                            " Actions "{{{
    1              0.000007 let s:kind.action_table.nop = {
                                  \ 'description' : 'no operation',
                                  \ }
    1              0.000003 function! s:kind.action_table.nop.func(candidate) "{{{
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.yank = {
                                  \ 'description' : 'yank word or text',
                                  \ 'is_selectable' : 1,
                                  \ 'is_quit' : 0,
                                  \ }
    1              0.000003 function! s:kind.action_table.yank.func(candidates) "{{{
                              let text = join(map(copy(a:candidates),
                                    \ 's:get_candidate_text(v:val)'), "\n")
                              let @" = text
                              echo 'Yanked: ' . text
                            
                              if has('clipboard')
                                let @* = text
                              endif
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.yank_escape = {
                                  \ 'description' : 'yank escaped word or text',
                                  \ }
    1              0.000003 function! s:kind.action_table.yank_escape.func(candidate) "{{{
                              let @" = escape(s:get_candidate_text(a:candidate), " *?[{`$\\%#\"|!<>")
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.ex = {
                                  \ 'description' : 'insert candidates into command line',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.ex.func(candidates) "{{{
                              " Result is ':| {candidate}', here '|' means the cursor position.
                              call feedkeys(printf(": %s\<C-b>",
                                    \ join(map(map(copy(a:candidates),
                                    \ "has_key(v:val, 'action__path') ? v:val.action__path : v:val.word"),
                                    \ 'escape(v:val, " *?[{`$\\%#\"|!<>")'))), 'n')
                            endfunction"}}}
                            
    1              0.000004 let s:kind.action_table.insert = {
                                  \ 'description' : 'insert word or text',
                                  \ }
    1              0.000002 function! s:kind.action_table.insert.func(candidate) "{{{
                              call unite#kinds#common#insert_word(s:get_candidate_text(a:candidate),
                                    \ { 'regtype' : get(a:candidate, 'action__regtype', 'v')})
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.insert_directory = {
                                  \ 'description' : 'insert directory',
                                  \ }
    1              0.000002 function! s:kind.action_table.insert_directory.func(candidate) "{{{
                              let context = unite#get_current_unite().context
                            
                              if has_key(a:candidate,'action__directory')
                                  let directory = a:candidate.action__directory
                              elseif has_key(a:candidate, 'action__path')
                                  let directory = unite#util#substitute_path_separator(
                                        \ fnamemodify(a:candidate.action__path, ':p:h'))
                              elseif has_key(a:candidate, 'word') && isdirectory(a:candidate.word)
                                  let directory = a:candidate.word
                              else
                                  return
                              endif
                            
                              call unite#kinds#common#insert_word(directory)
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.preview = {
                                  \ 'description' : 'preview word',
                                  \ 'is_quit' : 0,
                                  \ }
    1              0.000002 function! s:kind.action_table.preview.func(candidate) "{{{
                              redraw
                              echo s:get_candidate_text(a:candidate)
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.echo = {
                                  \ 'description' : 'echo candidates for debug',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.echo.func(candidates) "{{{
                              echomsg string(a:candidates)
                            endfunction"}}}
                            "}}}
                            
    1              0.000005 function! unite#kinds#common#insert_word(word, ...) "{{{
                              let unite = unite#get_current_unite()
                              let context = unite.context
                              let opt = get(a:000, 0, {})
                              let col = get(opt, 'col', context.col)
                              let regtype = get(opt, 'regtype', 'v')
                            
                              if !context.complete
                                " Paste.
                                let old_reg = [getreg('"'), getregtype('"')]
                            
                                call setreg('"', a:word, regtype)
                                try
                                  execute 'normal! ""'.(
                                        \ regtype !=# 'v' || (col('$') - col('.') <= 1) ? 'p' : 'P')
                                finally
                                  call setreg('"', old_reg[0], old_reg[1])
                                endtry
                            
                                " Open folds.
                                normal! zv
                            
                                return
                              endif
                            
                              let cur_text = col < 0 ? '' :
                                    \ matchstr(getline('.'), '^.*\%' . col . 'c.')
                            
                              let next_line = getline('.')[context.col-1 :]
                              call setline(line('.'),
                                    \ split(cur_text . a:word . next_line,
                                    \            '\n\|\r\n'))
                              let next_col = len(cur_text)+len(a:word)+1
                              call cursor('', next_col)
                            
                              if next_col < col('$')
                                startinsert
                              else
                                startinsert!
                              endif
                            endfunction"}}}
    1              0.000004 function! s:get_candidate_text(candidate) "{{{
                              return get(a:candidate, 'action__text', a:candidate.word)
                            endfunction"}}}
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/cdable.vim
Sourced 1 time
Total time:   0.000417
 Self time:   0.000417

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: cdable.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 Nov 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000014 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000005 function! unite#kinds#cdable#define() "{{{
                              return s:kind
                            endfunction"}}}
                            
    1              0.000008 let s:kind = {
                                  \ 'name' : 'cdable',
                                  \ 'action_table' : {},
                                  \ 'alias_table' : { 'edit' : 'narrow' },
                                  \}
                            
                            " Actions "{{{
    1              0.000006 let s:kind.action_table.cd = {
                                  \ 'description' : 'change current directory',
                                  \ }
    1              0.000002 function! s:kind.action_table.cd.func(candidate) "{{{
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              if &filetype ==# 'vimfiler' || &filetype ==# 'vimshell'
                                call s:external_cd(a:candidate)
                              elseif a:candidate.action__directory != ''
                                execute g:unite_kind_openable_cd_command '`=a:candidate.action__directory`'
                              endif
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.lcd = {
                                  \ 'description' : 'change window local current directory',
                                  \ }
    1              0.000002 function! s:kind.action_table.lcd.func(candidate) "{{{
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              if &filetype ==# 'vimfiler' || &filetype ==# 'vimshell'
                                call s:external_cd(a:candidate)
                              elseif a:candidate.action__directory != ''
                                execute g:unite_kind_openable_lcd_command '`=a:candidate.action__directory`'
                              endif
                            endfunction"}}}
                            
    1              0.000006 let s:kind.action_table.project_cd = {
                                  \ 'description' : 'change current directory to project directory',
                                  \ }
    1              0.000002 function! s:kind.action_table.project_cd.func(candidate) "{{{
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              if a:candidate.action__directory == ''
                                " Ignore.
                                return
                              endif
                            
                              let directory = unite#util#path2project_directory(
                                    \ a:candidate.action__directory)
                            
                              if isdirectory(directory)
                                let candidate = copy(a:candidate)
                                let candidate.action__directory = directory
                                call s:kind.action_table.cd.func(candidate)
                              endif
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.tabnew_cd = {
                                  \ 'description' : 'open a new tab page here',
                                  \ 'is_tab' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.tabnew_cd.func(candidate) "{{{
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              if &filetype ==# 'vimfiler' || &filetype ==# 'vimshell'
                                tabnew | call s:external_cd(a:candidate)
                              elseif a:candidate.action__directory != ''
                                tabnew | execute g:unite_kind_openable_cd_command '`=a:candidate.action__directory`'
                              endif
                            endfunction"}}}
                            
    1              0.000007 let s:kind.action_table.narrow = {
                                  \ 'description' : 'narrowing candidates by directory name',
                                  \ 'is_quit' : 0,
                                  \ 'is_start' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.narrow.func(candidate) "{{{
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              call unite#start_temporary([['file'], ['file/new']])
                              let directory = isdirectory(a:candidate.word) ?
                                    \ a:candidate.word : a:candidate.action__directory
                              if directory[-1:] != '/'
                                let directory .= '/'
                              endif
                              call unite#mappings#narrowing(directory)
                            endfunction"}}}
                            
    1              0.000004 let s:kind.action_table.vimshell = {
                                  \ 'description' : 'open vimshell buffer here',
                                  \ }
    1              0.000003 function! s:kind.action_table.vimshell.func(candidate) "{{{
                              if !exists(':VimShell')
                                echo 'vimshell is not installed.'
                                return
                              endif
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              execute 'VimShell' escape(a:candidate.action__directory, '\ ')
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.tabvimshell = {
                                  \ 'description' : 'tabopen vimshell buffer here',
                                  \ 'is_tab' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.tabvimshell.func(candidate) "{{{
                              if !exists(':VimShellTab')
                                echo 'vimshell is not installed.'
                                return
                              endif
                            
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              execute 'VimShellTab' escape(a:candidate.action__directory, '\ ')
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.vimfiler = {
                                  \ 'description' : 'open vimfiler buffer here',
                                  \ }
    1              0.000002 function! s:kind.action_table.vimfiler.func(candidate) "{{{
                              if !exists(':VimFilerCreate')
                                echo 'vimfiler is not installed.'
                                return
                              endif
                            
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              execute 'VimFilerCreate' escape(a:candidate.action__directory, '\ ')
                            
                              if has_key(a:candidate, 'action__path')
                                    \ && a:candidate.action__directory !=# a:candidate.action__path
                                " Move cursor.
                                call vimfiler#mappings#search_cursor(a:candidate.action__path)
                                call s:move_vimfiler_cursor(a:candidate)
                              endif
                            endfunction"}}}
                            
    1              0.000005 let s:kind.action_table.tabvimfiler = {
                                  \ 'description' : 'tabopen vimfiler buffer here',
                                  \ 'is_tab' : 1,
                                  \ }
    1              0.000002 function! s:kind.action_table.tabvimfiler.func(candidate) "{{{
                              if !exists(':VimFilerTab')
                                echo 'vimfiler is not installed.'
                                return
                              endif
                            
                              if !s:check_is_directory(a:candidate.action__directory)
                                return
                              endif
                            
                              execute 'VimFilerTab' escape(a:candidate.action__directory, '\ ')
                            
                              if has_key(a:candidate, 'action__path')
                                    \ && a:candidate.action__directory !=# a:candidate.action__path
                                " Move cursor.
                                call vimfiler#mappings#search_cursor(a:candidate.action__path)
                                call s:move_vimfiler_cursor(a:candidate)
                              endif
                            endfunction"}}}
                            
                            " For rec. "{{{
    1              0.000006 let s:cdable_action_rec = {
                                  \ 'description' : 'open this directory by file_rec source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000003 function! s:cdable_action_rec.func(candidate)
                              call unite#start_script([['file_rec', a:candidate.action__directory]])
                            endfunction
                            
    1              0.000006 let s:cdable_action_rec_parent = {
                                  \ 'description' : 'open parent directory by file_rec source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000002 function! s:cdable_action_rec_parent.func(candidate)
                              call unite#start_script([['file_rec', unite#util#substitute_path_separator(
                                    \ fnamemodify(a:candidate.action__directory, ':h'))
                                    \ ]])
                            endfunction
                            
    1              0.000005 let s:cdable_action_rec_project = {
                                  \ 'description' : 'open project directory by file_rec source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000002 function! s:cdable_action_rec_project.func(candidate)
                              call unite#start_script([['file_rec', unite#util#substitute_path_separator(
                                    \ unite#util#path2project_directory(a:candidate.action__directory))
                                    \ ]])
                            endfunction
                            
    1              0.000006 let s:cdable_action_rec_async = {
                                  \ 'description' : 'open this directory by file_rec/async source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000002 function! s:cdable_action_rec_async.func(candidate)
                              call unite#start_script([['file_rec/async', a:candidate.action__directory]])
                            endfunction
                            
    1              0.000006 let s:cdable_action_rec_parent_async = {
                                  \ 'description' : 'open parent directory by file_rec/async source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000002 function! s:cdable_action_rec_parent_async.func(candidate)
                              call unite#start_script([['file_rec/async', unite#util#substitute_path_separator(
                                    \ fnamemodify(a:candidate.action__directory, ':h'))
                                    \ ]])
                            endfunction
                            
    1              0.000006 let s:cdable_action_rec_project_async = {
                                  \ 'description' : 'open project directory by file_rec/async source',
                                  \ 'is_start' : 1,
                                  \}
                            
    1              0.000002 function! s:cdable_action_rec_project_async.func(candidate)
                              call unite#start_script([['file_rec/async', unite#util#substitute_path_separator(
                                    \ unite#util#path2project_directory(a:candidate.action__directory))
                                    \ ]])
                            endfunction
                            
    1              0.000005 let s:kind.action_table['rec'] =
                                  \ s:cdable_action_rec
    1              0.000005 let s:kind.action_table['rec_parent'] =
                                  \ s:cdable_action_rec_parent
    1              0.000004 let s:kind.action_table['rec_project'] =
                                  \ s:cdable_action_rec_project
    1              0.000004 let s:kind.action_table['rec/async'] =
                                  \ s:cdable_action_rec_async
    1              0.000004 let s:kind.action_table['rec_parent/async'] =
                                  \ s:cdable_action_rec_parent_async
    1              0.000005 let s:kind.action_table['rec_project/async'] =
                                  \ s:cdable_action_rec_project_async
    1              0.000003 unlet! s:cdable_action_rec
    1              0.000001 unlet! s:cdable_action_rec_async
    1              0.000002 unlet! s:cdable_action_rec_project
    1              0.000002 unlet! s:cdable_action_rec_project_async
    1              0.000001 unlet! s:cdable_action_rec_parent
    1              0.000002 unlet! s:cdable_action_rec_parent_async
                            "}}}
                            
                            
    1              0.000003 function! s:external_cd(candidate) "{{{
                              if &filetype ==# 'vimfiler'
                                call vimfiler#mappings#cd(a:candidate.action__directory)
                                call s:move_vimfiler_cursor(a:candidate)
                              elseif &filetype ==# 'vimshell'
                                execute 'VimShell' escape(a:candidate.action__directory, '\\ ')
                              endif
                            endfunction"}}}
    1              0.000002 function! s:move_vimfiler_cursor(candidate) "{{{
                              if &filetype !=# 'vimfiler'
                                return
                              endif
                            
                              if has_key(a:candidate, 'action__path')
                                    \ && a:candidate.action__directory !=# a:candidate.action__path
                                " Move cursor.
                                call vimfiler#mappings#search_cursor(a:candidate.action__path)
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! s:check_is_directory(directory)
                              if !isdirectory(a:directory)
                                let yesno = input(printf(
                                      \ 'Directory path "%s" is not exists. Create? : ', a:directory))
                                redraw
                                if yesno !~ '^y\%[es]$'
                                  echo 'Canceled.'
                                  return 0
                                endif
                            
                                call mkdir(a:directory, 'p')
                              endif
                            
                              return 1
                            endfunction
                            "}}}
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/uri.vim
Sourced 1 time
Total time:   0.002089
 Self time:   0.000113

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: uri.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 29 Jul 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000006 function! unite#kinds#uri#define() "{{{
                              return s:kind
                            endfunction"}}}
                            
    1   0.001988   0.000012 let s:System = unite#util#get_vital().import('System.File')
                            
    1              0.000006 let s:kind = {
                                  \ 'name' : 'uri',
                                  \ 'default_action' : 'start',
                                  \ 'action_table' : {},
                                  \}
                            
                            " Actions "{{{
    1              0.000006 let s:kind.action_table.start = {
                                  \ 'description' : 'open uri by browser',
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000003 function! s:kind.action_table.start.func(candidates) "{{{
                              for candidate in a:candidates
                                let path = has_key(candidate, 'action__uri') ?
                                      \ candidate.action__uri : candidate.action__path
                                if unite#util#is_windows() && path =~ '^//'
                                  " substitute separator for UNC.
                                  let path = substitute(path, '/', '\\', 'g')
                                endif
                            
                                call s:System.open(path)
                              endfor
                            endfunction"}}}
                            "}}}
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/kinds/jump_list.vim
Sourced 1 time
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: jump_list.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 28 Oct 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
                            " Variables  "{{{
    1              0.000006 if !exists('g:unite_kind_jump_list_after_jump_scroll')
    1              0.000004   let g:unite_kind_jump_list_after_jump_scroll = 25
    1              0.000001 else
                              let g:unite_kind_jump_list_after_jump_scroll =
                                    \ min([max([0, g:unite_kind_jump_list_after_jump_scroll]), 100])
                            endif
                            "}}}
                            
    1              0.000005 function! unite#kinds#jump_list#define() "{{{
                              let kind = {
                                    \ 'name' : 'jump_list',
                                    \ 'default_action' : 'open',
                                    \ 'action_table': {},
                                    \ 'alias_table' : { 'rename' : 'replace' },
                                    \ 'parents': ['openable'],
                                    \}
                            
                              " Actions "{{{
                              let kind.action_table.open = {
                                    \ 'description' : 'jump to this position',
                                    \ 'is_selectable' : 1,
                                    \ }
                              function! kind.action_table.open.func(candidates) "{{{
                                for candidate in a:candidates
                                  let bufnr = s:open(candidate)
                                  call s:jump(candidate, 0)
                            
                                  " Open folds.
                                  normal! zv
                                  call s:adjust_scroll(s:best_winline())
                            
                                  call unite#remove_previewed_buffer_list(bufnr)
                                endfor
                              endfunction"}}}
                            
                              let kind.action_table.preview = {
                                    \ 'description' : 'preview this position',
                                    \ 'is_quit' : 0,
                                    \ }
                              function! kind.action_table.preview.func(candidate) "{{{
                                let filename = s:get_filename(a:candidate)
                                let buflisted = buflisted(
                                      \ unite#util#escape_file_searching(filename))
                                let preview_windows = filter(range(1, winnr('$')),
                                      \ 'getwinvar(v:val, "&previewwindow") != 0')
                                if empty(preview_windows)
                                  noautocmd silent execute 'pedit!' fnameescape(filename)
                                  if !buflisted
                                    let prev_winnr = winnr('#')
                                    let winnr = winnr()
                                    wincmd P
                                    doautoall BufRead
                                    setlocal nomodified
                                    execute prev_winnr.'wincmd w'
                                    execute winnr.'wincmd w'
                                  endif
                                endif
                            
                                let prev_winnr = winnr('#')
                                let winnr = winnr()
                                wincmd P
                                let bufnr = s:open(a:candidate)
                                call s:jump(a:candidate, 1)
                                execute prev_winnr.'wincmd w'
                                execute winnr.'wincmd w'
                            
                                if !buflisted
                                  call unite#add_previewed_buffer_list(bufnr)
                                endif
                              endfunction"}}}
                            
                              let kind.action_table.highlight = {
                                    \ 'description' : 'highlight this position',
                                    \ 'is_quit' : 0,
                                    \ }
                              function! kind.action_table.highlight.func(candidate) "{{{
                                let candidate_winnr = bufwinnr(s:get_bufnr(a:candidate))
                            
                                if candidate_winnr > 0
                                  let unite = unite#get_current_unite()
                                  let context = unite.context
                                  let current_winnr = winnr()
                            
                                  if context.vertical 
                                      setlocal winfixwidth
                                  else 
                                      setlocal winfixheight
                                  endif
                            
                                  noautocmd execute candidate_winnr 'wincmd w'
                            
                                  call s:jump(a:candidate, 1)
                                  let unite_winnr = bufwinnr(unite.bufnr)
                                  if unite_winnr < 0
                                    let unite_winnr = current_winnr
                                  endif
                                  if unite_winnr > 0
                                    noautocmd execute unite_winnr 'wincmd w'
                                  endif
                                endif
                              endfunction"}}}
                            
                            
                              let kind.action_table.replace = {
                                    \ 'description' : 'replace with qfreplace',
                                    \ 'is_selectable' : 1,
                                    \ }
                              function! kind.action_table.replace.func(candidates) "{{{
                                if globpath(&runtimepath, 'autoload/qfreplace.vim') == ''
                                  echo 'qfreplace.vim is not installed.'
                                  return
                                endif
                            
                                let qflist = []
                                for candidate in a:candidates
                                  if has_key(candidate, 'action__line')
                                        \ && has_key(candidate, 'action__text')
                                    let filename = s:get_filename(candidate)
                                    call add(qflist, {
                                          \ 'filename' : filename,
                                          \ 'lnum' : candidate.action__line,
                                          \ 'text' : candidate.action__text,
                                          \ })
                                  endif
                                endfor
                            
                                if !empty(qflist)
                                  call setqflist(qflist)
                                  call qfreplace#start('')
                                endif
                              endfunction"}}}
                            
                              return kind
                            endfunction"}}}
                            
                            "}}}
                            
                            " Misc.
    1              0.000004 function! s:jump(candidate, is_highlight) "{{{
                              let line = get(a:candidate, 'action__line', 1)
                              let pattern = get(a:candidate, 'action__pattern', '')
                            
                              if line == ''
                                " Use default line number.
                                let line = 1
                              endif
                              if line !~ '^\d\+$'
                                call unite#print_error('unite: jump_list: Invalid action__line format.')
                                return
                              endif
                            
                              if !has_key(a:candidate, 'action__pattern')
                                " Jump to the line number.
                                let col = get(a:candidate, 'action__col', 0)
                                if col == 0
                                  if line('.') != line
                                    execute line
                                  endif
                                else
                                  call cursor(line, col)
                                endif
                            
                                call s:open_current_line(a:is_highlight)
                                return
                              endif
                            
                              " Jump by search().
                              let source = unite#get_sources(a:candidate.source)
                              if !(has_key(a:candidate, 'action__signature')
                                    \ && has_key(source, 'calc_signature'))
                                " Not found signature.
                                if line != '' && getline(line) =~# pattern
                                  if line('.') != line
                                    execute line
                                  endif
                                else
                                  call search(pattern, 'w')
                                endif
                            
                                call s:open_current_line(a:is_highlight)
                                return
                              endif
                            
                              call search(pattern, 'w')
                            
                              let lnum_prev = line('.')
                              call search(pattern, 'w')
                              let lnum = line('.')
                              if lnum != lnum_prev
                                " Detected same pattern lines!!
                                let start_lnum = lnum
                                while source.calc_signature(lnum) !=#
                                      \ a:candidate.action__signature
                                  call search(pattern, 'w')
                                  let lnum = line('.')
                                  if lnum == start_lnum
                                    " Not found.
                                    call unite#print_error(
                                          \ "unite: jump_list: Target position is not found.")
                                    call cursor(1, 1)
                                    return
                                  endif
                                endwhile
                              endif
                            
                              call s:open_current_line(a:is_highlight)
                            endfunction"}}}
                            
    1              0.000003 function! s:best_winline() "{{{
                              return max([1, winheight(0) * g:unite_kind_jump_list_after_jump_scroll / 100])
                            endfunction"}}}
                            
    1              0.000003 function! s:adjust_scroll(best_winline) "{{{
                              normal! zt
                              let save_cursor = getpos('.')
                              let winl = 1
                              " Scroll the cursor line down.
                              while winl <= a:best_winline
                                let winl_prev = winl
                                execute "normal! \<C-y>"
                                let winl = winline()
                                if winl == winl_prev
                                  break
                                end
                                let winl_prev = winl
                              endwhile
                              if winl > a:best_winline
                                execute "normal! \<C-e>"
                              endif
                              call setpos('.', save_cursor)
                            endfunction"}}}
                            
    1              0.000003 function! s:open_current_line(is_highlight) "{{{
                              normal! zv
                              normal! zz
                              if a:is_highlight
                                execute 'match Search /\%'.line('.').'l/'
                              endif
                            endfunction"}}}
                            
    1              0.000002 function! s:open(candidate) "{{{
                              let bufnr = s:get_bufnr(a:candidate)
                              if bufnr != bufnr('%')
                                if has_key(a:candidate, 'action__buffer_nr')
                                  silent execute 'buffer' bufnr
                                else
                                  call unite#util#smart_execute_command(
                                        \ 'edit!', unite#util#substitute_path_separator(
                                        \   fnamemodify(a:candidate.action__path, ':~:.')))
                                endif
                              endif
                            
                              return bufnr
                            endfunction"}}}
    1              0.000002 function! s:get_filename(candidate) "{{{
                              return has_key(a:candidate, 'action__path') ?
                                        \ a:candidate.action__path :
                                        \ bufname(a:candidate.action__buffer_nr)
                            endfunction"}}}
    1              0.000004 function! s:get_bufnr(candidate) "{{{
                              return has_key(a:candidate, 'action__buffer_nr') ?
                                    \ a:candidate.action__buffer_nr :
                                    \ bufnr(unite#util#escape_file_searching(
                                    \     a:candidate.action__path))
                            endfunction"}}}
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /usr/share/vim/vim73/ftplugin/ant.vim
Sourced 1 time
Total time:   0.001470
 Self time:   0.001271

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	ant
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000008 if exists("b:did_ftplugin") | finish | endif
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000013 let s:save_cpo = &cpo
    1              0.000011 set cpo-=C
                            
                            " Define some defaults in case the included ftplugins don't set them.
    1              0.000003 let s:undo_ftplugin = ""
    1              0.000005 let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
                            	    \	     "All Files (*.*)\t*.*\n"
                            
    1              0.000940 runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
    1              0.000007 let b:did_ftplugin = 1
                            
                            " Override our defaults if these were set by an included ftplugin.
    1              0.000005 if exists("b:undo_ftplugin")
    1              0.000003     let s:undo_ftplugin = b:undo_ftplugin
    1              0.000001 endif
    1              0.000003 if exists("b:browsefilter")
                                let s:browsefilter = b:browsefilter
                            endif
                            
                            " Change the :browse e filter to primarily show Ant-related files.
    1              0.000004 if has("gui_win32")
                                let b:browsefilter = "Build Files (build.xml)\tbuild.xml\n" .
                            		\	 "Java Files (*.java)\t*.java\n" .
                            		\	 "Properties Files (*.prop*)\t*.prop*\n" .
                            		\	 "Manifest Files (*.mf)\t*.mf\n" .
                            		\	 s:browsefilter
                            endif
                            
                            " Undo the stuff we changed.
    1              0.000004 let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin
                            
                            " Restore the saved compatibility options.
    1              0.000008 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /usr/share/vim/vim73/indent/ant.vim
Sourced 1 time
Total time:   0.000286
 Self time:   0.000218

count  total (s)   self (s)
                            " Vim indent file
                            " Language:    ANT files
                            " Maintainer:  David Fishburn <fishburn@ianywhere.com>
                            " Last Change: Thu May 15 2003 10:02:54 PM
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
                            endif
                            
                            " Use XML formatting rules
    1              0.000176 runtime! indent/xml.vim

SCRIPT  /usr/share/vim/vim73/syntax/ant.vim
Sourced 1 time
Total time:   0.004166
 Self time:   0.000563

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	ANT build file (xml)
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            " Last Change:	Tue Apr 27 13:05:59 CEST 2004
                            " Filenames:	build.xml
                            " $Id: ant.vim,v 1.1 2004/06/13 18:13:18 vimboss Exp $
                            
                            " Quit when a syntax file was already loaded
    1              0.000005 if exists("b:current_syntax")
                                finish
                            endif
                            
    1              0.000013 let s:ant_cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000176 runtime! syntax/xml.vim
                            
    1              0.000003 syn case ignore
                            
    1              0.000005 if !exists('*AntSyntaxScript')
    1              0.000003     fun AntSyntaxScript(tagname, synfilename)
                            	unlet b:current_syntax
                            	let s:include = expand("<sfile>:p:h").'/'.a:synfilename
                            	if filereadable(s:include)
                            	    exe 'syn include @ant'.a:tagname.' '.s:include
                            	else
                            	    exe 'syn include @ant'.a:tagname." $VIMRUNTIME/syntax/".a:synfilename
                            	endif
                            
                            	exe 'syn region ant'.a:tagname
                            		    \." start=#<script[^>]\\{-}language\\s*=\\s*['\"]".a:tagname."['\"]\\(>\\|[^>]*[^/>]>\\)#"
                            		    \.' end=#</script>#'
                            		    \.' fold'
                            		    \.' contains=@ant'.a:tagname.',xmlCdataStart,xmlCdataEnd,xmlTag,xmlEndTag'
                            		    \.' keepend'
                            	exe 'syn cluster xmlRegionHook add=ant'.a:tagname
                                endfun
    1              0.000001 endif
                            
                            " TODO: add more script languages here ?
    1              0.000063 call AntSyntaxScript('javascript', 'javascript.vim')
    1              0.000063 call AntSyntaxScript('jpython', 'python.vim')
                            
                            
    1              0.000007 syn cluster xmlTagHook add=antElement
                            
    1              0.000007 syn keyword antElement display WsdlToDotnet addfiles and ant antcall antstructure apply archives arg argument
    1              0.000006 syn keyword antElement display assertions attrib attribute available basename bcc blgenclient bootclasspath
    1              0.000005 syn keyword antElement display borland bottom buildnumber buildpath buildpathelement bunzip2 bzip2 cab
    1              0.000006 syn keyword antElement display catalogpath cc cccheckin cccheckout cclock ccmcheckin ccmcheckintask ccmcheckout
    1              0.000005 syn keyword antElement display ccmcreatetask ccmkattr ccmkbl ccmkdir ccmkelem ccmklabel ccmklbtype
    1              0.000006 syn keyword antElement display ccmreconfigure ccrmtype ccuncheckout ccunlock ccupdate checksum chgrp chmod
    1              0.000005 syn keyword antElement display chown classconstants classes classfileset classpath commandline comment
    1              0.000007 syn keyword antElement display compilerarg compilerclasspath concat concatfilter condition copy copydir
    1              0.000006 syn keyword antElement display copyfile coveragepath csc custom cvs cvschangelog cvspass cvstagdiff cvsversion
    1              0.000006 syn keyword antElement display daemons date defaultexcludes define delete deletecharacters deltree depend
    1              0.000007 syn keyword antElement display depends dependset depth description different dirname dirset disable dname
    1              0.000006 syn keyword antElement display doclet doctitle dtd ear echo echoproperties ejbjar element enable entity entry
    1              0.000006 syn keyword antElement display env equals escapeunicode exclude excludepackage excludesfile exec execon
    1              0.000006 syn keyword antElement display existing expandproperties extdirs extension extensionSet extensionset factory
    1              0.000005 syn keyword antElement display fail filelist filename filepath fileset filesmatch filetokenizer filter
    1              0.000006 syn keyword antElement display filterchain filterreader filters filterset filtersfile fixcrlf footer format
    1              0.000007 syn keyword antElement display from ftp generic genkey get gjdoc grant group gunzip gzip header headfilter http
    1              0.000006 syn keyword antElement display ignoreblank ilasm ildasm import importtypelib include includesfile input iplanet
    1              0.000004 syn keyword antElement display iplanet-ejbc isfalse isreference isset istrue jar jarlib-available
    1              0.000006 syn keyword antElement display jarlib-manifest jarlib-resolve java javac javacc javadoc javadoc2 jboss jdepend
    1              0.000005 syn keyword antElement display jjdoc jjtree jlink jonas jpcoverage jpcovmerge jpcovreport jsharpc jspc
    1              0.000005 syn keyword antElement display junitreport jvmarg lib libfileset linetokenizer link loadfile loadproperties
    1              0.000007 syn keyword antElement display location macrodef mail majority manifest map mapper marker mergefiles message
    1              0.000006 syn keyword antElement display metainf method mimemail mkdir mmetrics modified move mparse none not options or
    1              0.000005 syn keyword antElement display os outputproperty package packageset parallel param patch path pathconvert
    1              0.000007 syn keyword antElement display pathelement patternset permissions prefixlines present presetdef project
    1              0.000005 syn keyword antElement display property propertyfile propertyref propertyset pvcs pvcsproject record reference
    1              0.000005 syn keyword antElement display regexp rename renameext replace replacefilter replaceregex replaceregexp
    1              0.000005 syn keyword antElement display replacestring replacetoken replacetokens replacevalue replyto report resource
    1              0.000006 syn keyword antElement display revoke rmic root rootfileset rpm scp section selector sequential serverdeploy
    1              0.000006 syn keyword antElement display setproxy signjar size sleep socket soscheckin soscheckout sosget soslabel source
    1              0.000006 syn keyword antElement display sourcepath sql src srcfile srcfilelist srcfiles srcfileset sshexec stcheckin
    1              0.000005 syn keyword antElement display stcheckout stlabel stlist stringtokenizer stripjavacomments striplinebreaks
    1              0.000006 syn keyword antElement display striplinecomments style subant substitution support symlink sync sysproperty
    1              0.000006 syn keyword antElement display syspropertyset tabstospaces tag taglet tailfilter tar tarfileset target
    1              0.000006 syn keyword antElement display targetfile targetfilelist targetfileset taskdef tempfile test testlet text title
    1              0.000006 syn keyword antElement display to token tokenfilter touch transaction translate triggers trim tstamp type
    1              0.000005 syn keyword antElement display typedef unjar untar unwar unzip uptodate url user vbc vssadd vsscheckin
    1              0.000005 syn keyword antElement display vsscheckout vsscp vsscreate vssget vsshistory vsslabel waitfor war wasclasspath
    1              0.000005 syn keyword antElement display webapp webinf weblogic weblogictoplink websphere whichresource wlclasspath
    1              0.000005 syn keyword antElement display wljspc wsdltodotnet xmlcatalog xmlproperty xmlvalidate xslt zip zipfileset
    1              0.000002 syn keyword antElement display zipgroupfileset
                            
    1              0.000006 hi def link antElement Statement
                            
    1              0.000003 let b:current_syntax = "ant"
                            
    1              0.000009 let &cpo = s:ant_cpo_save
    1              0.000002 unlet s:ant_cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim73/syntax/javascript.vim
Sourced 1 time
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2010 Mar 25
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000005 if !exists("main_syntax")
    1              0.000003   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
    1              0.000005   let main_syntax = 'javascript'
    1              0.000002 endif
                            
                            " Drop fold if it set but vim doesn't support it.
    1              0.000002 if version < 600 && exists("javaScript_fold")
                              unlet javaScript_fold
                            endif
                            
                            
    1              0.000012 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    1              0.000012 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    1              0.000012 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    1              0.000012 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    1              0.000013 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    1              0.000015 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000014 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            
    1              0.000008 syn match   javaScriptSpecialCharacter "'\\.'"
    1              0.000012 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    1              0.000020 syn region  javaScriptRegexpString     start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gi]\{0,2\}\s*$+ end=+/[gi]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
                            
    1              0.000008 syn keyword javaScriptConditional	if else switch
    1              0.000035 syn keyword javaScriptRepeat		while for do in
    1              0.000009 syn keyword javaScriptBranch		break continue
    1              0.000010 syn keyword javaScriptOperator		new delete instanceof typeof
    1              0.000010 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    1              0.000007 syn keyword javaScriptStatement		return with
    1              0.000008 syn keyword javaScriptBoolean		true false
    1              0.000007 syn keyword javaScriptNull		null undefined
    1              0.000008 syn keyword javaScriptIdentifier	arguments this var let
    1              0.000008 syn keyword javaScriptLabel		case default
    1              0.000008 syn keyword javaScriptException		try catch finally throw
    1              0.000014 syn keyword javaScriptMessage		alert confirm prompt status
    1              0.000012 syn keyword javaScriptGlobal		self window top parent
    1              0.000010 syn keyword javaScriptMember		document event location 
    1              0.000009 syn keyword javaScriptDeprecated	escape unescape
    1              0.000019 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
    1              0.000004 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
    1              0.000009     syn keyword javaScriptFunction	function
    1              0.000010     syn match	javaScriptBraces	   "[{}\[\]]"
    1              0.000009     syn match	javaScriptParens	   "[()]"
    1              0.000001 endif
                            
    1              0.000003 syn sync fromstart
    1              0.000002 syn sync maxlines=100
                            
    1              0.000004 if main_syntax == "javascript"
    1              0.000003   syn sync ccomment javaScriptComment
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000003 if version >= 508 || !exists("did_javascript_syn_inits")
    1              0.000002   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000010     command -nargs=+ HiLink hi def link <args>
    1              0.000021   endif
    1              0.000010   HiLink javaScriptComment		Comment
    1              0.000010   HiLink javaScriptLineComment		Comment
    1              0.000007   HiLink javaScriptCommentTodo		Todo
    1              0.000006   HiLink javaScriptSpecial		Special
    1              0.000009   HiLink javaScriptStringS		String
    1              0.000007   HiLink javaScriptStringD		String
    1              0.000010   HiLink javaScriptCharacter		Character
    1              0.000004   HiLink javaScriptSpecialCharacter	javaScriptSpecial
    1              0.000007   HiLink javaScriptNumber		javaScriptValue
    1              0.000007   HiLink javaScriptConditional		Conditional
    1              0.000006   HiLink javaScriptRepeat		Repeat
    1              0.000006   HiLink javaScriptBranch		Conditional
    1              0.000006   HiLink javaScriptOperator		Operator
    1              0.000007   HiLink javaScriptType			Type
    1              0.000006   HiLink javaScriptStatement		Statement
    1              0.000006   HiLink javaScriptFunction		Function
    1              0.000006   HiLink javaScriptBraces		Function
    1              0.000010   HiLink javaScriptError		Error
    1              0.000007   HiLink javaScrParenError		javaScriptError
    1              0.000006   HiLink javaScriptNull			Keyword
    1              0.000006   HiLink javaScriptBoolean		Boolean
    1              0.000009   HiLink javaScriptRegexpString		String
                            
    1              0.000007   HiLink javaScriptIdentifier		Identifier
    1              0.000005   HiLink javaScriptLabel		Label
    1              0.000005   HiLink javaScriptException		Exception
    1              0.000005   HiLink javaScriptMessage		Keyword
    1              0.000006   HiLink javaScriptGlobal		Keyword
    1              0.000006   HiLink javaScriptMember		Keyword
    1              0.000006   HiLink javaScriptDeprecated		Exception 
    1              0.000006   HiLink javaScriptReserved		Keyword
    1              0.000009   HiLink javaScriptDebug		Debug
    1              0.000009   HiLink javaScriptConstant		Label
                            
    1              0.000002   delcommand HiLink
    1              0.000001 endif
                            
    1              0.000004 let b:current_syntax = "javascript"
    1              0.000003 if main_syntax == 'javascript'
    1              0.000003   unlet main_syntax
    1              0.000000 endif
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim73/syntax/python.vim
Sourced 1 time
Total time:   0.001062
 Self time:   0.001062

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Neil Schemenauer <nas@python.ca>
                            " Last Change:	2010 Sep 21
                            " Credits:	Zvezdan Petkovic <zpetkovic@acm.org>
                            "		Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " For version 5.x: Clear all syntax items.
                            " For version 6.x: Quit when a syntax file was already loaded.
    1              0.000003 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    1              0.000008 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " http://docs.python.org/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3.0 and 2.6.
                            " We include Python 3.0 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3.0 but they are
                            "   built-ins in 2.6 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3.0 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3.0 and will be highlighted.
                            " - 'print' is a built-in in Python 3.0 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2.6)
                            "
    1              0.000011 syn keyword pythonStatement	False, None, True
    1              0.000006 syn keyword pythonStatement	as assert break continue del exec global
    1              0.000005 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    1              0.000009 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    1              0.000008 syn keyword pythonConditional	elif else if
    1              0.000007 syn keyword pythonRepeat	for while
    1              0.000007 syn keyword pythonOperator	and in is not or
    1              0.000008 syn keyword pythonException	except finally raise try
    1              0.000007 syn keyword pythonInclude	from import
                            
                            " Decorators (new in Python 2.4)
    1              0.000013 syn match   pythonDecorator	"@" display nextgroup=pythonFunction skipwhite
                            " The zero-length non-grouping match before the function name is
                            " extremely important in pythonFunction.  Without it, everything is
                            " interpreted as a function inside the contained environment of
                            " doctests.
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    1              0.000013 syn match   pythonFunction
                                  \ "\%(\%(def\s\|class\s\|@\)\s*\)\@<=\h\%(\w\|\.\)*" contained
                            
    1              0.000016 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    1              0.000005 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    1              0.000023 syn region  pythonString
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    1              0.000022 syn region  pythonString
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    1              0.000019 syn region  pythonRawString
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    1              0.000015 syn region  pythonRawString
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    1              0.000007 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    1              0.000007 syn match   pythonEscape	"\\\o\{1,3}" contained
    1              0.000008 syn match   pythonEscape	"\\x\x\{2}" contained
    1              0.000010 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    1              0.000009 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    1              0.000007 syn match   pythonEscape	"\\$"
                            
    1              0.000006 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " http://docs.python.org/reference/lexical_analysis.html#numeric-literals
    1              0.000005 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    1              0.000014   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    1              0.000006   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    1              0.000006   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    1              0.000007   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    1              0.000005   syn match   pythonNumber	"\<\d\+[jJ]\>"
    1              0.000006   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    1              0.000010   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    1              0.000011   syn match   pythonNumber
                            	\ "\%(^\|\W\)\@<=\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    1              0.000001 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " http://docs.python.org/library/constants.html
                            " http://docs.python.org/library/functions.html
                            " http://docs.python.org/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    1              0.000004 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3.0
    1              0.000011   syn keyword pythonBuiltin	False True None
    1              0.000005   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    1              0.000005   syn keyword pythonBuiltin	abs all any bin bool chr classmethod
    1              0.000006   syn keyword pythonBuiltin	compile complex delattr dict dir divmod
    1              0.000005   syn keyword pythonBuiltin	enumerate eval filter float format
    1              0.000005   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    1              0.000005   syn keyword pythonBuiltin	help hex id input int isinstance
    1              0.000005   syn keyword pythonBuiltin	issubclass iter len list locals map max
    1              0.000005   syn keyword pythonBuiltin	min next object oct open ord pow print
    1              0.000006   syn keyword pythonBuiltin	property range repr reversed round set
    1              0.000004   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    1              0.000006   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2.6 only
    1              0.000022   syn keyword pythonBuiltin	basestring callable cmp execfile file
    1              0.000019   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    1              0.000010   syn keyword pythonBuiltin	unicode xrange
                              " Python 3.0 only
    1              0.000017   syn keyword pythonBuiltin	ascii bytearray bytes exec memoryview
                              " non-essential built-in functions; Python 2.6 only
    1              0.000016   syn keyword pythonBuiltin	apply buffer coerce intern
    1              0.000001 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/library/exceptions.html
    1              0.000004 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (only used as base classes for other exceptions)
    1              0.000016   syn keyword pythonExceptions	BaseException Exception
    1              0.000011   syn keyword pythonExceptions	ArithmeticError EnvironmentError
    1              0.000007   syn keyword pythonExceptions	LookupError
                              " builtin base exception removed in Python 3.0
    1              0.000006   syn keyword pythonExceptions	StandardError
                              " builtin exceptions (actually raised)
    1              0.000013   syn keyword pythonExceptions	AssertionError AttributeError BufferError
    1              0.000014   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    1              0.000013   syn keyword pythonExceptions	IOError ImportError IndentationError
    1              0.000011   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    1              0.000004   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    1              0.000004   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    1              0.000005   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    1              0.000005   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    1              0.000004   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    1              0.000004   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    1              0.000004   syn keyword pythonExceptions	UnicodeTranslateError ValueError VMSError
    1              0.000004   syn keyword pythonExceptions	WindowsError ZeroDivisionError
                              " builtin warnings
    1              0.000005   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    1              0.000004   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    1              0.000005   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    1              0.000003   syn keyword pythonExceptions	UserWarning Warning
    1              0.000001 endif
                            
    1              0.000004 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    1              0.000004 if !exists("python_no_doctest_highlight")
    1              0.000003   if !exists("python_no_doctest_code_higlight")
    1              0.000011     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,@Spell
    1              0.000017     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    1              0.000001   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    1              0.000001 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    1              0.000015 syn sync match pythonSync grouphere NONE "^\s*\%(def\|class\)\s\+\h\w*\s*("
                            
    1              0.000003 if version >= 508 || !exists("did_python_syn_inits")
    1              0.000002   if version <= 508
                                let did_python_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000010     command -nargs=+ HiLink hi def link <args>
    1              0.000001   endif
                            
                              " The default highlight links.  Can be overridden later.
    1              0.000011   HiLink pythonStatement	Statement
    1              0.000007   HiLink pythonConditional	Conditional
    1              0.000006   HiLink pythonRepeat		Repeat
    1              0.000009   HiLink pythonOperator		Operator
    1              0.000005   HiLink pythonException	Exception
    1              0.000005   HiLink pythonInclude		Include
    1              0.000006   HiLink pythonDecorator	Define
    1              0.000006   HiLink pythonFunction		Function
    1              0.000007   HiLink pythonComment		Comment
    1              0.000006   HiLink pythonTodo		Todo
    1              0.000006   HiLink pythonString		String
    1              0.000006   HiLink pythonRawString	String
    1              0.000007   HiLink pythonEscape		Special
    1              0.000004   if !exists("python_no_number_highlight")
    1              0.000006     HiLink pythonNumber		Number
    1              0.000001   endif
    1              0.000003   if !exists("python_no_builtin_highlight")
    1              0.000006     HiLink pythonBuiltin	Function
    1              0.000001   endif
    1              0.000003   if !exists("python_no_exception_highlight")
    1              0.000007     HiLink pythonExceptions	Structure
    1              0.000001   endif
    1              0.000003   if exists("python_space_error_highlight")
                                HiLink pythonSpaceError	Error
                              endif
    1              0.000003   if !exists("python_no_doctest_highlight")
    1              0.000007     HiLink pythonDoctest	Special
    1              0.000006     HiLink pythonDoctestValue	Define
    1              0.000000   endif
                            
    1              0.000002   delcommand HiLink
    1              0.000001 endif
                            
    1              0.000003 let b:current_syntax = "python"
                            
    1              0.000010 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/vim/vim73/syntax/jproperties.vim
Sourced 1 time
Total time:   0.001334
 Self time:   0.001334

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Java Properties resource file (*.properties[_*])
                            " Maintainer:	Simon Baldwin <simonb@sco.com>
                            " Last change:	26th Mar 2000
                            
                            " =============================================================================
                            
                            " Optional and tuning variables:
                            
                            " jproperties_lines
                            " -----------------
                            "   Set a value for the sync block that we use to find long continuation lines
                            "   in properties; the value is already large - if you have larger continuation
                            "   sets you may need to increase it further - if not, and you find editing is
                            "   slow, reduce the value of jproperties_lines.
    1              0.000019 if !exists("jproperties_lines")
    1              0.000014 	let jproperties_lines = 256
    1              0.000004 endif
                            
                            " jproperties_strict_syntax
                            " -------------------------
                            "   Most properties files assign values with "id=value" or "id:value".  But,
                            "   strictly, the Java properties parser also allows "id value", "id", and
                            "   even more bizarrely "=value", ":value", " value", and so on.  These latter
                            "   ones, however, are rarely used, if ever, and handling them in the high-
                            "   lighting can obscure errors in the more normal forms.  So, in practice
                            "   we take special efforts to pick out only "id=value" and "id:value" forms
                            "   by default.  If you want strict compliance, set jproperties_strict_syntax
                            "   to non-zero (and good luck).
    1              0.000012 if !exists("jproperties_strict_syntax")
    1              0.000020 	let jproperties_strict_syntax = 0
    1              0.000003 endif
                            
                            " jproperties_show_messages
                            " -------------------------
                            "   If this properties file contains messages for use with MessageFormat,
                            "   setting a non-zero value will highlight them.  Messages are of the form
                            "   "{...}".  Highlighting doesn't go to the pains of picking apart what is
                            "   in the format itself - just the basics for now.
    1              0.000010 if !exists("jproperties_show_messages")
    1              0.000012 	let jproperties_show_messages = 0
    1              0.000003 endif
                            
                            " =============================================================================
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    1              0.000006 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " switch case sensitivity off
    1              0.000007 syn case ignore
                            
                            " set the block
    1              0.000026 exec "syn sync lines=" . jproperties_lines
                            
                            " switch between 'normal' and 'strict' syntax
    1              0.000007 if jproperties_strict_syntax != 0
                            
                            	" an assignment is pretty much any non-empty line at this point,
                            	" trying to not think about continuation lines
                            	syn match   jpropertiesAssignment	"^\s*[^[:space:]]\+.*$" contains=jpropertiesIdentifier
                            
                            	" an identifier is anything not a space character, pretty much; it's
                            	" followed by = or :, or space or tab.  Or end-of-line.
                            	syn match   jpropertiesIdentifier	"[^=:[:space:]]*" contained nextgroup=jpropertiesDelimiter
                            
                            	" treat the delimiter specially to get colours right
                            	syn match   jpropertiesDelimiter	"\s*[=:[:space:]]\s*" contained nextgroup=jpropertiesString
                            
                            	" catch the bizarre case of no identifier; a special case of delimiter
                            	syn match   jpropertiesEmptyIdentifier	"^\s*[=:]\s*" nextgroup=jpropertiesString
                            else
                            
                            	" here an assignment is id=value or id:value, and we conveniently
                            	" ignore continuation lines for the present
    1              0.000045 	syn match   jpropertiesAssignment	"^\s*[^=:[:space:]]\+\s*[=:].*$" contains=jpropertiesIdentifier
                            
                            	" an identifier is anything not a space character, pretty much; it's
                            	" always followed by = or :, and we find it in an assignment
    1              0.000022 	syn match   jpropertiesIdentifier	"[^=:[:space:]]\+" contained nextgroup=jpropertiesDelimiter
                            
                            	" treat the delimiter specially to get colours right; this time the
                            	" delimiter must contain = or :
    1              0.000017 	syn match   jpropertiesDelimiter	"\s*[=:]\s*" contained nextgroup=jpropertiesString
    1              0.000003 endif
                            
                            " a definition is all up to the last non-\-terminated line; strictly, Java
                            " properties tend to ignore leading whitespace on all lines of a multi-line
                            " definition, but we don't look for that here (because it's a major hassle)
    1              0.000078 syn region  jpropertiesString		start="" skip="\\$" end="$" contained contains=jpropertiesSpecialChar,jpropertiesError,jpropertiesSpecial
                            
                            " {...} is a Java Message formatter - add a minimal recognition of these
                            " if required
    1              0.000011 if jproperties_show_messages != 0
                            	syn match   jpropertiesSpecial		"{[^}]*}\{-1,\}" contained
                            	syn match   jpropertiesSpecial		"'{" contained
                            	syn match   jpropertiesSpecial		"''" contained
                            endif
                            
                            " \uABCD are unicode special characters
    1              0.000016 syn match   jpropertiesSpecialChar	"\\u\x\{1,4}" contained
                            
                            " ...and \u not followed by a hex digit is an error, though the properties
                            " file parser won't issue an error on it, just set something wacky like zero
    1              0.000014 syn match   jpropertiesError		"\\u\X\{1,4}" contained
    1              0.000013 syn match   jpropertiesError		"\\u$"me=e-1 contained
                            
                            " other things of note are the \t,r,n,\, and the \ preceding line end
    1              0.000015 syn match   jpropertiesSpecial		"\\[trn\\]" contained
    1              0.000020 syn match   jpropertiesSpecial		"\\\s" contained
    1              0.000012 syn match   jpropertiesSpecial		"\\$" contained
                            
                            " comments begin with # or !, and persist to end of line; put here since
                            " they may have been caught by patterns above us
    1              0.000050 syn match   jpropertiesComment		"^\s*[#!].*$" contains=jpropertiesTODO
    1              0.000017 syn keyword jpropertiesTodo		TODO FIXME XXX contained
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000012 if version >= 508 || !exists("did_jproperties_syntax_inits")
    1              0.000006   if version < 508
                                let did_jproperties_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000044     command -nargs=+ HiLink hi def link <args>
    1              0.000004   endif
                            
    1              0.000036 	HiLink jpropertiesComment	Comment
    1              0.000025 	HiLink jpropertiesTodo		Todo
    1              0.000026 	HiLink jpropertiesIdentifier	Identifier
    1              0.000023 	HiLink jpropertiesString	String
    1              0.000036 	HiLink jpropertiesExtendString	String
    1              0.000040 	HiLink jpropertiesCharacter	Character
    1              0.000024 	HiLink jpropertiesSpecial	Special
    1              0.000022 	HiLink jpropertiesSpecialChar	SpecialChar
    1              0.000022 	HiLink jpropertiesError	Error
                            
    1              0.000007   delcommand HiLink
    1              0.000003 endif
                            
    1              0.000012 let b:current_syntax = "jproperties"
                            
                            " vim:ts=8

SCRIPT  /home/skl/.vim/bundle/unite.vim/autoload/unite/sources/mru.vim
Sourced 1 time
Total time:   0.003191
 Self time:   0.000747

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mru.vim
                            " AUTHOR:  Zhso Cai <caizhaoff@gmail.com>
                            "          Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " Last Modified: 30 Apr 2013
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
                            
                            " Variables  "{{{
    1   0.000019   0.000007 let s:V = unite#util#get_vital()
    1   0.002165   0.000011 let s:L = s:V.import("Data.List")
                            
                            " The version of MRU file format.
    1              0.000003 let s:VERSION = '0.2.0'
                            
    1   0.000036   0.000011 call unite#util#set_default(
                                  \ 'g:unite_source_mru_do_validate', 1)
    1   0.000027   0.000009 call unite#util#set_default(
                                  \ 'g:unite_source_mru_update_interval', 600)
                            
    1   0.000025   0.000008 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_time_format',
                                  \ '(%Y/%m/%d %H:%M:%S) ')
    1   0.000025   0.000007 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_filename_format',
                                  \ ':~:.')
    1   0.000026   0.000010 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_file',
                                  \ g:unite_data_directory . '/file_mru')
    1   0.000027   0.000010 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_long_file',
                                  \ g:unite_data_directory . '/file_mru_long')
    1   0.000026   0.000010 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_limit',
                                  \ 100)
    1   0.000024   0.000008 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_long_limit',
                                  \ 1000)
    1   0.000030   0.000013 call unite#util#set_default(
                                  \ 'g:unite_source_file_mru_ignore_pattern',
                                  \'\~$\|\.\%(o\|exe\|dll\|bak\|zwc\|pyc\|sw[po]\)$'
                                  \'\|\%(^\|/\)\.\%(hg\|git\|bzr\|svn\)\%($\|/\)'
                                  \'\|^\%(\\\\\|/mnt/\|/media/\|/temp/\|/tmp/\|\%(/private\)\=/var/folders/\)'
                                  \'\|\%(^\%(fugitive\)://\)'
                                  \)
                            
    1   0.000025   0.000008 call unite#util#set_default('g:unite_source_directory_mru_time_format',
                                  \ '(%Y/%m/%d %H:%M:%S) ')
    1   0.000026   0.000008 call unite#util#set_default('g:unite_source_directory_mru_filename_format',
                                  \ ':~:.')
    1   0.000026   0.000009 call unite#util#set_default('g:unite_source_directory_mru_file',
                                  \ g:unite_data_directory . '/directory_mru')
    1   0.000026   0.000009 call unite#util#set_default('g:unite_source_directory_mru_long_file',
                                  \ g:unite_data_directory . '/directory_mru_long')
    1   0.000022   0.000006 call unite#util#set_default('g:unite_source_directory_mru_limit', 100)
    1   0.000024   0.000008 call unite#util#set_default('g:unite_source_directory_mru_long_limit', 1000)
    1   0.000029   0.000012 call unite#util#set_default('g:unite_source_directory_mru_ignore_pattern',
                                  \'\%(^\|/\)\.\%(hg\|git\|bzr\|svn\)\%($\|/\)'
                                  \'\|^\%(\\\\\|/mnt/\|/media/\|/temp/\|/tmp/\|\%(/private\)\=/var/folders/\)')
                            "}}}
                            
                            " MRUs  "{{{
    1              0.000003 let s:MRUs = {}
                            
                            " Template MRU:  "{{{2
                            
                            "---------------------%>---------------------
                            " @candidates:
                            " ------------
                            " [[full_path, localtime()], ... ]
                            "
                            " @mtime
                            " ------
                            " the last modified time of the mru file.
                            " - set once when loading the short mru_file
                            " - update when #save()
                            "
                            " @is_loaded
                            " ----------
                            " 0: empty
                            " 1: short
                            " 2: long
                            " -------------------%<---------------------
                            
    1              0.000020 let s:mru = {
                                  \ 'candidates'      : [],
                                  \ 'type'            : '',
                                  \ 'mtime'           : 0,
                                  \ 'update_interval' : g:unite_source_mru_update_interval,
                                  \ 'mru_file'        : {},
                                  \ 'limit'           : {},
                                  \ 'do_validate'     : g:unite_source_mru_do_validate,
                                  \ 'is_loaded'       : 0,
                                  \ 'version'         : s:VERSION,
                                  \ }
                            
    1              0.000004 function! s:mru.is_a(type) "{{{
                              return self.type == a:type
                            endfunction "}}}
    1              0.000003 function! s:mru.save(...)
                                throw 'unite(mru) umimplemented method: save()!'
                            endfunction
    1              0.000001 function! s:mru.load()
                                throw 'unite(mru) umimplemented method: load()!'
                            endfunction
    1              0.000002 function! s:mru.validate()
                                throw 'unite(mru) umimplemented method: validate()!'
                            endfunction
                            
    1              0.000003 function! s:mru.gather_candidates(args, context) "{{{
                              if empty(self.candidates)
                                call self.load()
                              endif
                            
                              let self.candidates = unite#sources#mru#variables#get_mrus(self.type)
                                    \ + self.candidates
                              call unite#sources#mru#variables#clear(self.type)
                            
                              if a:context.is_redraw && g:unite_source_mru_do_validate
                                call filter(self.candidates,
                                      \ ((self.type == 'file') ?
                                      \ "v:val.action__path !~ '^\\a\\w\\+:'
                                      \       && filereadable(v:val.action__path)" :
                                      \ "isdirectory(v:val.action__path)"))
                              endif
                            
                              if get(a:args, 0, '') =~# '\%(long\|all\|\*\|_\)'
                                  \ || a:context.is_redraw
                                call self.load()
                                return self.candidates
                              else
                                return self.candidates[: self.limit.short]
                              endif
                            endfunction"}}}
    1              0.000002 function! s:mru.delete(candidates) "{{{
                              for candidate in a:candidates
                                call filter(self.candidates,
                                      \ 'v:val.action__path !=# candidate.action__path')
                              endfor
                            
                              call self.save()
                            endfunction"}}}
    1              0.000002 function! s:mru.has_external_update() "{{{
                              return self.mtime < getftime(self.mru_file.short)
                                  \ || self.mtime < getftime(self.mru_file.long)
                            endfunction"}}}
                            
    1              0.000001 function! s:mru.save(...) "{{{
                              let opts = {}
                              if a:0 >= 1 && s:V.is_dict(a:1)
                                call extend(opts, a:1)
                              endif
                            
                              " should load all candidates
                              call self.load(1)
                            
                              let self.candidates = unite#sources#mru#variables#get_mrus(self.type)
                                    \ + self.candidates
                              call unite#sources#mru#variables#clear(self.type)
                            
                              if empty(self.candidates)
                                " nothing to save, mru is not loaded
                                return
                              endif
                            
                              if self.has_external_update() && filereadable(self.mru_file.short)
                                " only need to get the short list which contains the latest MRUs
                                let [ver; items] = readfile(self.mru_file.short)
                                if self.version_check(ver)
                                  let self.candidates = s:L.uniq(extend(self.candidates,
                                        \ s:convert2candidates(items)), 'v:val.action__path')
                                endif
                              endif
                            
                              if get(opts, 'event') ==# 'VimLeavePre'
                                call self.validate()
                              endif
                            
                              let self.candidates = s:L.uniq(self.candidates, 'v:val.action__path')
                            
                              call writefile([self.version] + map(copy(
                                  \ self.candidates[: self.limit.short - 1]),
                                  \ 'join(s:convert2list(v:val), "\t")'),
                                  \ self.mru_file.short)
                            
                              if len(self.candidates) > self.limit.short
                                call writefile([self.version] + map(copy(
                                    \ self.candidates[self.limit.short : self.limit.long - 1]),
                                    \ 'join(s:convert2list(v:val), "\t")'),
                                    \ self.mru_file.long)
                                let self.mtime = getftime(self.mru_file.long)
                              else
                                let self.mtime = getftime(self.mru_file.short)
                              endif
                            endfunction"}}}
                            
    1              0.000002 function! s:mru.load(...)  "{{{
                              let is_force = get(a:000, 0, 0)
                            
                              " everything is loaded, done!
                              if !is_force && self.is_loaded >= 2
                                return
                              endif
                            
                              " Load Order:
                              " 1. (load)  short mru list
                              " 2. (merge) long list on_redraw
                              let mru_file = empty(self.candidates) ?
                                    \ self.mru_file.short : self.mru_file.long
                            
                              if !filereadable(mru_file)
                                return
                              endif
                            
                              let file = readfile(mru_file)
                              if empty(file)
                                return
                              endif
                            
                              let [ver; items] = file
                              if !self.version_check(ver)
                                return
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
                              call extend(self.candidates, s:convert2candidates(items))
                            
                              if mru_file == self.mru_file.short
                                let self.mtime = getftime(mru_file)
                                let self.is_loaded = 1
                              elseif mru_file == self.mru_file.long
                                let self.is_loaded = 2
                              endif
                            endfunction"}}}
    1              0.000004 function! s:mru.version_check(ver)  "{{{
                              if str2float(a:ver) < self.version
                                call unite#util#print_error(
                                      \ 'Sorry, the version of MRU file is old.')
                                return 0
                              else
                                return 1
                              endif
                            endfunction"}}}
                            
                            "}}}
                            
                            " File MRU:   "{{{2
                            "
    1              0.000029 let s:file_mru = extend(deepcopy(s:mru), {
                                  \ 'type'          : 'file',
                                  \ 'mru_file'      : {
                                  \   'short' : g:unite_source_file_mru_file,
                                  \   'long'  : g:unite_source_file_mru_long_file,
                                  \  },
                                  \ 'limit'         : {
                                  \   'short' : g:unite_source_file_mru_limit,
                                  \   'long'  : g:unite_source_file_mru_long_limit,
                                  \  },
                                  \ }
                                  \)
    1              0.000003 function! s:file_mru.validate()  "{{{
                              if self.do_validate
                                call filter(self.candidates,
                                      \ 'getftype(v:val.action__path) ==# "file"')
                              endif
                            endfunction"}}}
                            
                            " Directory MRU:   "{{{2
    1              0.000025 let s:directory_mru = extend(deepcopy(s:mru), {
                                  \ 'type'          : 'directory',
                                  \ 'mru_file'      : {
                                  \   'short' : g:unite_source_directory_mru_file,
                                  \   'long'  : g:unite_source_directory_mru_long_file,
                                  \  },
                                  \ 'limit'         : {
                                  \   'short' : g:unite_source_directory_mru_limit,
                                  \   'long'  : g:unite_source_directory_mru_long_limit,
                                  \  },
                                  \ }
                                  \)
                            
    1              0.000004 function! s:directory_mru.validate()  "{{{
                              if self.do_validate
                                call filter(self.candidates,
                                      \ 'getftype(v:val.action__path) ==# "dir"')
                              endif
                            endfunction"}}}
                            "}}}
                            
                            " Public Interface:   "{{{2
                            
    1              0.000004 let s:MRUs.file = s:file_mru
    1              0.000003 let s:MRUs.directory = s:directory_mru
    1              0.000004 function! unite#sources#mru#_save(...) "{{{
                              let opts = {}
                              if a:0 >= 1 && s:V.is_dict(a:1)
                                call extend(opts, a:1)
                              endif
                            
                              for m in values(s:MRUs)
                                call m.save(opts)
                              endfor
                            endfunction"}}}
                            "}}}
                            "}}}
                            
                            " Source  "{{{
                            
    1              0.000004 function! unite#sources#mru#define() "{{{
                              return [s:file_mru_source, s:dir_mru_source]
                            endfunction"}}}
    1              0.000017 let s:file_mru_source = {
                                  \ 'name' : 'file_mru',
                                  \ 'description' : 'candidates from file MRU list',
                                  \ 'hooks' : {},
                                  \ 'action_table' : {},
                                  \ 'syntax' : 'uniteSource__FileMru',
                                  \ 'default_kind' : 'file',
                                  \ 'ignore_pattern' : g:unite_source_file_mru_ignore_pattern,
                                  \ 'max_candidates' : 200,
                                  \}
                            
    1              0.000017 let s:dir_mru_source = {
                                  \ 'name' : 'directory_mru',
                                  \ 'description' : 'candidates from directory MRU list',
                                  \ 'hooks' : {},
                                  \ 'action_table' : {},
                                  \ 'syntax' : 'uniteSource__DirectoryMru',
                                  \ 'default_kind' : 'directory',
                                  \ 'ignore_pattern' :
                                  \    g:unite_source_directory_mru_ignore_pattern,
                                  \ 'alias_table' : { 'unite__new_candidate' : 'vimfiler__mkdir' },
                                  \ 'max_candidates' : 200,
                                  \}
                            
    1              0.000003 function! s:file_mru_source.hooks.on_syntax(args, context) "{{{
                              syntax match uniteSource__FileMru_Time
                                    \ /([^)]*)\s\+/
                                    \ contained containedin=uniteSource__FileMru
                              highlight default link uniteSource__FileMru_Time Statement
                            endfunction"}}}
    1              0.000005 function! s:dir_mru_source.hooks.on_syntax(args, context) "{{{
                              syntax match uniteSource__DirectoryMru_Time
                                    \ /([^)]*)\s\+/
                                    \ contained containedin=uniteSource__DirectoryMru
                              highlight default link uniteSource__DirectoryMru_Time Statement
                            endfunction"}}}
    1              0.000003 function! s:file_mru_source.hooks.on_post_filter(args, context) "{{{
                              return s:on_post_filter(a:args, a:context)
                            endfunction"}}}
    1              0.000003 function! s:dir_mru_source.hooks.on_post_filter(args, context) "{{{
                              return s:on_post_filter(a:args, a:context)
                            endfunction"}}}
    1              0.000003 function! s:file_mru_source.gather_candidates(args, context) "{{{
                              let mru = s:MRUs.file
                              return mru.gather_candidates(a:args, a:context)
                            endfunction"}}}
    1              0.000002 function! s:dir_mru_source.gather_candidates(args, context) "{{{
                              let mru = s:MRUs.directory
                              return mru.gather_candidates(a:args, a:context)
                            endfunction"}}}
                            "}}}
                            " Actions "{{{
    1              0.000009 let s:file_mru_source.action_table.delete = {
                                  \ 'description' : 'delete from file_mru list',
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_quit' : 0,
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000003 function! s:file_mru_source.action_table.delete.func(candidates) "{{{
                              call s:MRUs.file.delete(a:candidates)
                            endfunction"}}}
                            
    1              0.000011 let s:dir_mru_source.action_table.delete = {
                                  \ 'description' : 'delete from directory_mru list',
                                  \ 'is_invalidate_cache' : 1,
                                  \ 'is_quit' : 0,
                                  \ 'is_selectable' : 1,
                                  \ }
    1              0.000003 function! s:dir_mru_source.action_table.delete.func(candidates) "{{{
                              call s:MRUs.directory.delete(a:candidates)
                            endfunction"}}}
                            "}}}
                            
                            " Filters "{{{
    1              0.000003 function! s:file_mru_source.source__converter(candidates, context) "{{{
                              return s:converter(a:candidates,
                                    \ g:unite_source_file_mru_filename_format,
                                    \ g:unite_source_file_mru_time_format)
                            endfunction"}}}
                            
    1              0.000006 let s:file_mru_source.converters = [ s:file_mru_source.source__converter ]
                            
    1              0.000002 function! s:dir_mru_source.source__converter(candidates, context) "{{{
                              return s:converter(a:candidates,
                                    \ g:unite_source_directory_mru_filename_format,
                                    \ g:unite_source_directory_mru_time_format)
                            endfunction"}}}
                            
    1              0.000005 let s:dir_mru_source.converters = [ s:dir_mru_source.source__converter ]
                            
                            "}}}
                            
                            " Misc "{{{
    1              0.000003 function! s:convert2candidates(items)  "{{{
                              try
                                return map(a:items, 's:convert2dictionary(split(v:val, "\t"))')
                              catch
                                call unite#util#print_error('Sorry, MRU file is invalid.')
                                return []
                              endtry
                            endfunction"}}}
    1              0.000003 function! s:convert2dictionary(list)  "{{{
                              return { 'word' : a:list[0], 'source__time' : str2nr(a:list[1]),
                                    \ 'action__path' : fnamemodify(a:list[0], ':p'), }
                            endfunction"}}}
    1              0.000003 function! s:convert2list(dict)  "{{{
                              return [ fnamemodify(a:dict.action__path, ':~'), a:dict.source__time ]
                            endfunction"}}}
    1              0.000003 function! s:on_post_filter(args, context) "{{{
                              let a:context.candidates = s:L.uniq(
                                    \ a:context.candidates, 'v:val.action__path')
                              for candidate in a:context.candidates
                                let candidate.action__directory =
                                      \ unite#util#path2directory(candidate.action__path)
                                let candidate.kind =
                                      \ (isdirectory(candidate.action__path) ? 'directory' : 'file')
                            
                                if candidate.kind ==# 'directory' && candidate.abbr !~ '/$'
                                  let candidate.abbr .= '/'
                                endif
                              endfor
                            endfunction"}}}
    1              0.000004 function! s:converter(candidates, filename_format, time_format) "{{{
                              for candidate in filter(copy(a:candidates),
                                    \ "!has_key(v:val, 'abbr')")
                                let path = (a:filename_format == '') ?  candidate.action__path :
                                      \ unite#util#substitute_path_separator(
                                      \   fnamemodify(candidate.action__path, a:filename_format))
                                if path == ''
                                  let path = candidate.action__path
                                endif
                            
                                " Set default abbr.
                                let candidate.abbr = (a:time_format == '' ? '' :
                                      \ strftime(a:time_format, candidate.source__time))
                                let candidate.abbr .= path
                              endfor
                            
                              return a:candidates
                            endfunction"}}}
                            "}}}
                            "
    1              0.000011 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

FUNCTION  unite#mappings#define_default_mappings()
Called 1 time
Total time:   0.002127
 Self time:   0.002127

count  total (s)   self (s)
                              " Plugin keymappings "{{{
    1              0.000041   nnoremap <silent><buffer> <Plug>(unite_exit) :<C-u>call <SID>exit()<CR>
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_all_exit) :<C-u>call <SID>all_exit()<CR>
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_choose_action) :<C-u>call <SID>choose_action()<CR>
    1              0.000016   nnoremap <expr><buffer> <Plug>(unite_insert_enter) <SID>insert_enter('i')
    1              0.000027   nnoremap <expr><buffer> <Plug>(unite_insert_head) <SID>insert_enter('A'.  (repeat("\<Left>", len(substitute(    unite#helper#get_input(), '.', 'x', 'g')))))
    1              0.000016   nnoremap <expr><buffer> <Plug>(unite_append_enter) <SID>insert_enter('a')
    1              0.000016   nnoremap <expr><buffer> <Plug>(unite_append_end) <SID>insert_enter('A')
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate) :<C-u>call <SID>toggle_mark('j')<CR>
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate_up) :<C-u>call <SID>toggle_mark('k')<CR>
    1              0.000015   nnoremap <silent><buffer> <Plug>(unite_redraw) :<C-u>call <SID>redraw()<CR>
    1              0.000017   nnoremap <silent><buffer> <Plug>(unite_rotate_next_source) :<C-u>call <SID>rotate_source(1)<CR>
    1              0.000017   nnoremap <silent><buffer> <Plug>(unite_rotate_previous_source) :<C-u>call <SID>rotate_source(0)<CR>
    1              0.000018   nnoremap <silent><buffer> <Plug>(unite_print_candidate) :<C-u>call <SID>print_candidate()<CR>
    1              0.000017   nnoremap <silent><buffer> <Plug>(unite_print_message_log) :<C-u>call <SID>print_message_log()<CR>
    1              0.000019   nnoremap <buffer><expr> <Plug>(unite_cursor_top) unite#get_current_unite().prompt_linenr.'G0z.'
    1              0.000018   nnoremap <silent><buffer> <Plug>(unite_cursor_bottom) :<C-u>call <SID>redraw_all_candidates()<CR>G
    1              0.000017   nnoremap <buffer><expr> <Plug>(unite_loop_cursor_down) <SID>loop_cursor_down(0)
    1              0.000016   nnoremap <buffer><expr> <Plug>(unite_skip_cursor_down) <SID>loop_cursor_down(1)
    1              0.000016   nnoremap <buffer><silent> <Plug>(unite_next_screen) :<C-u>call <SID>move_screen(1)<CR>
    1              0.000017   nnoremap <buffer><silent> <Plug>(unite_next_half_screen) :<C-u>call <SID>move_half_screen(1)<CR>
    1              0.000020   nnoremap <silent><buffer> <Plug>(unite_quick_match_default_action) :<C-u>call unite#mappings#_quick_match(0)<CR>
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_quick_match_choose_action) :<C-u>call unite#mappings#_quick_match(1)<CR>
    1              0.000017   nnoremap <silent><buffer> <Plug>(unite_input_directory) :<C-u>call <SID>input_directory()<CR>
    1              0.000022   nnoremap <silent><buffer><expr> <Plug>(unite_do_default_action) unite#do_action(unite#get_current_unite().context.default_action)
    1              0.000019   nnoremap <silent><buffer> <Plug>(unite_delete_backward_path) :<C-u>call <SID>normal_delete_backward_path()<CR>
    1              0.000015   nnoremap <silent><buffer> <Plug>(unite_restart) :<C-u>call <SID>restart()<CR>
    1              0.000019   nnoremap <buffer><silent> <Plug>(unite_toggle_mark_all_candidates) :<C-u>call <SID>toggle_mark_all_candidates()<CR>
    1              0.000019   nnoremap <buffer><silent> <Plug>(unite_toggle_transpose_window) :<C-u>call <SID>toggle_transpose_window()<CR>
    1              0.000017   nnoremap <buffer><silent> <Plug>(unite_toggle_auto_preview) :<C-u>call <SID>toggle_auto_preview()<CR>
    1              0.000018   nnoremap <buffer><silent> <Plug>(unite_toggle_auto_highlight) :<C-u>call <SID>toggle_auto_highlight()<CR>
    1              0.000016   nnoremap <buffer><silent> <Plug>(unite_narrowing_path) :<C-u>call <SID>narrowing_path()<CR>
    1              0.000019   nnoremap <buffer><silent> <Plug>(unite_narrowing_input_history) :<C-u>call <SID>narrowing_input_history()<CR>
    1              0.000016   nnoremap <buffer><silent> <Plug>(unite_narrowing_dot) :<C-u>call <SID>narrowing_dot()<CR>
    1              0.000019   nnoremap <buffer><silent> <Plug>(unite_disable_max_candidates) :<C-u>call <SID>disable_max_candidates()<CR>
    1              0.000016   nnoremap <buffer><silent> <Plug>(unite_quick_help) :<C-u>call <SID>quick_help()<CR>
    1              0.000017   nnoremap <buffer><silent> <Plug>(unite_new_candidate) :<C-u>call <SID>do_new_candidate_action()<CR>
                            
    1              0.000038   vnoremap <buffer><silent> <Plug>(unite_toggle_mark_selected_candidates) :<C-u>call <SID>toggle_mark_candidates(getpos("'<")[1]  - unite#get_current_unite().prompt_linenr-1, getpos("'>")[1] - unite#get_current_unite().prompt_linenr - 1)<CR>
                            
    1              0.000015   inoremap <silent><buffer> <Plug>(unite_exit) <ESC>:<C-u>call <SID>exit()<CR>
    1              0.000032   inoremap <silent><expr><buffer> <Plug>(unite_insert_leave) "\<ESC>0".((line('.') <= unite#get_current_unite().prompt_linenr) ? (unite#get_current_unite().prompt_linenr+1)."G" : "") . ":call unite#redraw()\<CR>"
    1              0.000030   inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_char) <SID>smart_imap("\<ESC>:\<C-u>call \<SID>all_exit()\<CR>", (unite#helper#get_input() == '' ? "\<ESC>:\<C-u>call \<SID>all_exit()\<CR>" : "\<C-h>"))
    1              0.000027   inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_line) <SID>smart_imap('', repeat("\<C-h>",     col('.')-(len(unite#get_current_unite().prompt)+1)))
    1              0.000017   inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_word) <SID>smart_imap('', "\<C-w>")
    1              0.000019   inoremap <silent><expr><buffer> <Plug>(unite_delete_backward_path) <SID>smart_imap('', <SID>delete_backward_path())
    1              0.000019   inoremap <expr><buffer> <Plug>(unite_select_next_line) pumvisible() ? "\<C-n>" : <SID>loop_cursor_down(0)
    1              0.000019   inoremap <silent><buffer> <Plug>(unite_skip_previous_line) <ESC>:call unite#mappings#loop_cursor_up_call(1, 'i')<CR>
    1              0.000021   inoremap <expr><buffer> <Plug>(unite_select_next_page) pumvisible() ? "\<PageDown>" : repeat("\<Down>", winheight(0))
    1              0.000020   inoremap <expr><buffer> <Plug>(unite_select_previous_page) pumvisible() ? "\<PageUp>" : repeat("\<Up>", winheight(0))
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate) <C-o>:<C-u>call <SID>toggle_mark('j')<CR>
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_toggle_mark_current_candidate_up) <C-o>:<C-u>call <SID>toggle_mark('k')<CR>
    1              0.000016   inoremap <silent><buffer> <Plug>(unite_choose_action) <C-o>:<C-u>call <SID>choose_action()<CR>
    1              0.000028   inoremap <expr><buffer> <Plug>(unite_move_head) <SID>smart_imap("\<ESC>".<SID>insert_enter('A'),   repeat("\<Left>", len(substitute(     unite#helper#get_input(), '.', 'x', 'g'))))
    1              0.000019   inoremap <silent><buffer> <Plug>(unite_quick_match_default_action) <C-o>:<C-u>call unite#mappings#_quick_match(0)<CR>
    1              0.000019   inoremap <silent><buffer> <Plug>(unite_quick_match_choose_action) <C-o>:<C-u>call unite#mappings#_quick_match(1)<CR>
    1              0.000016   inoremap <silent><buffer> <Plug>(unite_input_directory) <C-o>:<C-u>call <SID>input_directory()<CR>
    1              0.000021   inoremap <silent><buffer><expr> <Plug>(unite_do_default_action) unite#do_action(unite#get_current_unite().context.default_action)
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_toggle_transpose_window) <C-o>:<C-u>call <SID>toggle_transpose_window()<CR>
    1              0.000017   inoremap <silent><buffer> <Plug>(unite_toggle_auto_preview) <C-o>:<C-u>call <SID>toggle_auto_preview()<CR>
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_toggle_auto_highlight) <C-o>:<C-u>call <SID>toggle_auto_highlight()<CR>
    1              0.000015   inoremap <silent><buffer> <Plug>(unite_narrowing_path) <C-o>:<C-u>call <SID>narrowing_path()<CR>
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_narrowing_input_history) <C-o>:<C-u>call <SID>narrowing_input_history()<CR>
    1              0.000018   inoremap <silent><buffer> <Plug>(unite_disable_max_candidates) <C-o>:<C-u>call <SID>disable_max_candidates()<CR>
    1              0.000015   inoremap <silent><buffer> <Plug>(unite_redraw) <C-o>:<C-u>call <SID>redraw()<CR>
    1              0.000017   inoremap <buffer><silent> <Plug>(unite_new_candidate) <C-o>:<C-u>call <SID>do_new_candidate_action()<CR>
    1              0.000017   inoremap <silent><buffer> <Plug>(unite_print_message_log) <C-o>:<C-u>call <SID>print_message_log()<CR>
                              "}}}
                            
    1              0.000006   if exists('g:unite_no_default_keymappings') && g:unite_no_default_keymappings
                                return
                              endif
                            
                              " Normal mode key-mappings.
    1              0.000016   nmap <buffer> i         <Plug>(unite_insert_enter)
    1              0.000014   nmap <buffer> I         <Plug>(unite_insert_head)
    1              0.000012   nmap <buffer> A         <Plug>(unite_append_end)
    1              0.000012   nmap <buffer> q         <Plug>(unite_exit)
    1              0.000012   nmap <buffer> Q         <Plug>(unite_all_exit)
    1              0.000015   nmap <buffer> <CR>      <Plug>(unite_do_default_action)
    1              0.000016   nmap <buffer> <Space>   <Plug>(unite_toggle_mark_current_candidate)
    1              0.000017   nmap <buffer> <S-Space> <Plug>(unite_toggle_mark_current_candidate_up)
    1              0.000012   nmap <buffer> <Tab>     <Plug>(unite_choose_action)
    1              0.000015   nmap <buffer> <C-n>     <Plug>(unite_rotate_next_source)
    1              0.000015   nmap <buffer> <C-p>     <Plug>(unite_rotate_previous_source)
    1              0.000014   nmap <buffer> <C-g>     <Plug>(unite_print_message_log)
    1              0.000013   nmap <buffer> <C-l>     <Plug>(unite_redraw)
    1              0.000014   nmap <buffer> gg        <Plug>(unite_cursor_top)
    1              0.000013   nmap <buffer> G         <Plug>(unite_cursor_bottom)
    1              0.000014   nmap <buffer> j         <Plug>(unite_loop_cursor_down)
    1              0.000016   nmap <buffer> <Down>    <Plug>(unite_loop_cursor_down)
    1              0.000012   nmap <buffer> k         <Plug>(unite_loop_cursor_up)
    1              0.000013   nmap <buffer> <Up>      <Plug>(unite_loop_cursor_up)
    1              0.000014   nmap <buffer> J         <Plug>(unite_skip_cursor_down)
    1              0.000012   nmap <buffer> K         <Plug>(unite_skip_cursor_up)
    1              0.000014   nmap <buffer> <C-h>     <Plug>(unite_delete_backward_path)
    1              0.000013   nmap <buffer> <C-r>     <Plug>(unite_restart)
    1              0.000015   nmap <buffer> *         <Plug>(unite_toggle_mark_all_candidates)
    1              0.000015   nmap <buffer> M         <Plug>(unite_disable_max_candidates)
    1              0.000012   nmap <buffer> ?         <Plug>(unite_quick_help)
    1              0.000013   nmap <buffer> N         <Plug>(unite_new_candidate)
    1              0.000013   nmap <buffer> .         <Plug>(unite_narrowing_dot)
                            
    1              0.000023   nmap <silent><buffer><expr> a unite#smart_map("\<Plug>(unite_append_enter)",                 "\<Plug>(unite_choose_action)")
    1              0.000015   nnoremap <silent><buffer><expr> d unite#smart_map('d', unite#do_action('delete'))
    1              0.000015   nnoremap <silent><buffer><expr> b unite#smart_map('b', unite#do_action('bookmark'))
    1              0.000014   nnoremap <silent><buffer><expr> e unite#smart_map('e', unite#do_action('edit'))
    1              0.000013   nnoremap <silent><buffer><expr> p unite#do_action('preview')
    1              0.000017   nmap <silent><buffer><expr> x unite#smart_map('x', "\<Plug>(unite_quick_match_default_action)")
    1              0.000017   nnoremap <silent><buffer><expr> t unite#smart_map('t', unite#do_action('tabopen'))
    1              0.000017   nnoremap <silent><buffer><expr> yy unite#smart_map('yy', unite#do_action('yank'))
                            
                              " Visual mode key-mappings.
    1              0.000019   xmap <buffer> <Space> <Plug>(unite_toggle_mark_selected_candidates)
                            
                              " Insert mode key-mappings.
    1              0.000014   imap <buffer> <TAB>     <Plug>(unite_choose_action)
    1              0.000014   imap <buffer> <C-n>     <Plug>(unite_select_next_line)
    1              0.000014   imap <buffer> <Down>     <Plug>(unite_select_next_line)
    1              0.000015   imap <buffer> <C-p>     <Plug>(unite_select_previous_line)
    1              0.000015   imap <buffer> <Up>     <Plug>(unite_select_previous_line)
    1              0.000013   imap <buffer> <C-f>     <Plug>(unite_select_next_page)
    1              0.000014   imap <buffer> <C-b>     <Plug>(unite_select_previous_page)
    1              0.000014   imap <buffer> <CR>      <Plug>(unite_do_default_action)
    1              0.000014   imap <buffer> <C-h>     <Plug>(unite_delete_backward_char)
    1              0.000014   imap <buffer> <BS>      <Plug>(unite_delete_backward_char)
    1              0.000013   imap <buffer> <C-u>     <Plug>(unite_delete_backward_line)
    1              0.000014   imap <buffer> <C-w>     <Plug>(unite_delete_backward_word)
    1              0.000012   imap <buffer> <C-a>     <Plug>(unite_move_head)
    1              0.000013   imap <buffer> <Home>    <Plug>(unite_move_head)
    1              0.000012   imap <buffer> <C-l>     <Plug>(unite_redraw)
    1              0.000005   if has('gui_running')
                                imap <buffer> <ESC>     <Plug>(unite_insert_leave)
                              endif
    1              0.000012   imap <buffer> <C-g>     <Plug>(unite_exit)
                            
    1              0.000018   imap <silent><buffer><expr> <Space> unite#smart_map(' ', "\<Plug>(unite_toggle_mark_current_candidate)")
    1              0.000019   imap <silent><buffer><expr> <S-Space> unite#smart_map(' ', "\<Plug>(unite_toggle_mark_current_candidate_up)")
                            
    1              0.000013   inoremap <silent><buffer><expr> <C-d> unite#do_action('delete')
    1              0.000016   inoremap <silent><buffer><expr> <C-e> unite#do_action('edit')
    1              0.000013   inoremap <silent><buffer><expr> <C-t> unite#do_action('tabopen')
    1              0.000013   inoremap <silent><buffer><expr> <C-y> unite#do_action('yank')

FUNCTION  353()
Called 3 times
Total time:   0.033734
 Self time:   0.000223

count  total (s)   self (s)
                                "throwaway buffer options
    3              0.000012     setlocal noswapfile
    3              0.000010     setlocal buftype=nofile
    3              0.000008     setlocal bufhidden=hide
    3              0.000006     setlocal nowrap
    3              0.000013     setlocal foldcolumn=0
    3              0.000007     setlocal foldmethod=manual
    3              0.000005     setlocal nofoldenable
    3              0.000004     setlocal nobuflisted
    3              0.000006     setlocal nospell
    3              0.000006     if g:NERDTreeShowLineNumbers
    3              0.000014         setlocal nu
    3              0.000003     else
                                    setlocal nonu
                                    if v:version >= 703
                                        setlocal nornu
                                    endif
                                endif
                            
    3              0.000003     iabc <buffer>
                            
    3              0.000005     if g:NERDTreeHighlightCursorline
    3              0.000006         setlocal cursorline
    3              0.000003     endif
                            
    3   0.000040   0.000013     call self._setupStatusline()
                            
    3              0.000007     let b:treeShowHelp = 0
    3              0.000007     let b:NERDTreeIgnoreEnabled = 1
    3              0.000011     let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    3              0.000009     let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    3              0.000008     let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    3   0.024824   0.000011     setfiletype nerdtree
    3   0.008685   0.000014     call self._bindMappings()

FUNCTION  unite#util#get_vital()
Called 23 times
Total time:   0.019487
 Self time:   0.000290

count  total (s)   self (s)
   23              0.000092   if !exists('s:V')
    1   0.019204   0.000007     let s:V = vital#of('unite.vim')
    1              0.000001   endif
   23              0.000047   return s:V

FUNCTION  <SNR>109_get_syn()
Called 70244 times
Total time:   2.891816
 Self time:   2.891816

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
70244              0.417537   let mode = has('gui_running') ? 'gui' : 'cterm'
70244              0.829338   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
70244              0.250728   if empty(color) || color == -1
 4784              0.046746     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
 4784              0.004465   endif
70244              0.196554   if empty(color) || color == -1
                                if has('gui_running')
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
70244              0.098603   return color

FUNCTION  <SNR>30_on_window_changed()
Called 101 times
Total time:   0.971763
 Self time:   0.003459

count  total (s)   self (s)
  101              0.000741   if pumvisible()
                                return
                              endif
  101   0.006107   0.000984   call <sid>init()
  101   0.964171   0.000990   call airline#update_statusline()

FUNCTION  <SNR>55_record()
Called 152 times
Total time:   0.060122
 Self time:   0.018723

count  total (s)   self (s)
  152              0.001710 	if s:locked | retu | en
  152              0.001573 	let bufnr = a:bufnr + 0
  152              0.001574 	let bufname = bufname(bufnr)
  152              0.001276 	if bufnr > 0 && !empty(bufname)
  150              0.007493 		cal filter(s:mrbs, 'v:val != bufnr')
  150              0.001497 		cal insert(s:mrbs, bufnr)
  150   0.043604   0.002205 		cal s:addtomrufs(bufname)
  150              0.000240 	en

FUNCTION  <SNR>145_set_cursor_line()
Called 7 times
Total time:   0.000703
 Self time:   0.000566

count  total (s)   self (s)
    7   0.000210   0.000073   let unite = unite#get_current_unite()
    7              0.000033   let prompt_linenr = unite.prompt_linenr
    7              0.000029   let context = unite.context
                            
    7              0.000340   execute 'match' (line('.') <= prompt_linenr ? line('$') <= prompt_linenr ? 'uniteError /\%'.prompt_linenr.'l/' : context.cursor_line_highlight.' /\%'.(prompt_linenr+1).'l/' : context.cursor_line_highlight.' /^\%#.*/')
    7              0.000063   let unite.cursor_line_time = reltime()

FUNCTION  unite#filters#converter_default#define()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return s:converter

FUNCTION  <SNR>195_set_syntax()
Called 3 times
Total time:   0.000413
 Self time:   0.000353

count  total (s)   self (s)
    3   0.000083   0.000023   let unite = unite#get_current_unite()
    3              0.000011   let source_padding = 3
                            
    3              0.000018   let abbr_head = unite.max_source_name+source_padding
    3              0.000031   silent! syntax clear uniteCandidateAbbr
    3              0.000073   execute 'syntax region uniteCandidateAbbr' 'start=/\%' .(abbr_head).'c/ end=/$/ keepend contained'
                            
                              " Set syntax.
    6              0.000063   for source in filter(copy(unite.sources), 'v:val.syntax != ""')
    3              0.000031     silent! execute 'syntax clear' source.syntax
    3              0.000047     execute 'syntax region' source.syntax 'start=// end=/$/ keepend contained'
    3              0.000005   endfor

FUNCTION  <SNR>145_check_redraw()
Called 1 time
Total time:   0.000353
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000017   0.000006   let unite = unite#get_current_unite()
    1              0.000002   let prompt_linenr = unite.prompt_linenr
    1              0.000003   if line('.') == prompt_linenr || unite.context.is_redraw
                                " Redraw.
    1   0.000180   0.000004     call unite#redraw()
    1   0.000145   0.000007     call s:change_highlight()
    1              0.000001   endif

FUNCTION  <SNR>187_strwidthpart()
Called 1 time
Total time:   0.000032
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002   if a:width <= 0
                                return ''
                              endif
    1              0.000002   let ret = a:str
    1   0.000011   0.000007   let width = s:wcswidth(a:str)
    1              0.000003   while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
    1              0.000002   return ret

FUNCTION  airline#extensions#undotree#apply()
Called 99 times
Total time:   0.003985
 Self time:   0.003985

count  total (s)   self (s)
   99              0.000635   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{t:undotree.GetStatusLine()}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{t:diffpanel.GetStatusLine()}')
                                endif
                              endif

FUNCTION  <SNR>79_SyntasticRegistryNormaliseFiletype()
Called 38 times
Total time:   0.001891
 Self time:   0.001891

count  total (s)   self (s)
   38              0.000507     let ft = get(s:defaultFiletypeMap, a:ftalias, a:ftalias)
   38              0.000426     let ft = get(g:syntastic_filetype_map, ft, ft)
   38              0.000526     let ft = substitute(ft, '\m-', '_', 'g')
   38              0.000137     return ft

FUNCTION  syntastic#log#debug()
Called 810 times
Total time:   0.021122
 Self time:   0.013293

count  total (s)   self (s)
  810   0.017471   0.009642     if !s:isDebugEnabled(a:level)
  810              0.001578         return
                                endif
                            
                                let leader = s:logTimestamp()
                                call s:logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 167 times
Total time:   0.918759
 Self time:   0.032573

count  total (s)   self (s)
                                " for 7.2; we cannot iterate the list, hence why we use range()
                                " for 7.3-[97, 328]; we cannot reuse the variable, hence the {}
  795              0.003772     for i in range(0, len(a:list) - 1)
  795              0.007892       let Fn{i} = a:list[i]
  795   0.899579   0.013393       let code = call(Fn{i}, a:000)
  795              0.002235       if code != 0
  167              0.000355         return code
                                  endif
  628              0.001036     endfor
                                return 0

FUNCTION  <SNR>191_read_pipes()
Called 2 times
Total time:   0.013407
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000019   if type(self.fd[-1]) != type({})
                                let self.eof = 1
                                return ''
                              endif
                            
    2              0.000014   let number = get(a:000, 0, -1)
    2              0.000015   let timeout = get(a:000, 1, s:read_timeout)
                            
    2   0.013311   0.000033   let output = self.fd[-1].read(number, timeout)
    2              0.000016   let self.eof = self.fd[-1].eof
                            
    2              0.000006   return output

FUNCTION  unite#util#is_cmdwin()
Called 5 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    5              0.000050   return bufname('%') ==# '[Command Line]'

FUNCTION  AutoPairsSpace()
Called 91 times
Total time:   0.009618
 Self time:   0.009618

count  total (s)   self (s)
   91              0.002568   let line = getline('.')
   91              0.001953   let prev_char = line[col('.')-2]
   91              0.000389   let cmd = ''
   91              0.000942   let cur_char =line[col('.')-1]
   91              0.001291   if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>\<LEFT>"
                              endif
   91              0.000961   return "\<SPACE>".cmd

FUNCTION  neosnippet#helpers#get_filetype()
Called 20 times
Total time:   0.001582
 Self time:   0.001582

count  total (s)   self (s)
   20              0.000215   if !exists('s:exists_context_filetype')
                                " context_filetype.vim installation check.
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
   20              0.000331   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   20              0.000135   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
                            
   20              0.000085   return context_filetype

FUNCTION  vimproc#util#iconv()
Called 3 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    3              0.000025   if !has('iconv') || a:expr == '' || a:from == '' || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
    3              0.000059   let result = iconv(a:expr, a:from, a:to)
    3              0.000009   return result != '' ? result : a:expr

FUNCTION  airline#extensions#unite#apply()
Called 102 times
Total time:   0.014592
 Self time:   0.004644

count  total (s)   self (s)
  102              0.001748   if &ft == 'unite'
    3   0.000713   0.000051     call a:1.add_section('airline_a', ' Unite ')
    3   0.003253   0.000049     call a:1.add_section('airline_b', ' %{get(unite#get_context(), "buffer_name", "")} ')
    3   0.003079   0.000055     call a:1.add_section('airline_c', ' %{unite#get_status_string()} ')
    3   0.000114   0.000057     call a:1.split()
    3   0.003047   0.000046     call a:1.add_section('airline_y', ' %{get(unite#get_context(), "real_buffer_name", "")} ')
    3              0.000009     return 1
                              endif

FUNCTION  unite#variables#filters()
Called 7 times
Total time:   0.019740
 Self time:   0.000446

count  total (s)   self (s)
    7              0.000023   if a:0 == 0
                                call unite#init#_default_scripts('filters', [])
                              else
    7   0.018885   0.000098     call unite#init#_default_scripts('filters', [a:1])
    7              0.000011   endif
                            
    7   0.000627   0.000120   let filters = unite#init#_filters()
                            
    7              0.000023   if a:0 == 0
                                return filters
                              endif
                            
    7              0.000049   return get(filters, a:1, {})

FUNCTION  unite#get_unite_candidates()
Called 7 times
Total time:   0.000214
 Self time:   0.000074

count  total (s)   self (s)
    7   0.000192   0.000052   return unite#get_current_unite().current_candidates

FUNCTION  vimproc#util#set_default()
Called 9 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    9              0.000048   if !exists(a:var) || type({a:var}) != type(a:val)
    6              0.000023     let alternate_var = get(a:000, 0, '')
                            
    6              0.000040     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
    6              0.000006   endif

FUNCTION  <SNR>109_exec_separator()
Called 17561 times
Total time:   6.918519
 Self time:   0.882579

count  total (s)   self (s)
17561   2.794006   0.148197   let l:from = airline#themes#get_highlight(a:from.a:suffix)
17561   2.628915   0.149132   let l:to = airline#themes#get_highlight(a:to.a:suffix)
17561              0.088578   let group = a:from.'_to_'.a:to.a:suffix
17561              0.028860   if a:inverse
 8241              0.064552     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
 8241              0.009098   else
 9320              0.067082     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
 9320              0.009431   endif
17561              0.076864   let a:dict[group] = colors
17561   1.034409   0.124061   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>26_SynSet()
Called 8 times
Total time:   0.021113
 Self time:   0.007199

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    8              0.000077   syn clear
    8              0.000032   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    8              0.000037   let s = expand("<amatch>")
    8              0.000020   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              endif
                            
    8              0.000012   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   16              0.000075     for name in split(s, '\.')
    8   0.020633   0.006719       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    8              0.000024     endfor
    8              0.000009   endif

FUNCTION  <SNR>187_truncate()
Called 2 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
    2              0.000168   if a:str =~# '^[\x00-\x7f]*$'
    2              0.000039     return len(a:str) < a:width ? printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret

FUNCTION  unite#custom#get_profile()
Called 9 times
Total time:   0.000585
 Self time:   0.000369

count  total (s)   self (s)
    9              0.000076   let profile_name = (a:profile_name == '' ? 'default' : a:profile_name)
    9   0.000283   0.000067   let custom = unite#custom#get()
                            
    9              0.000052   if !has_key(custom.profiles, profile_name)
    2              0.000020     let custom.profiles[profile_name] = { 'substitute_patterns' : {}, 'filters' : [], 'context' : {}, 'ignorecase' : &ignorecase, 'smartcase' : &smartcase, 'unite__save_pos' : {}, 'unite__inputs' : {}, }
    2              0.000002   endif
                            
    9              0.000051   return custom.profiles[profile_name][a:option_name]

FUNCTION  <SNR>187_wcswidth()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000018     return strwidth(a:str)

FUNCTION  neosnippet#mappings#expandable()
Called 17 times
Total time:   0.039152
 Self time:   0.001200

count  total (s)   self (s)
                              " Check snippet trigger.
   17   0.039051   0.001099   return neosnippet#helpers#get_cursor_snippet( neosnippet#helpers#get_snippets(), neosnippet#util#get_cur_text()) != ''

FUNCTION  <SNR>190_make_aliases()
Called 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000003   let aliases = []
    1              0.000005   for [name, config] in items(g:unite_source_alias_aliases)
                                let args = (!has_key(config, 'args')) ? [] : (type(config.args) == type([])) ? config.args : [config.args]
                            
                                let alias = {}
                                let alias.name = name
                                let alias.description = get(config, 'description', s:make_default_description(config.source, args))
                                let alias.source__config = config
                                let alias.source__args = args
                                let alias.hooks = {}
                            
                                function! alias.hooks.on_pre_init(args, context)
                                  let config = a:context.source.source__config
                                  let original_source = (!has_key(config, 'source') ||  config.source ==# a:context.source.name) ? {} : deepcopy(unite#get_all_sources(config.source))
                                  let alias_source = deepcopy(a:context.source)
                            
                                  if has_key(original_source, 'hooks') && has_key(original_source.hooks, 'on_pre_init')
                                    " Call pre init hook.
                                    call original_source.hooks.on_pre_init( a:context.source.source__args + a:args, { 'source' : original_source })
                                  endif
                            
                                  let source = extend(a:context.source, filter(copy(original_source), 'type(v:val) != type(function("type"))'))
                                  let source.name = alias_source.name
                                  let source.description = alias_source.description
                                  let source.hooks = {}
                                  let source.source__original_source = original_source
                                  let source.source__args = a:context.source.source__args
                            
                                  " Overwrite hooks.
                                  if has_key(original_source, 'hooks')
                                    for func in filter(keys(original_source.hooks), 'v:val !=# "on_pre_init"')
                                      let define_function = join([ 'function! source.hooks.' . func . '(args, context)', '  let args = a:context.source.source__args + a:args', '  return a:context.source.source__original_source.hooks.'                    . func . '(args, a:context)', 'endfunction'], "\n")
                                      execute define_function
                                    endfor
                                  endif
                            
                                  " Overwrite functions.
                                  for func in keys(filter(copy(original_source), 'type(v:val) == type(function("type"))'))
                                    if func ==# 'complete'
                                      let define_function = join([ 'function! source.' . func . '(args, context, arglead, cmdline, cursorpos)', '  let args = self.source__args + a:args', '  return self.source__original_source.'                    . func .   '(args, a:context, a:arglead, a:cmdline, a:cursorpos)', 'endfunction'], "\n")
                                    else
                                      let define_function = join([ 'function! source.' . func . '(args, context)', '  let args = self.source__args + a:args', '  return self.source__original_source.'                    . func . '(args, a:context)', 'endfunction'], "\n")
                                    endif
                                    execute define_function
                                  endfor
                                endfunction
                            
                                call add(aliases, alias)
                              endfor
                            
    1              0.000002   return aliases

FUNCTION  unite#helper#get_postfix()
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000006   let buffers = get(a:000, 0, range(1, bufnr('$')))
    1              0.000036   let buflist = sort(filter(map(buffers, 'bufname(v:val)'), 'stridx(v:val, a:prefix) >= 0'))
    1              0.000002   if empty(buflist)
    1              0.000001     return ''
                              endif
                            
                              return a:is_create ? '@'.(matchstr(buflist[-1], '@\zs\d\+$') + 1) : matchstr(buflist[-1], '@\d\+$')

FUNCTION  repeat#wrap()
Called 7 times
Total time:   0.014550
 Self time:   0.014550

count  total (s)   self (s)
    7              0.000110     let preserve = (g:repeat_tick == b:changedtick)
    7              0.014292     exe 'norm! '.(a:count ? a:count : '').a:command . (&foldopen =~# 'undo' ? 'zv' : '')
    7              0.000051     if preserve
                                    let g:repeat_tick = b:changedtick
                                endif

FUNCTION  <SNR>114_add_section()
Called 864 times
Total time:   0.737694
 Self time:   0.037209

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  864              0.003229     if a:key == 'warning'
   93   0.001219   0.000686       call a:builder.add_raw('%(')
   93              0.000120     endif
  864   0.717601   0.018166     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  864              0.003061     if a:key == 'warning'
   93   0.001280   0.000763       call a:builder.add_raw('%)')
   93              0.000104     endif

FUNCTION  <SNR>40_crend()
Called 54 times
Total time:   0.001653
 Self time:   0.001653

count  total (s)   self (s)
   54              0.000448   let n = ""
   54              0.000772   if !exists("b:endwise_addition") || !exists("b:endwise_words") || !exists("b:endwise_syngroups")
   54              0.000205     return n
                              end
                              let synpat  = '\%('.substitute(b:endwise_syngroups,',','\\|','g').'\)'
                              let wordchoice = '\%('.substitute(b:endwise_words,',','\\|','g').'\)'
                              if exists("b:endwise_pattern")
                                let beginpat = substitute(b:endwise_pattern,'&',substitute(wordchoice,'\\','\\&','g'),'g')
                              else
                                let beginpat = '\<'.wordchoice.'\>'
                              endif
                              let lnum = line('.') - 1
                              let space = matchstr(getline(lnum),'^\s*')
                              let col  = match(getline(lnum),beginpat) + 1
                              let word  = matchstr(getline(lnum),beginpat)
                              let endword = substitute(word,'.*',b:endwise_addition,'')
                              let y = n.endword."\<C-O>O"
                              let endpat = '\w\@<!'.endword.'\w\@!'
                              if a:always
                                return y
                              elseif col <= 0 || synIDattr(synID(lnum,col,1),'name') !~ '^'.synpat.'$'
                                return n
                              elseif getline('.') !~ '^\s*#\=$'
                                return n
                              endif
                              let line = s:mysearchpair(beginpat,endpat,synpat)
                              " even is false if no end was found, or if the end found was less
                              " indented than the current line
                              let even = strlen(matchstr(getline(line),'^\s*')) >= strlen(space)
                              if line == 0
                                let even = 0
                              endif
                              if !even && line == line('.') + 1
                                return y
                              endif
                              if even
                                return n
                              endif
                              return y

FUNCTION  339()
Called 3 times
Total time:   0.008671
 Self time:   0.000475

count  total (s)   self (s)
                                "make <cr> do the same as the default 'o' mapping
    3              0.000165     exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"
                            
    3   0.008218   0.000022     call g:NERDTreeKeyMap.BindAll()
                            
    3              0.000038     command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
    3              0.000037     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
    3              0.000032     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
    3              0.000030     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
    3              0.000032     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
    3              0.000038     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
    3              0.000041     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
    3              0.000022     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  <SNR>191_vp_dlopen()
Called 1 time
Total time:   0.000742
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000739   0.000008   let [handle] = s:libcall('vp_dlopen', [a:path])
    1              0.000002   return handle

FUNCTION  <SNR>195_redraw_echo()
Called 2 times
Total time:   0.020867
 Self time:   0.020857

count  total (s)   self (s)
    2              0.000010   if has('vim_starting')
                                echo join(s:msg2list(a:expr), "\n")
                                return
                              endif
                            
    2   0.000021   0.000011   let msg = s:msg2list(a:expr)
    2              0.000010   let height = max([1, &cmdheight])
    4              0.000015   for i in range(0, len(msg)-1, height)
    2              0.020692     redraw
    2              0.000086     echo join(msg[i : i+height-1], "\n")
    2              0.000004   endfor

FUNCTION  syntastic#log#debugShowOptions()
Called 37 times
Total time:   0.001156
 Self time:   0.000795

count  total (s)   self (s)
   37   0.000907   0.000546     if !s:isDebugEnabled(a:level)
   37              0.000095         return
                                endif
                            
                                let leader = s:logTimestamp()
                                call s:logRedirect(1)
                            
                                let vlist = type(a:names) == type("") ? [a:names] : a:names
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val)))")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:logRedirect(0)

FUNCTION  airline#check_mode()
Called 7979 times
Total time:   5.606838
 Self time:   0.845211

count  total (s)   self (s)
 7979              0.053876   let context = s:contexts[a:winnr]
                            
 7979              0.037273   if get(w:, 'airline_active', 1)
 5711              0.027995     let l:m = mode()
 5711              0.016512     if l:m ==# "i"
 4237              0.016340       let l:mode = ['insert']
 4237              0.007795     elseif l:m ==# "R"
    5              0.000031       let l:mode = ['replace']
    5              0.000009     elseif l:m =~# '\v(v|V||s|S|)'
  125              0.000453       let l:mode = ['visual']
  125              0.000140     else
 1344              0.006387       let l:mode = ['normal']
 1344              0.002143     endif
 5711              0.047962     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
 5711              0.007321   else
 2268              0.006375     let l:mode = ['inactive']
 2268              0.011546     let w:airline_current_mode = get(g:airline_mode_map, '__')
 2268              0.002149   endif
                            
 7979              0.019331   if g:airline_detect_modified
 7979              0.021052     if &modified
 4391              0.045322       call add(l:mode, 'modified')
 4391              0.006011     endif
 7979              0.007720   endif
                            
 7979              0.023079   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
 7979              0.056284   let mode_string = join(l:mode)
 7979              0.047350   if get(w:, 'airline_lastmode', '') != mode_string
  200   0.025871   0.002062     call airline#highlighter#highlight_modified_inactive(context.bufnr)
  200   4.739959   0.002141     call airline#highlighter#highlight(l:mode)
  200              0.000733     let w:airline_lastmode = mode_string
  200              0.000150   endif
                            
 7979              0.011149   return ''

FUNCTION  67()
Called 35 times
Total time:   0.006582
 Self time:   0.005966

count  total (s)   self (s)
   35              0.000134     if !exists("self._cachedMessages")
   32              0.000106         let self._cachedMessages = {}
   32   0.000959   0.000343         let errors = self.errors() + (self._quietWarnings ? [] : self.warnings())
                            
  252              0.000293         for e in errors
  220              0.000475             let b = e['bufnr']
  220              0.000428             let l = e['lnum']
                            
  220              0.000616             if !has_key(self._cachedMessages, b)
   32              0.000134                 let self._cachedMessages[b] = {}
   32              0.000034             endif
                            
  220              0.000707             if !has_key(self._cachedMessages[b], l)
  172              0.000781                 let self._cachedMessages[b][l] = e['text']
  172              0.000170             endif
  220              0.000189         endfor
   32              0.000028     endif
                            
   35              0.000149     return get(self._cachedMessages, a:buf, {})

FUNCTION  <SNR>108_wrap_accent()
Called 14 times
Total time:   0.000255
 Self time:   0.000202

count  total (s)   self (s)
   14              0.000047   if exists('a:part.accent')
   14   0.000130   0.000077     call airline#highlighter#add_accent(a:part.accent)
   14              0.000065     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  neosnippet#helpers#get_snippets_directory()
Called 3 times
Total time:   0.000200
 Self time:   0.000085

count  total (s)   self (s)
    3   0.000047   0.000024   let snippets_dir = copy(neosnippet#variables#snippets_dir())
    3   0.000098   0.000027   if !get(g:neosnippet#disable_runtime_snippets, neosnippet#helpers#get_filetype(), get(g:neosnippet#disable_runtime_snippets, '_', 0))
    3   0.000044   0.000023     let snippets_dir += neosnippet#variables#runtime_dir()
    3              0.000003   endif
                            
    3              0.000004   return snippets_dir

FUNCTION  <SNR>55_mergelists()
Called 5 times
Total time:   0.002817
 Self time:   0.001694

count  total (s)   self (s)
    5   0.001124   0.000116 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    5              0.001357 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    5              0.000143 	let mrufs = s:mrufs + diskmrufs
    5   0.000174   0.000059 	retu s:chop(mrufs)

FUNCTION  <SNR>205_get_candidates_action_table()
Called 2 times
Total time:   0.071519
 Self time:   0.000343

count  total (s)   self (s)
    2              0.000014   let action_tables = []
    2   0.000137   0.000029   let Self = unite#get_self_functions()[-1]
    4              0.000020   for candidate in a:candidates
    2   0.068599   0.000034     let action_table = unite#action#_get_candidate_action_table( candidate, a:sources)
                            
    2              0.000006     let action_name = a:action_name
    2              0.000004     if action_name ==# 'default'
                                  " Get default action.
    2   0.002526   0.000023       let action_name = unite#action#get_default_action( candidate.source, candidate.kind)
    2              0.000001     endif
                            
    2              0.000003     if action_name == ''
                                  " Ignore.
                                  return []
                                endif
                            
    2              0.000006     if !has_key(action_table, action_name)
                                  call unite#util#print_error( candidate.unite__abbr . '(' . candidate.source . ')')
                                  call unite#util#print_error( 'No such action : ' . action_name)
                            
                                  return []
                                endif
                            
    2              0.000006     let action = action_table[action_name]
                            
                                " Check selectable flag.
    2              0.000005     if !action.is_selectable && len(a:candidates) > 1
                                  call unite#util#print_error( candidate.unite__abbr . '(' . candidate.source . ')')
                                  call unite#util#print_error( 'Not selectable action : ' . action_name)
                                  return []
                                endif
                            
    2              0.000004     let found = 0
    2              0.000004     for table in action_tables
                                  if action == table.action
                                    " Add list.
                                    call add(table.candidates, candidate)
                                    call add(table.source_names, candidate.source)
                                    let found = 1
                                    break
                                  endif
                                endfor
                            
    2              0.000002     if !found
                                  " Add action table.
    2              0.000018       call add(action_tables, { 'action' : action, 'source_names' : [candidate.source], 'candidates' : (!action.is_selectable ? candidate : [candidate]), })
    2              0.000002     endif
    2              0.000002   endfor
                            
    2              0.000003   return action_tables

FUNCTION  <SNR>130_handleLeftClick()
Called 8 times
Total time:   0.045457
 Self time:   0.000936

count  total (s)   self (s)
    8   0.044622   0.000101     let currentNode = g:NERDTreeFileNode.GetSelected()
    8              0.000018     if currentNode != {}
                            
                                    "the dir arrows are multibyte chars, and vim's string functions only
                                    "deal with single bytes - so split the line up with the hack below and
                                    "take the line substring manually
    6              0.000074         let line = split(getline(line(".")), '\zs')
    6              0.000011         let startToCur = ""
   82              0.000096         for i in range(0,len(line)-1)
   76              0.000193             let startToCur .= line[i]
   76              0.000055         endfor
                            
    6              0.000010         if currentNode.path.isDirectory
                                        if startToCur =~# nerdtree#treeMarkupReg() && startToCur =~# '[+~] \?$'
                                            call currentNode.activate()
                                            return
                                        endif
                                    endif
                            
    6              0.000023         if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                        let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                        if char !~# nerdtree#treeMarkupReg()
                                            if currentNode.path.isDirectory
                                                call currentNode.activate()
                                            else
                                                call currentNode.activate({'reuse': 1, 'where': 'p'})
                                            endif
                                            return
                                        endif
                                    endif
    6              0.000005     endif

FUNCTION  nerdtree#renderView()
Called 6 times
Total time:   0.039258
 Self time:   0.002047

count  total (s)   self (s)
    6              0.000055     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
    6              0.000037     let curLine = line(".")
    6              0.000031     let curCol = col(".")
    6              0.000034     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
    6              0.000650     silent 1,$delete _
                            
    6   0.007013   0.000088     call nerdtree#dumpHelp()
                            
                                "delete the blank line before the help and add one after it
    6              0.000016     if g:NERDTreeMinimalUI == 0
    6              0.000062         call setline(line(".")+1, "")
    6              0.000043         call cursor(line(".")+1, col("."))
    6              0.000007     endif
                            
    6              0.000016     if b:NERDTreeShowBookmarks
    6   0.000446   0.000048         call nerdtree#renderBookmarks()
    6              0.000007     endif
                            
                                "add the 'up a dir' line
    6              0.000014     if !g:NERDTreeMinimalUI
    6   0.000087   0.000069         call setline(line(".")+1, nerdtree#treeUpDirLine())
    6              0.000037         call cursor(line(".")+1, col("."))
    6              0.000009     endif
                            
                                "draw the header line
    6   0.000767   0.000086     let header = b:NERDTreeRoot.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    6              0.000050     call setline(line(".")+1, header)
    6              0.000038     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
    6              0.000021     let old_o = @o
    6   0.029252   0.000063     let @o = b:NERDTreeRoot.renderToString()
    6              0.000100     silent put o
    6              0.000033     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
    6              0.000055     silent 1,1delete _
                            
                                "restore the view
    6              0.000026     let old_scrolloff=&scrolloff
    6              0.000036     let &scrolloff=0
    6              0.000024     call cursor(topLine, 1)
    6              0.000089     normal! zt
    6              0.000021     call cursor(curLine, curCol)
    6              0.000024     let &scrolloff = old_scrolloff
                            
    6              0.000021     setlocal nomodifiable

FUNCTION  <SNR>186__build_module()
Called 11 times
Total time:   0.040888
 Self time:   0.013479

count  total (s)   self (s)
   11              0.000040   if has_key(s:loaded, a:sid)
    6              0.000075     return copy(s:loaded[a:sid])
                              endif
    5   0.032470   0.000122   let functions = s:_get_functions(a:sid)
                            
    5              0.000032   let prefix = '<SNR>' . a:sid . '_'
    5              0.000012   let module = {}
  127              0.000143   for func in functions
  122              0.000615     let module[func] = function(prefix . func)
  122              0.000100   endfor
    5              0.000014   if has_key(module, '_vital_loaded')
    1              0.001581     let V = vital#{s:self_version}#new()
    1              0.000003     if has_key(module, '_vital_depends')
    1   0.001686   0.001683       call call(V.load, module._vital_depends(), V)
    1              0.000001     endif
    1              0.000001     try
    1              0.001650       call module._vital_loaded(V)
    1              0.000001     catch
                                  " FIXME: Show an error message for debug.
                                endtry
    1              0.000001   endif
    5              0.000014   if !get(g:, 'vital_debug', 0)
    5              0.000331     call filter(module, 'v:key =~# "^\\a"')
    5              0.000005   endif
    5              0.000023   let s:loaded[a:sid] = module
    5              0.000042   return copy(module)

FUNCTION  <SNR>180_RemoveDir()
Called 32 times
Total time:   0.365983
 Self time:   0.012697

count  total (s)   self (s)
   32              0.000513     if isdirectory(a:dir)
   32              0.003105         for f in split(globpath(a:dir, '*'), "\n")
                                        call s:RemoveDir(f)
                                    endfor
   32   0.359821   0.006535         silent! call system('rmdir ' . a:dir)
   32              0.000489     else
                                    silent! call delete(a:dir)
                                endif

FUNCTION  airline#util#append()
Called 10954 times
Total time:   0.218214
 Self time:   0.218214

count  total (s)   self (s)
10954              0.042770   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
10954              0.073037   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
10954              0.062915   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>68_UpdateLastColumn()
Called 98 times
Total time:   0.008384
 Self time:   0.008384

count  total (s)   self (s)
                              " Function to save the current column and buffer and window numbers,
   98              0.000906   if !exists('w:BufKillList')
                                " Just give up for now.
                                return
                              endif
   98              0.001315   let index = index(w:BufKillList, bufnr('%'))
   98              0.000374   if index != -1
                                " Extend list if required, then set the value
   98              0.002183     let w:BufKillColumnList += repeat([0], index - len(w:BufKillColumnList) + 1)
   98              0.001191     let w:BufKillColumnList[index] = col('.')
   98              0.000258   else
                                echom 'UpdateLastColumn failed to find bufnr ' . bufnr('%') . ' in w:BufKillList'
                              endif

FUNCTION  vimproc#plineopen3()
Called 1 time
Total time:   0.010328
 Self time:   0.000516

count  total (s)   self (s)
    1   0.005071   0.000490   let commands = type(a:commands) == type('') ? vimproc#parser#parse_pipe(a:commands) : a:commands
    1              0.000004   let is_pty = get(a:000, 0, 0)
                            
    1   0.005251   0.000020   return s:plineopen(3, commands, is_pty)

FUNCTION  unite#variables#loaded_sources()
Called 29 times
Total time:   0.001054
 Self time:   0.000552

count  total (s)   self (s)
                              " Initialize load.
   29   0.000737   0.000235   let unite = unite#get_current_unite()
   29              0.000252   return a:0 == 0 ? unite.sources : get(filter(copy(unite.sources), 'v:val.name ==# a:1'), 0, {})

FUNCTION  vimproc#kill()
Called 1 time
Total time:   0.000278
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000004   if a:sig == 0 && vimproc#util#is_windows()
                                " Use waitpid().
                                let [cond, status] = s:waitpid(a:pid)
                                return cond ==# 'run'
                              endif
                            
    1              0.000001   try
    1   0.000238   0.000011     let [ret] = s:libcall('vp_kill', [a:pid, a:sig])
                              catch
    1              0.000006     let s:last_errmsg = v:exception
    1              0.000003     return 1
                              endtry
                            
                              return ret

FUNCTION  neosnippet#helpers#get_cursor_snippet()
Called 17 times
Total time:   0.001644
 Self time:   0.001644

count  total (s)   self (s)
   17              0.000397   let cur_word = matchstr(a:cur_text, '\S\+$')
   17              0.000176   if cur_word != '' && has_key(a:snippets, cur_word)
                                  return cur_word
                              endif
                            
   20              0.000120   while cur_word != ''
    3              0.000038     if has_key(a:snippets, cur_word) && a:snippets[cur_word].options.word
                                  return cur_word
                                endif
                            
    3              0.000088     let cur_word = substitute(cur_word, '^\%(\w\+\|\W\)', '', '')
    3              0.000019   endwhile
                            
   17              0.000062   return cur_word

FUNCTION  vital#_b6a796b#new()
Called 2 times
Total time:   0.021610
 Self time:   0.000085

count  total (s)   self (s)
    2   0.021608   0.000083   return s:_import('').load(['Prelude', ''])

FUNCTION  ctrlp#utils#writecache()
Called 5 times
Total time:   0.001908
 Self time:   0.001778

count  total (s)   self (s)
    5   0.000233   0.000103 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    5              0.001632 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    5              0.000020 	en

FUNCTION  AutoPairsInsert()
Called 57 times
Total time:   0.021589
 Self time:   0.021589

count  total (s)   self (s)
   57              0.000833   if !b:autopairs_enabled
                                return a:key
                              end
                            
   57              0.000814   let line = getline('.')
   57              0.000764   let pos = col('.') - 1
   57              0.000557   let before = strpart(line, 0, pos)
   57              0.000370   let after = strpart(line, pos)
   57              0.000947   let next_chars = split(after, '\zs')
   57              0.000523   let current_char = get(next_chars, 0, '')
   57              0.000372   let next_char = get(next_chars, 1, '')
   57              0.002030   let prev_chars = split(before, '\zs')
   57              0.000416   let prev_char = get(prev_chars, -1, '')
                            
   57              0.000186   let eol = 0
   57              0.000455   if col('$') -  col('.') <= 1
   53              0.000219     let eol = 1
   53              0.000086   end
                            
                              " Ignore auto close if prev character is \
   57              0.000303   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
   57              0.000441   if !has_key(b:AutoPairs, a:key)
   19              0.000146     let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
   19              0.000047     if current_char == a:key
   19              0.000088       return "\<Right>"
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return "\<Right>\<Right>"
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    let next_lineno = line('.')+1
                                    let next_line = getline(nextnonblank(next_lineno))
                                    let next_char = matchstr(next_line, '\s*\zs.')
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  if search(a:key, 'W')
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
   38              0.000215   let open = a:key
   38              0.000348   let close = b:AutoPairs[open]
                            
   38              0.000246   if current_char == close && open == close
    4              0.000019     return "\<Right>"
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
   34              0.000191   if a:key == "'" && prev_char =~ '\v\w'
    1              0.000014     return a:key
                              end
                            
                              " support for ''' ``` and """
   33              0.000141   if open == close
                                " The key must be ' " `
    9              0.000113     let pprev_char = line[col('.')-3]
    9              0.000058     if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat("\<LEFT>", 3)
                                end
    9              0.000012   end
                            
   33              0.000217   let quotes_num = 0
                              " Ignore comment line for vim file
   33              0.000282   if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
   33              0.000207   if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
    9              0.000384     let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
    9              0.000061     let n = quotes_num
    9              0.000035     let pos = 0
   11              0.000043     while 1
   11              0.000120       let pos = stridx(cleaned_line, open, pos)
   11              0.000039       if pos == -1
    9              0.000034         break
                                  end
    2              0.000005       let n = n + 1
    2              0.000004       let pos = pos + 1
    2              0.000004     endwhile
    9              0.000037     if n % 2 == 1
                                  return a:key
                                endif
    9              0.000019   endif
                            
   33              0.000408   return open.close."\<Left>"

FUNCTION  airline#themes#get_highlight()
Called 35122 times
Total time:   5.125592
 Self time:   0.326736

count  total (s)   self (s)
35122   5.105299   0.306443   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  unite#util#expand()
Called 1 time
Total time:   0.000131
 Self time:   0.000082

count  total (s)   self (s)
    1   0.000127   0.000078   return unite#util#get_vital().substitute_path_separator( (a:path =~ '^\~') ? substitute(a:path, '^\~', expand('~'), '') : (a:path =~ '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path)

FUNCTION  unite#do_action()
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000058   return printf("%s:\<C-u>call unite#action#do(%s)\<CR>",             (mode() ==# 'i' ? "\<ESC>" : ''), string(a:action))

FUNCTION  <SNR>61_append()
Called 63 times
Total time:   0.001540
 Self time:   0.001540

count  total (s)   self (s)
   63              0.000248   if &filetype == 'unite'
                                " Ignore unite window.
    2              0.000007     return
                              endif
                            
                              " Save unite window information.
   61              0.000926   let w:unite_window = { 'time' : localtime(), 'cwd' : getcwd(),}

FUNCTION  <SNR>219_convert2dictionary()
Called 55 times
Total time:   0.000743
 Self time:   0.000743

count  total (s)   self (s)
   55              0.000707   return { 'word' : a:list[0], 'source__time' : str2nr(a:list[1]), 'action__path' : fnamemodify(a:list[0], ':p'), }

FUNCTION  <SNR>62_call_unite_empty()
Called 1 time
Total time:   0.201601
 Self time:   0.005863

count  total (s)   self (s)
    1   0.013473   0.005824   let [args, options] = unite#helper#parse_options_args(a:args)
    1   0.188123   0.000034   call unite#start(args, options)

FUNCTION  <SNR>158_UseConfigFiles()
Called 5 times
Total time:   0.005383
 Self time:   0.000192

count  total (s)   self (s)
    5              0.000029     if s:editorconfig_core_mode == 'external_command'
                                    call s:UseConfigFiles_ExternalCommand()
                                elseif s:editorconfig_core_mode == 'python_builtin'
    5   0.005232   0.000041         call s:UseConfigFiles_Python_Builtin()
    5              0.000011     elseif s:editorconfig_core_mode == 'python_external'
                                    call s:UseConfigFiles_Python_External()
                                else
                                    echohl Error | echo "Unknown EditorConfig Core: " . s:editorconfig_core_mode | echohl None
                                endif

FUNCTION  vimproc#util#substitute_path_separator()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  unite#get_kinds()
Called 22 times
Total time:   0.036767
 Self time:   0.000212

count  total (s)   self (s)
   22   0.036751   0.000196   return call('unite#variables#kinds', a:000)

FUNCTION  unite#util#substitute_path_separator()
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000011     return a:path

FUNCTION  <SNR>114_build_sections()
Called 257 times
Total time:   0.768052
 Self time:   0.030358

count  total (s)   self (s)
 1182              0.003647   for key in a:keys
  925              0.004249     if key == 'warning' && !a:context.active
   61              0.000224       continue
                                endif
  864   0.750168   0.012474     call s:add_section(a:builder, a:context, key)
  864              0.001774   endfor

FUNCTION  unite#helper#convert_source_name()
Called 20 times
Total time:   0.001065
 Self time:   0.000405

count  total (s)   self (s)
   20   0.000829   0.000169   let context = unite#get_context()
   20              0.000199   return !context.short_source_names ? a:source_name : a:source_name !~ '\A'  ? a:source_name[:1] : substitute(a:source_name, '\a\zs\a\+', '', 'g')

FUNCTION  unite#init#_loaded_sources()
Called 1 time
Total time:   0.034797
 Self time:   0.000175

count  total (s)   self (s)
    1   0.034622   0.000014   let all_sources = unite#init#_sources( unite#helper#get_source_names(a:sources))
    1              0.000002   let sources = []
                            
    1              0.000001   let number = 0
    2   0.000028   0.000014   for [source, args] in unite#helper#get_source_args(a:sources)
    1              0.000003     if type(source) == type('')
    1              0.000003       let source_name = source
    1              0.000001       unlet source
    1              0.000003       if !has_key(all_sources, source_name)
                                    if a:context.unite__is_vimfiler || a:context.unite__is_complete
                                      " Ignore error.
                                      continue
                                    endif
                            
                                    if source_name =~ '^-'
                                      call unite#util#print_error( 'unite.vim: Invalid option "' . source_name . '" is detected.')
                                      throw 'unite.vim: Invalid option'
                                    else
                                      call unite#util#print_error( 'unite.vim: Invalid source name "' . source_name . '" is detected.')
                                      throw 'unite.vim: Invalid source'
                                    endif
                                  endif
                            
    1              0.000015       let source = deepcopy(all_sources[source_name])
    1              0.000001     else
                                  " Use source dictionary.
                                  call unite#init#_sources(source)
                                endif
                            
    1              0.000002     let source.args = args
    1              0.000002     let source.unite__is_invalidate = 1
                            
    1              0.000023     let source.unite__context = deepcopy(a:context)
    1              0.000004     let source.unite__context.is_async = has_key(source, 'async_gather_candidates')
    1              0.000003     let source.unite__context.source = source
    1              0.000002     let source.unite__candidates = []
    1              0.000002     let source.unite__cached_candidates = []
    1              0.000003     let source.unite__cached_change_candidates = []
    1              0.000002     let source.unite__number = number
    1              0.000001     let number += 1
                            
    1              0.000004     call add(sources, source)
                            
    1              0.000001     unlet source
    1              0.000002   endfor
                            
    1              0.000001   return sources

FUNCTION  neosnippet#util#get_cur_text()
Called 34 times
Total time:   0.001370
 Self time:   0.001370

count  total (s)   self (s)
   34              0.001262   return (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))

FUNCTION  nerdtree#closeTreeIfQuitOnOpen()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000005     if g:NERDTreeQuitOnOpen && nerdtree#isTreeOpen()
                                    call nerdtree#closeTree()
                                endif

FUNCTION  unite#view#_redraw()
Called 4 times
Total time:   0.001503
 Self time:   0.000918

count  total (s)   self (s)
    4   0.000099   0.000046   if unite#util#is_cmdwin()
                                return
                              endif
                            
    4              0.000016   if a:winnr > 0
                                " Set current unite.
                                let unite = getbufvar(winbufnr(a:winnr), 'unite')
                                let unite_save = unite#variables#current_unite()
                                let winnr_save = winnr()
                            
                                execute a:winnr 'wincmd w'
                            
                                let line_save = unite.prompt_linenr
                              endif
                            
    4              0.000013   try
    4              0.000019     if &filetype !=# 'unite'
                                  return
                                endif
                            
    4   0.000182   0.000053     let unite = unite#get_current_unite()
    4              0.000029     let context = unite.context
                            
    4              0.000016     if !context.is_redraw
    4              0.000031       let context.is_redraw = a:is_force
    4              0.000010     endif
                            
    4              0.000012     if context.is_redraw
                                  call unite#clear_message()
                                endif
                            
    4   0.000454   0.000051     let input = unite#helper#get_input()
    4              0.000054     if !context.is_redraw && input ==# unite.last_input && !unite.is_async && !context.is_resize && !a:is_gather_all
    4              0.000010       return
                                endif
                            
                                let is_gather_all = a:is_gather_all || context.log
                            
                                if context.is_redraw || input !=# unite.last_input || unite.is_async
                                  " Recaching.
                                  call unite#candidates#_recache(input, a:is_force)
                                endif
                            
                                let unite.last_input = input
                            
                                " Redraw.
                                call unite#view#_redraw_candidates(is_gather_all)
                                let unite.context.is_redraw = 0
                              finally
    4              0.000013     if a:winnr > 0
                                  if unite.prompt_linenr != line_save
                                    " Updated.
                                    normal! G
                                  endif
                            
                                  " Restore current unite.
                                  call unite#set_current_unite(unite_save)
                                  execute winnr_save 'wincmd w'
                                endif
    4              0.000014   endtry
                            
                              if context.auto_preview
                                call unite#view#_do_auto_preview()
                              endif
                              if context.auto_highlight
                                call unite#view#_do_auto_highlight()
                              endif

FUNCTION  <SNR>191_plineopen()
Called 1 time
Total time:   0.005231
 Self time:   0.000477

count  total (s)   self (s)
    1              0.000002   let pid_list = []
    1              0.000002   let stdin_list = []
    1              0.000002   let stdout_list = []
    1              0.000002   let stderr_list = []
    1              0.000002   let npipe = a:npipe
                            
                              " Open input.
    1              0.000008   let hstdin = (empty(a:commands) || a:commands[0].fd.stdin == '')? 0 : vimproc#fopen(a:commands[0].fd.stdin, 'O_RDONLY').fd
                            
    1   0.000008   0.000006   let is_pty = !vimproc#util#is_windows() && a:is_pty
                            
    1              0.000002   let cnt = 0
    2              0.000004   for command in a:commands
    1              0.000005     if is_pty && command.fd.stdout == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstdout = 1
                                else
    1              0.000003       let mode = 'O_WRONLY | O_CREAT'
    1              0.000004       if command.fd.stdout =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stdout = command.fd.stdout[1:]
                                  else
    1              0.000003         let mode .= ' | O_TRUNC'
    1              0.000000       endif
                            
    1   0.000024   0.000010       let hstdout = s:is_pseudo_device(command.fd.stdout) ? 0 : vimproc#fopen(command.fd.stdout, mode).fd
    1              0.000001     endif
                            
    1              0.000004     if is_pty && command.fd.stderr == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstderr = 1
                                else
    1              0.000002       let mode = 'O_WRONLY | O_CREAT'
    1              0.000003       if command.fd.stderr =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stderr = command.fd.stderr[1:]
                                  else
    1              0.000003         let mode .= ' | O_TRUNC'
    1              0.000000       endif
    1   0.000019   0.000007       let hstderr = s:is_pseudo_device(command.fd.stderr) ? 0 : vimproc#fopen(command.fd.stderr, mode).fd
    1              0.000001     endif
                            
    1              0.000003     if command.fd.stderr ==# '/dev/stdout'
                                  let npipe = 2
                                endif
                            
    1   0.001799   0.000008     let args = s:convert_args(command.args)
    1              0.000006     let command_name = fnamemodify(args[0], ':t:r')
    1              0.000010     let pty_npipe = cnt == 0 && hstdin == 0 && hstdout == 0 && hstderr == 0 && exists('g:vimproc_popen2_commands') && get(g:vimproc_popen2_commands, command_name, 0) != 0 ? 2 : npipe
                            
    1              0.000003     if is_pty && (cnt == 0 || cnt == len(a:commands)-1)
                                  " Use pty_open().
    1   0.001940   0.000017       let pipe = s:vp_pty_open(pty_npipe, winwidth(0)-5, winheight(0), hstdin, hstdout, hstderr, args)
    1              0.000001     else
                                  let pipe = s:vp_pipe_open(pty_npipe, hstdin, hstdout, hstderr, args)
                                endif
                            
    1              0.000003     if len(pipe) == 4
    1              0.000005       let [pid, fd_stdin, fd_stdout, fd_stderr] = pipe
    1   0.000215   0.000016       let stderr = s:fdopen(fd_stderr, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000001     else
                                  let [pid, fd_stdin, fd_stdout] = pipe
                                  let stderr = s:closed_fdopen( 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                endif
                            
    1              0.000007     call add(pid_list, pid)
    1   0.000171   0.000010     let stdin = s:fdopen(fd_stdin, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000009     let stdin.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdin == 0
    1              0.000008     call add(stdin_list, stdin)
    1   0.000186   0.000013     let stdout = s:fdopen(fd_stdout, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000006     let stdout.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdout == 0
    1              0.000007     call add(stdout_list, stdout)
    1              0.000006     let stderr.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstderr == 0
    1              0.000004     call add(stderr_list, stderr)
                            
    1              0.000006     let hstdin = stdout_list[-1].fd
    1              0.000002     let cnt += 1
    1              0.000002   endfor
                            
    1              0.000002   let proc = {}
    1              0.000003   let proc.pid_list = pid_list
    1              0.000003   let proc.pid = pid_list[-1]
    1   0.000158   0.000013   let proc.stdin = s:fdopen_pipes(stdin_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000125   0.000009   let proc.stdout = s:fdopen_pipes(stdout_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000123   0.000008   let proc.stderr = s:fdopen_pipes(stderr_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000020   0.000005   let proc.get_winsize = s:funcref('vp_get_winsize')
    1   0.000021   0.000006   let proc.set_winsize = s:funcref('vp_set_winsize')
    1   0.000020   0.000006   let proc.kill = s:funcref('vp_kill')
    1   0.000020   0.000006   let proc.waitpid = s:funcref('vp_waitpid')
    1   0.000020   0.000006   let proc.checkpid = s:funcref('vp_checkpid')
    1              0.000002   let proc.is_valid = 1
    1              0.000002   let proc.is_pty = is_pty
    1              0.000002   if a:is_pty
    1              0.000002     let proc.ttyname = ''
    1   0.000023   0.000006     let proc.get_winsize = s:funcref('vp_get_winsize')
    1   0.000019   0.000005     let proc.set_winsize = s:funcref('vp_set_winsize')
    1              0.000001   endif
                            
    1              0.000001   return proc

FUNCTION  unite#get_context()
Called 77 times
Total time:   0.002832
 Self time:   0.001396

count  total (s)   self (s)
   77   0.002167   0.000731   let unite = unite#get_current_unite()
   77              0.000557   return has_key(unite, 'context') ? unite.context : unite#init#_context({})

FUNCTION  unite#sources#mru#variables#clear()
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000004   if a:type ==# 'file'
    1              0.000013     let s:mru_files = []
    1              0.000001   else
    1              0.000011     let s:mru_directories = []
    1              0.000001   endif

FUNCTION  nerdtree#getPath()
Called 25 times
Total time:   0.177713
 Self time:   0.047490

count  total (s)   self (s)
   25              0.000294     let line = getline(a:ln)
                            
   25   0.018844   0.000358     let rootLine = g:NERDTreeFileNode.GetRootLineNum()
                            
                                "check to see if we have the root node
   25              0.000124     if a:ln == rootLine
                                    return b:NERDTreeRoot.path
                                endif
                            
   25              0.000098     if !g:NERDTreeDirArrows
                                    " in case called from outside the tree
                                    if line !~# '^ *[|` ]' || line =~# '^$'
                                        return {}
                                    endif
                                endif
                            
   25   0.000439   0.000310     if line ==# nerdtree#treeUpDirLine()
                                    return b:NERDTreeRoot.path.getParent()
                                endif
                            
   25   0.001986   0.000325     let indent = nerdtree#indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
   25   0.004380   0.000424     let curFile = nerdtree#stripMarkupFromLine(line, 0)
                            
   25              0.000095     let wasdir = 0
   25              0.000148     if curFile =~# '/$'
    2              0.000008         let wasdir = 1
    2              0.000036         let curFile = substitute(curFile, '/\?$', '/', "")
    2              0.000004     endif
                            
   25              0.000081     let dir = ""
   25              0.000102     let lnum = a:ln
  574              0.001552     while lnum > 0
  566              0.003043         let lnum = lnum - 1
  566              0.003630         let curLine = getline(lnum)
  566   0.089537   0.007414         let curLineStripped = nerdtree#stripMarkupFromLine(curLine, 1)
                            
                                    "have we reached the top of the tree?
  566              0.001881         if lnum == rootLine
   17   0.002724   0.000362             let dir = b:NERDTreeRoot.path.str({'format': 'UI'}) . dir
   17              0.000028             break
                                    endif
  549              0.003232         if curLineStripped =~# '/$'
  152   0.009146   0.001957             let lpindent = nerdtree#indentLevelFor(curLine)
  152              0.000532             if lpindent < indent
   10              0.000065                 let indent = indent - 1
                            
   10              0.000171                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
   10              0.000044                 continue
                                        endif
  142              0.000165         endif
  539              0.001420     endwhile
   25              0.000217     let curFile = b:NERDTreeRoot.path.drive . dir . curFile
   25  17.996514  17.982197     let toReturn = g:NERDTreePath.New(curFile)
   17              0.000038     return toReturn

FUNCTION  <SNR>102_get_hunks()
Called 5469 times
Total time:   0.332966
 Self time:   0.163140

count  total (s)   self (s)
 5469              0.023417   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
 5469   0.223392   0.053566   return {s:source_func}()

FUNCTION  <SNR>194__vital_depends()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return ['Data.List']

FUNCTION  <SNR>48_search()
Called 2 times
Total time:   0.000373
 Self time:   0.000238

count  total (s)   self (s)
                              " Define what will be searched.
    2   0.000176   0.000041   let cpat = s:str2coll(s:fchar)
    2              0.000023   let pat = a:f ? cpat : (a:fwd ? '\_.\ze' . cpat : cpat . '\zs\_.')
    2              0.000014   let b_flag = a:fwd ? '' : 'b'
                              " This is for the tx todo.
    2              0.000017   let c_flag = !a:0 ? '' : (a:1 && !a:f ? 'c' : '')
    2              0.000017   let ic = g:fanfingtastic_ignorecase ? '\c' : '\C'
    2              0.000107   return searchpos(ic.'\m'.pat, 'W'.b_flag.c_flag)

FUNCTION  unite#kinds#openable#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:kind

FUNCTION  <SNR>48_get()
Called 4 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    4              0.000072   let var = 's:'.a:var
    4              0.000074   return exists(var) ? eval(var) : ''

FUNCTION  unite#handlers#_on_cursor_moved()
Called 4 times
Total time:   0.003197
 Self time:   0.001506

count  total (s)   self (s)
    4              0.000014   if &filetype !=# 'unite'
                                return
                              endif
                            
    4   0.000123   0.000037   let unite = unite#get_current_unite()
    4              0.000021   let prompt_linenr = unite.prompt_linenr
    4              0.000013   let context = unite.context
                            
    4              0.000023   if line('.') == prompt_linenr && !&l:modifiable
    1              0.000003     setlocal modifiable
    1              0.000001   endif
    4              0.000014   if line('.') != prompt_linenr && &l:modifiable
                                setlocal nomodifiable
                              endif
                            
    4              0.000012   if line('.') <= prompt_linenr
    4              0.000287     nnoremap <silent><buffer> <Plug>(unite_loop_cursor_up) :call unite#mappings#loop_cursor_up_call(    0, 'n')<CR>
    4              0.000210     nnoremap <silent><buffer> <Plug>(unite_skip_cursor_up) :call unite#mappings#loop_cursor_up_call(    1, 'n')<CR>
    4              0.000172     inoremap <silent><buffer> <Plug>(unite_select_previous_line) <ESC>:call unite#mappings#loop_cursor_up_call(    0, 'i')<CR>
    4              0.000155     inoremap <silent><buffer> <Plug>(unite_skip_previous_line) <ESC>:call unite#mappings#loop_cursor_up_call(    1, 'i')<CR>
    4              0.000006   else
                                if winline() <= winheight('$') / 2
                                  normal! zz
                                endif
                            
                                nnoremap <expr><buffer> <Plug>(unite_loop_cursor_up) unite#mappings#loop_cursor_up_expr(0)
                                nnoremap <expr><buffer> <Plug>(unite_skip_cursor_up) unite#mappings#loop_cursor_up_expr(1)
                                inoremap <expr><buffer> <Plug>(unite_select_previous_line) unite#mappings#loop_cursor_up_expr(0)
                                inoremap <expr><buffer> <Plug>(unite_skip_previous_line) unite#mappings#loop_cursor_up_expr(1)
                              endif
                            
    4              0.000029   if exists('b:current_syntax') && !context.no_cursor_line
    4              0.000006     match
                            
    4              0.000044     if line('.') <= prompt_linenr+1 || mode('.') == 'i' || split(reltimestr(reltime(unite.cursor_line_time)))[0] > '0.15'
    4   0.000349   0.000035       call s:set_cursor_line()
    4              0.000006     endif
    4              0.000020     let unite.cursor_line_time = reltime()
    4              0.000005   endif
                            
    4              0.000011   if context.auto_preview
                                call unite#view#_do_auto_preview()
                              endif
    4              0.000006   if context.auto_highlight
                                call unite#view#_do_auto_highlight()
                              endif
                            
    4   0.000063   0.000028   call s:restore_statusline()
                            
                              " Check lines. "{{{
    4              0.000034   if !context.auto_resize && winheight(0) < line('$') && line('.') + winheight(0) / 2 < line('$')
                                return
                              endif
                            
    4              0.000031   let height = (unite.context.no_split  || unite.context.winheight == 0) ? winheight(0) : unite.context.winheight
    4   0.001293   0.000037   let candidates = unite#candidates#_gather_pos(height)
    4              0.000018   if !context.auto_resize && empty(candidates)
                                " Nothing.
    4              0.000007     return
                              endif
                            
                              call unite#view#_resize_window()
                            
                              let modifiable_save = &l:modifiable
                              try
                                setlocal modifiable
                                let lines = unite#view#_convert_lines(candidates)
                                let pos = getpos('.')
                                silent! call append('$', lines)
                              finally
                                let &l:modifiable = l:modifiable_save
                              endtry
                            
                              let context = unite.context
                              let unite.current_candidates += candidates
                            
                              if pos != getpos('.')
                                call setpos('.', pos)
                              endif"}}}

FUNCTION  airline#highlighter#add_accent()
Called 14 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
   14              0.000045   let s:accents[a:accent] = 1

FUNCTION  nerdtree#restoreScreenState()
Called 3 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    3              0.000028     if !exists("b:NERDTreeOldTopLine") || !exists("b:NERDTreeOldPos") || !exists("b:NERDTreeOldWindowSize")
                                    return
                                endif
    3              0.000024     exec("silent vertical resize ".b:NERDTreeOldWindowSize)
                            
    3              0.000011     let old_scrolloff=&scrolloff
    3              0.000019     let &scrolloff=0
    3              0.000014     call cursor(b:NERDTreeOldTopLine, 0)
    3              0.000055     normal! zt
    3              0.000015     call setpos(".", b:NERDTreeOldPos)
    3              0.000011     let &scrolloff=old_scrolloff

FUNCTION  neosnippet#mappings#_clear_select_mode_mappings()
Called 55 times
Total time:   0.028122
 Self time:   0.028122

count  total (s)   self (s)
   55              0.000238   if !g:neosnippet#disable_select_mode_mappings
                                return
                              endif
                            
   55              0.000354   redir => mappings
   55              0.010169     silent! smap
   55              0.000334   redir END
                            
  125              0.005377   for line in map(filter(split(mappings, '\n'), "v:val !~# '^s'"), "substitute(v:val, '<NL>', '<C-J>', 'g')")
   70              0.001006     let map = matchstr(line, '^\a*\s*\zs\S\+')
   70              0.000611     let map = substitute(map, '<NL>', '<C-j>', 'g')
                            
   70              0.003312     silent! execute 'sunmap' map
   70              0.001374     silent! execute 'sunmap <buffer>' map
   70              0.000305   endfor
                            
                              " Define default select mode mappings.
   55              0.001154   snoremap <CR>     a<BS>
   55              0.000846   snoremap <BS>     a<BS>
   55              0.000798   snoremap <Del>    a<BS>
   55              0.000753   snoremap <C-h>    a<BS>

FUNCTION  neobundle#util#convert2list()
Called 52 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   52              0.000210   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  366()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000008   if a:context.input == '' || !has('float') || empty(a:candidates)
    1              0.000003     return a:candidates
                              endif
                            
                              " Initialize.
                              for candidate in a:candidates
                                let candidate.filter__rank = 0
                              endfor
                            
                              " let is_path = has_key(a:candidates[0], 'action__path')
                            
                              for input in split(a:context.input, '\\\@<! ')
                                let input = substitute(substitute(input, '\\ ', ' ', 'g'), '\*', '', 'g')
                            
                                " Calc rank.
                                let l1 = len(input)
                            
                                " for candidate in a:candidates
                                "   let word = is_path ? fnamemodify(candidate.word, ':t') : candidate.word
                                "   let index = stridx(word, input[0])
                                "   let candidate.filter__rank +=
                                "         \ len(word) + (index > 0 ? index * 2 : len(word))
                                " endfor
                            
                                if unite#util#has_lua()
                                  for candidate in a:candidates
                                    let candidate.filter__rank += s:calc_word_distance_lua(input, candidate.word, l1)
                                  endfor
                                else
                                  for candidate in a:candidates
                                    let candidate.filter__rank += s:calc_word_distance(input, candidate.word, l1)
                                  endfor
                                endif
                              endfor
                            
                              return unite#util#has_lua() ? s:sort_lua(a:candidates) : unite#util#sort_by(a:candidates, 'v:val.filter__rank')

FUNCTION  <SNR>191_vp_pipe_close()
Called 3 times
Total time:   0.000320
 Self time:   0.000035

count  total (s)   self (s)
                              " echomsg 'close:'.self.fd
    3              0.000006   if self.fd != 0
    3   0.000304   0.000019     call s:libcall('vp_pipe_close', [self.fd])
    3              0.000006     let self.fd = 0
    3              0.000003   endif

FUNCTION  <SNR>188_sort()
Called 3 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
    3              0.000056   if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
    3              0.000022   let s:expr = a:expr
    3              0.000038   return sort(a:list, 's:_compare')

FUNCTION  <SNR>23_LoadFTPlugin()
Called 8 times
Total time:   0.014668
 Self time:   0.012840

count  total (s)   self (s)
    8              0.000033     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    8              0.000040     let s = expand("<amatch>")
    8              0.000016     if s != ""
    8              0.000116       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   16              0.000070       for name in split(s, '\.')
    8   0.014193   0.012365 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    8              0.000026       endfor
    8              0.000010     endif

FUNCTION  <SNR>180_EditClasspath()
Called 1 time
Total time:   0.030747
 Self time:   0.000924

count  total (s)   self (s)
    1              0.000022     let command = 'syntastic javac classpath'
    1              0.000240     let winnr = bufwinnr('^' . command . '$')
    1              0.000010     if winnr < 0
    1              0.000024         let pathlist = split(g:syntastic_java_javac_classpath,"\n")
    1   0.030331   0.000580         execute (len(pathlist) + 5) . 'sp ' . fnameescape(command)
                            
    1              0.000002         augroup syntastic
    1              0.000009             autocmd BufWriteCmd <buffer> call s:SaveClasspath() | bwipeout
    1              0.000001         augroup END
                            
    1   0.000086   0.000014         setlocal buftype=acwrite bufhidden=wipe nobuflisted noswapfile nowrap number
    1              0.000003         for p in pathlist
                                        call append(line('$') - 1, p)
                                    endfor
    1              0.000000     else
                                    execute winnr . 'wincmd w'
                                endif

FUNCTION  unite#util#escape_pattern()
Called 2 times
Total time:   0.000041
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000041   0.000020   return call(unite#util#get_vital().escape_pattern, a:000)

FUNCTION  unite#view#_resize_window()
Called 4 times
Total time:   0.000576
 Self time:   0.000433

count  total (s)   self (s)
    4              0.000028   if &filetype !=# 'unite' || winnr('$') == 1
    1              0.000001     return
                              endif
                            
    3   0.000124   0.000025   let context = unite#get_context()
    3   0.000067   0.000023   let unite = unite#get_current_unite()
                            
    3              0.000009   if context.no_split
                                let context.is_resize = 0
                                return
                              endif
                            
    3              0.000031   if context.unite__old_winwidth != 0 && context.unite__old_winheight != 0 && winheight(0) != context.unite__old_winheight && winwidth(0) != context.unite__old_winwidth
                                " Disabled auto resize.
                                let context.winwidth = 0
                                let context.winheight = 0
                                let context.is_resize = 1
                                return
                              endif
                            
    3              0.000014   if context.auto_resize && line('.') == unite.prompt_linenr
                                " Auto resize.
                                let max_len = unite.prompt_linenr + len(unite.candidates)
                                silent! execute 'resize' min([max_len, context.winheight])
                                if line('.') <= winheight(0)
                                  normal! zb
                                endif
                                if mode() ==# 'i' && col('.') == (col('$') - 1)
                                  startinsert!
                                endif
                            
                                let context.is_resize = 1
                              elseif context.vertical && context.unite__old_winwidth  == 0
                                    " \ && winwidth(winnr()) != context.winwidth
                                    " \ && (context.unite__old_winwidth  == 0 ||
                                    " \     winheight(winnr()) == context.unite__old_winheight)
                                execute 'vertical resize' context.winwidth
                            
                                let context.is_resize = 1
                              elseif !context.vertical && context.unite__old_winheight  == 0
                                    " \ && winheight(winnr()) != context.winheight
                                    " \ && (context.unite__old_winheight == 0 ||
                                    " \     winwidth(winnr()) == context.unite__old_winwidth)
    1              0.000014     execute 'resize' context.winheight
                            
    1              0.000002     let context.is_resize = 1
    1              0.000001   else
    2              0.000008     let context.is_resize = 0
    2              0.000003   endif
                            
    3              0.000019   let context.unite__old_winheight = winheight(winnr())
    3              0.000017   let context.unite__old_winwidth = winwidth(winnr())

FUNCTION  unite#util#path2directory()
Called 1 time
Total time:   0.000043
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000041   0.000009   return call(unite#util#get_vital().path2directory, a:000)

FUNCTION  unite#helper#get_unite_winnr()
Called 2 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    2              0.000030   for winnr in filter(range(1, winnr('$')), "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                let buffer_context = get(getbufvar( winbufnr(winnr), 'unite'), 'context', {})
                                if !empty(buffer_context) && buffer_context.buffer_name ==# a:buffer_name
                                  if buffer_context.temporary && !empty(filter(copy(buffer_context.old_buffer_info), 'v:val.buffer_name ==# buffer_context.buffer_name'))
                                    " Disable resume.
                                    let buffer_context.old_buffer_info = []
                                  endif
                                  return winnr
                                endif
                              endfor
                            
    2              0.000003   return -1

FUNCTION  <SNR>191_close_all()
Called 2 times
Total time:   0.000548
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000009   if has_key(a:self, 'stdin')
    2   0.000181   0.000012     call a:self.stdin.close()
    2              0.000002   endif
    2              0.000006   if has_key(a:self, 'stdout')
    2   0.000175   0.000011     call a:self.stdout.close()
    2              0.000001   endif
    2              0.000006   if has_key(a:self, 'stderr')
    2   0.000162   0.000010     call a:self.stderr.close()
    2              0.000001   endif

FUNCTION  unite#handlers#_on_cursor_hold()
Called 90 times
Total time:   0.023886
 Self time:   0.020366

count  total (s)   self (s)
   90              0.001752   let is_async = 0
                            
   90   0.004689   0.002091   call s:restore_statusline()
                            
   90              0.000471   if &filetype ==# 'unite'
                                " Redraw.
    1   0.000500   0.000012     call unite#redraw()
    1   0.000417   0.000015     call s:change_highlight()
                            
    1   0.000049   0.000017     let unite = unite#get_current_unite()
    1              0.000008     let is_async = unite.is_async
                            
    1              0.000007     if !unite.is_async && unite.context.auto_quit
                                  call unite#force_quit_session()
                                endif
    1              0.000003   else
                                " Search other unite window.
   89              0.005675     for winnr in filter(range(1, winnr('$')), "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                  let unite = getbufvar(winbufnr(winnr), 'unite')
                                  if unite.is_async
                                    " Redraw unite buffer.
                                    call unite#redraw(winnr)
                            
                                    let is_async = unite.is_async
                                  endif
                                endfor
   89              0.000247   endif
                            
   90              0.000312   if is_async
                                " Ignore key sequences.
                                call feedkeys("g\<ESC>", 'n')
                              endif

FUNCTION  airline#parts#filetype()
Called 7697 times
Total time:   0.023667
 Self time:   0.023667

count  total (s)   self (s)
 7697              0.018704   return &filetype

FUNCTION  unite#candidates#_recache()
Called 1 time
Total time:   0.092542
 Self time:   0.000409

count  total (s)   self (s)
    1   0.000097   0.000023   let unite = unite#get_current_unite()
                            
                              " Save options.
    1              0.000010   let ignorecase_save = &ignorecase
                            
    1   0.000167   0.000047   if unite#custom#get_profile(unite.profile_name, 'smartcase') && get(split(a:input, '\W'), -1, '') =~ '\u'
                                let &ignorecase = 0
                              else
    1   0.000139   0.000032     let &ignorecase = unite#custom#get_profile(unite.profile_name, 'ignorecase')
    1              0.000003   endif
                            
    1              0.000008   let context = unite.context
    1              0.000009   let context.is_redraw = a:is_force
    1              0.000011   let context.is_changed = a:input !=# unite.last_input
                            
    2              0.000014   for source in unite.sources
    1              0.000008     let source.unite__candidates = []
    1              0.000003   endfor
                            
    1   0.000679   0.000028   let inputs = unite#helper#get_substitute_input(a:input)
    1              0.000015   let context.is_list_input = len(inputs) > 1
    2              0.000010   for input in inputs
    1              0.000008     let context.input = input
    1   0.090977   0.000032     call s:recache_candidates_loop(context, a:is_force)
    1              0.000001   endfor
                            
    1              0.000003   let filtered_count = 0
                            
    2              0.000004   for source in unite.sources
    1              0.000003     let source.unite__is_invalidate = 0
                            
    1              0.000006     if !context.no_buffer && source.max_candidates != 0 && !context.unite__is_interactive && !unite.disabled_max_candidates && len(source.unite__candidates) > source.max_candidates
                                  " Filtering too many candidates.
                                  let source.unite__candidates = source.unite__candidates[: source.max_candidates - 1]
                            
                                  if context.verbose && filtered_count < &cmdheight
                                    echohl WarningMsg | echomsg printf( '[%s] Filtering too many candidates.', source.name) | echohl None
                                    let filtered_count += 1
                                  endif
                                endif
                            
                                " Call post_filter hook.
    1              0.000004     let source.unite__context.candidates = source.unite__candidates
    1   0.000166   0.000009     call unite#helper#call_hook([source], 'on_post_filter')
                            
    1   0.000091   0.000012     let source.unite__candidates = unite#init#_candidates_source(   source.unite__context.candidates, source.name)
    1              0.000001   endfor
                            
                              " Update async state.
    1              0.000011   let unite.is_async = len(filter(copy(unite.sources),           'v:val.unite__context.is_async')) > 0
                            
    1              0.000006   let &ignorecase = ignorecase_save

FUNCTION  neosnippet#expandable_or_jumpable()
Called 17 times
Total time:   0.049330
 Self time:   0.000723

count  total (s)   self (s)
   17   0.049228   0.000621   return neosnippet#mappings#expandable_or_jumpable()

FUNCTION  airline#parts#iminsert()
Called 5477 times
Total time:   0.060472
 Self time:   0.060472

count  total (s)   self (s)
 5477              0.024844   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
 5477              0.006726   return ''

FUNCTION  <SNR>197_separator()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   return !exists('+shellslash') || &shellslash ? '/' : '\'

FUNCTION  neosnippet#variables#snippets()
Called 79 times
Total time:   0.001456
 Self time:   0.001456

count  total (s)   self (s)
   79              0.000541   if !exists('s:snippets')
                                let s:snippets= {}
                              endif
                            
   79              0.000258   return s:snippets

FUNCTION  unite#custom#get()
Called 35 times
Total time:   0.000685
 Self time:   0.000685

count  total (s)   self (s)
   35              0.000139   if !exists('s:custom')
                                let s:custom = {}
                                let s:custom.sources = {}
                                let s:custom.sources._ = {}
                                let s:custom.actions = {}
                                let s:custom.default_actions = {}
                                let s:custom.aliases = {}
                                let s:custom.profiles = {}
                              endif
                            
   35              0.000061   return s:custom

FUNCTION  unite#view#_get_status_string()
Called 19 times
Total time:   0.003830
 Self time:   0.000368

count  total (s)   self (s)
   19   0.003809   0.000347   return !exists('b:unite') ? '' : ((b:unite.is_async ? '[async] ' : '') . join(unite#helper#loaded_source_names_with_args(), ', '))

FUNCTION  unite#variables#all_sources()
Called 2 times
Total time:   0.001882
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000003   if a:0 == 0
                                return unite#init#_sources()
                              endif
                            
    2   0.000031   0.000009   let unite = unite#get_current_unite()
                            
    2   0.001819   0.000016   let all_sources = unite#init#_sources([], a:1)
    2              0.000009   let source = get(all_sources, a:1, {})
                            
    2              0.000010   return empty(source) ? get(filter(copy(get(unite, 'sources', [])), 'v:val.name ==# a:1'), 0, {}) : source

FUNCTION  <SNR>219_convert2list()
Called 57 times
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
   57              0.000348   return [ fnamemodify(a:dict.action__path, ':~'), a:dict.source__time ]

FUNCTION  unite#loaded_source_names_string()
Called 4 times
Total time:   0.000197
 Self time:   0.000026

count  total (s)   self (s)
    4   0.000197   0.000026   return join(unite#loaded_source_names())

FUNCTION  <SNR>48_next_char_pos()
Called 2 times
Total time:   0.000536
 Self time:   0.000163

count  total (s)   self (s)
    2              0.000016   let cnt = 0
    2              0.000019   while cnt < a:count
    2   0.000425   0.000052     let new_pos = s:search(a:fwd, a:f)
    2              0.000022     if new_pos[0] == 0
    2              0.000009       break
                                endif
                                " found one
                                let cnt += 1
                              endwhile
    2              0.000009   return new_pos

FUNCTION  <SNR>191_close()
Called 9 times
Total time:   0.000839
 Self time:   0.000077

count  total (s)   self (s)
    9              0.000015   if self.is_valid
    6   0.000367   0.000047     call self.f_close()
    6              0.000002   endif
                            
    9              0.000016   let self.is_valid = 0
    9              0.000017   let self.eof = 1
    9              0.000013   let self.__eof = 1

FUNCTION  <SNR>180_SaveClasspath()
Called 1 time
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    1              0.000020     let path = ''
    1              0.000024     let lines = getline(1, line('$'))
                                " save classpath to config file
    1              0.000010     if g:syntastic_java_javac_config_file_enabled
                                    call writefile(lines,g:syntastic_java_javac_config_file)
                                endif
    2              0.000014     for l in lines
    1              0.000007         if l != ''
    1              0.000012             let path .= l . "\n"
    1              0.000003         endif
    1              0.000003     endfor
    1              0.000010     let g:syntastic_java_javac_classpath = path
    1              0.000017     let &modified = 0

FUNCTION  303()
Called 124 times
Total time:   0.145068
 Self time:   0.038719

count  total (s)   self (s)
  124   0.035752   0.000707     if a:path.equals(self.path)
    6              0.000009         return self
                                endif
  118   0.032225   0.001452     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   86              0.000118         return {}
                                endif
                            
   32              0.000074     if self.path.isDirectory
  140              0.000313         for i in self.children
  140   0.008073   0.000796             let retVal = i.findNode(a:path)
  140              0.000283             if retVal != {}
   32              0.000047                 return retVal
                                        endif
  108              0.000131         endfor
                                endif
                                return {}

FUNCTION  fugitive#detect()
Called 5474 times
Total time:   4.609558
 Self time:   0.375884

count  total (s)   self (s)
 5474              0.030208   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
 5474              0.016467   if !exists('b:git_dir')
 5474   4.281561   0.047887     let dir = fugitive#extract_git_dir(a:path)
 5474              0.010871     if dir !=# ''
                                  let b:git_dir = dir
                                endif
 5474              0.005461   endif
 5474              0.017800   if exists('b:git_dir')
                                silent doautocmd User Fugitive
                                cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
                                nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
                                let buffer = fugitive#buffer()
                                if expand('%:p') =~# '//'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
                                if stridx(buffer.getvar('&tags'), escape(b:git_dir.'/tags', ', ')) == -1
                                  call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  if &filetype !=# ''
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
                                endif
                              endif

FUNCTION  <SNR>193_get_source_candidates()
Called 1 time
Total time:   0.048529
 Self time:   0.000120

count  total (s)   self (s)
    1              0.000003   let context = a:source.unite__context
                            
    1              0.000002   let funcname = 's:get_source_candidates()'
    1              0.000001   try
    1              0.000001     if context.unite__is_vimfiler
                                  if context.vimfiler__is_dummy
                                    let funcname = 'vimfiler_dummy_candidates'
                                    return has_key(a:source, 'vimfiler_dummy_candidates') ? copy(a:source.vimfiler_dummy_candidates(           a:source.args, a:source.unite__context)) : []
                                  else
                                    let funcname = 'vimfiler_gather_candidates'
                                    return has_key(a:source, 'vimfiler_gather_candidates') ? copy(a:source.vimfiler_gather_candidates(           a:source.args, a:source.unite__context)) : []
                                  endif
                                endif
                            
    1              0.000001     if context.is_redraw || a:source.unite__is_invalidate
                                  " Recaching.
    1              0.000003       let a:source.unite__cached_candidates = []
                            
    1              0.000002       let funcname = 'gather_candidates'
    1              0.000002       if has_key(a:source, 'gather_candidates')
    1   0.034105   0.000022         let a:source.unite__cached_candidates += copy(a:source.gather_candidates(a:source.args, a:source.unite__context))
    1              0.000001       endif
    1              0.000001     endif
                            
    1              0.000002     if a:source.unite__context.is_async
                                  " Get asynchronous candidates.
    1              0.000004       let funcname = 'async_gather_candidates'
    1              0.000001       while 1
    1   0.014338   0.000012         let a:source.unite__cached_candidates += a:source.async_gather_candidates(a:source.args, context)
                            
    1              0.000003         if context.unite__is_interactive || !a:source.unite__context.is_async
    1              0.000001           break
                                    endif
                                  endwhile
    1              0.000001     endif
                            
    1              0.000006     if has_key(a:source, 'change_candidates') && (context.is_redraw || context.is_changed     || a:source.unite__is_invalidate)
                                  " Recaching.
                                  let funcname = 'change_candidates'
                                  let a:source.unite__cached_change_candidates = a:source.change_candidates(     a:source.args, a:source.unite__context)
                                endif
    1              0.000001   catch
                                call unite#print_error(v:throwpoint)
                                call unite#print_error(v:exception)
                                call unite#print_error( '[unite.vim] Error occured in ' . funcname . '!')
                                call unite#print_error( '[unite.vim] Source name is ' . a:source.name)
                            
                                return []
                              endtry
                            
    1              0.000005   return a:source.unite__cached_candidates + a:source.unite__cached_change_candidates

FUNCTION  ctrlp#utils#readfile()
Called 5 times
Total time:   0.000865
 Self time:   0.000865

count  total (s)   self (s)
    5              0.000094 	if filereadable(a:file)
    5              0.000654 		let data = readfile(a:file)
    5              0.000045 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    5              0.000010 		retu data
                            	en
                            	retu []

FUNCTION  unite#candidates#_gather_pos()
Called 4 times
Total time:   0.001256
 Self time:   0.000249

count  total (s)   self (s)
    4   0.000092   0.000027   let unite = unite#get_current_unite()
    4              0.000015   if unite.context.is_redraw || unite.candidates_pos == 0
                                return []
                              endif
                            
    4   0.000081   0.000025   let unite = unite#get_current_unite()
    4              0.000037   let candidates = unite.candidates[unite.candidates_pos : unite.candidates_pos + a:offset - 1]
                            
                              " Post filter.
    4              0.000018   for filter_name in unite.post_filters
                                let candidates = unite#helper#call_filter( filter_name, candidates, unite.context)
                              endfor
                            
    4              0.000023   let unite.candidates_pos += len(candidates)
                            
    4   0.000919   0.000033   return unite#init#_candidates(candidates)

FUNCTION  syntastic#postprocess#cygwinRemoveCR()
Called 32 times
Total time:   0.002245
 Self time:   0.002245

count  total (s)   self (s)
   32              0.000629     if has('win32unix')
                                    let llist = []
                            
                                    for e in a:errors
                                        let e['text'] = substitute(e['text'], '\r', '', 'g')
                                        call add(llist, e)
                                    endfor
                                else
   32              0.000222         let llist = a:errors
   32              0.000076     endif
                            
   32              0.000108     return llist

FUNCTION  unite#candidates#gather()
Called 2 times
Total time:   0.001218
 Self time:   0.000227

count  total (s)   self (s)
    2              0.000017   let is_gather_all = get(a:000, 0, 0)
                            
    2   0.000057   0.000017   let unite = unite#get_current_unite()
    2              0.000011   let unite.candidates = []
    4              0.000017   for source in unite.sources
    2              0.000013     let unite.candidates += source.unite__candidates
    2              0.000004   endfor
                            
    2              0.000006   if is_gather_all
                                let unite.candidates_pos = len(unite.candidates)
                              elseif unite.context.is_redraw || unite.candidates_pos == 0
    1              0.000004     let unite.candidates_pos = line('.') + winheight(0)
    1              0.000000   endif
                            
    2   0.000988   0.000037   let candidates = unite#init#_candidates( unite.candidates[: unite.candidates_pos-1])
                            
                              " Post filter.
    2              0.000009   for filter_name in unite.post_filters
                                let candidates = unite#helper#call_filter( filter_name, candidates, unite.context)
                              endfor
                            
    2              0.000005   return candidates

FUNCTION  <SNR>191_fdopen()
Called 3 times
Total time:   0.000533
 Self time:   0.000118

count  total (s)   self (s)
    3   0.000531   0.000116   return { 'fd' : a:fd, 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '', 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  neosnippet#helpers#get_snippets()
Called 17 times
Total time:   0.035694
 Self time:   0.025321

count  total (s)   self (s)
   17   0.000933   0.000314   call neosnippet#init#check()
                            
   17   0.001086   0.000420   let neosnippet = neosnippet#variables#current_neosnippet()
   17              0.000247   let snippets = copy(neosnippet.snippets)
   51   0.003284   0.000811   for filetype in s:get_sources_filetypes(neosnippet#helpers#get_filetype())
   34   0.004195   0.000606     call neosnippet#commands#_make_cache(filetype)
   34   0.003429   0.002755     call extend(snippets, neosnippet#variables#snippets()[filetype], 'keep')
   34              0.000123   endfor
                            
   17   0.001058   0.000302   let cur_text = neosnippet#util#get_cur_text()
                            
   17              0.000103   if mode() ==# 'i'
                                " Special filters.
   17   0.001899   0.000303     if !s:is_beginning_of_line(cur_text)
    2              0.001545       call filter(snippets, '!v:val.options.head')
    2              0.000010     endif
   17              0.000034   endif
                            
   17              0.016829   call filter(snippets, "cur_text =~# get(v:val, 'regexp', '')")
                            
   17              0.000094   return snippets

FUNCTION  <SNR>83_isDebugEnabled()
Called 921 times
Total time:   0.008833
 Self time:   0.008833

count  total (s)   self (s)
                                " poor man's bit test for bit N, assuming a:level == 2**N
  921              0.005670     return (g:syntastic_debug / a:level) % 2

FUNCTION  102()
Called 38 times
Total time:   0.007296
 Self time:   0.001452

count  total (s)   self (s)
   38              0.000350     if has_key(s:defaultCheckers, a:filetype)
   38   0.006757   0.000913         return self._filterCheckersByName(a:checkers, s:defaultCheckers[a:filetype])
                                endif
                            
                                return a:checkers

FUNCTION  104()
Called 38 times
Total time:   0.005844
 Self time:   0.005331

count  total (s)   self (s)
   38              0.000320     let checkers_by_name = {}
  104              0.000514     for c in a:checkers
   66   0.001718   0.001205         let checkers_by_name[c.getName()] = c
   66              0.000194     endfor
                            
   38              0.000270     let filtered = []
   76              0.000332     for name in a:list
   38              0.000308         if has_key(checkers_by_name, name)
   33              0.000618             call add(filtered, checkers_by_name[name])
   33              0.000083         endif
   38              0.000071     endfor
                            
   38              0.000126     return filtered

FUNCTION  108()
Called 38 times
Total time:   0.002187
 Self time:   0.002187

count  total (s)   self (s)
   38              0.000702     if exists("g:syntastic_" . a:filetype . "_checker") && !exists("g:syntastic_" . a:filetype . "_checkers")
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#deprecationWarn("variable g:syntastic_" . a:filetype . "_checker is deprecated")
                                endif
   38              0.000647     return exists("b:syntastic_checkers") || exists("g:syntastic_" . a:filetype . "_checkers")

FUNCTION  unite#helper#parse_options()
Called 1 time
Total time:   0.004762
 Self time:   0.002433

count  total (s)   self (s)
    1              0.000007   let args = []
    1              0.000007   let options = {}
    4              0.000082   for arg in split(a:args, '\%(\\\@<!\s\)\+')
    3              0.000077     let arg = substitute(arg, '\\\( \)', '\1', 'g')
                            
    3              0.000065     let arg_key = substitute(arg, '=\zs.*$', '', '')
    3   0.004101   0.001772     let matched_list = filter(copy(unite#variables#options()),  'v:val ==# arg_key')
    5              0.000032     for option in matched_list
    2              0.000077       let key = substitute(substitute(option, '-', '_', 'g'), '=$', '', '')[1:]
    2              0.000048       let options[key] = (option =~ '=$') ? arg[len(option) :] : 1
    2              0.000014     endfor
                            
    3              0.000046     if empty(matched_list)
    1              0.000014       call add(args, arg)
    1              0.000002     endif
    3              0.000008   endfor
                            
    1              0.000006   return [args, options]

FUNCTION  310()
Called 30 times
Total time:   0.016462
 Self time:   0.001739

count  total (s)   self (s)
   30              0.000070     let toReturn = []
  120              0.000202     for i in self.children
   90   0.015240   0.000517         if i.path.ignore() ==# 0
   90              0.000487             call add(toReturn, i)
   90              0.000094         endif
   90              0.000087     endfor
   30              0.000037     return toReturn

FUNCTION  <SNR>87_LocalBrowse()
Called 55 times
Total time:   0.002195
 Self time:   0.002195

count  total (s)   self (s)
                              " unfortunate interaction -- debugging calls can't be used here;
                              " the BufEnter event causes triggering when attempts to write to
                              " the DBG buffer are made.
                            "  echomsg "dirname<".a:dirname.">"
   55              0.000367   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                               endif
                              elseif isdirectory(a:dirname)
                            "   echomsg "dirname<".dirname."> isdir"
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                              endif
                              " not a directory, ignore it

FUNCTION  314()
Called 5 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    5              0.000013     let opts = a:0 ? a:1 : {}
                            
    5              0.000017     if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
    5              0.000009         let self.isOpen = 1
    5              0.000009         if self.children ==# []
                                        return self._initChildren(0)
                                    else
    5              0.000004             return 0
                                    endif
                                endif

FUNCTION  28()
Called 53 times
Total time:   0.003474
 Self time:   0.000715

count  total (s)   self (s)
   53   0.000973   0.000359     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
   53   0.002440   0.000295     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  29()
Called 53 times
Total time:   0.002145
 Self time:   0.001349

count  total (s)   self (s)
   53   0.000854   0.000304     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
   53   0.000496   0.000250     if a:loclist.hasErrorsOrWarningsToDisplay()
   35              0.000072         if g:syntastic_auto_loc_list == 1
                                        call a:loclist.show()
                                    endif
   35              0.000022     else
   18              0.000065         if g:syntastic_auto_loc_list > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
   18              0.000040             lclose
   18              0.000018         endif
   18              0.000016     endif

FUNCTION  unite#start#standard()
Called 1 time
Total time:   0.184813
 Self time:   0.001844

count  total (s)   self (s)
    1              0.000017   if empty(a:sources)
                                call unite#print_error('[unite.vim] Source names is required.')
                                return
                              endif
                            
                              " Check command line window.
    1   0.000027   0.000021   if unite#util#is_cmdwin()
                                call unite#print_error( '[unite.vim] Command line buffer is detected! '. 'Please close command line buffer.')
                                return
                              endif
                            
    1              0.000005   let context = get(a:000, 0, {})
    1   0.001585   0.000340   let context = unite#init#_context(context, unite#helper#get_source_names(a:sources))
                            
    1              0.000001   if context.resume
                                " Check resume buffer.
                                let resume_bufnr = s:get_resume_buffer(context.buffer_name)
                                if resume_bufnr > 0 && getbufvar(resume_bufnr, 'unite').source_names ==#    unite#helper#get_source_names(a:sources)
                                  return unite#start#resume(context.buffer_name, context)
                                endif
                              endif
                            
    1   0.000012   0.000008   call unite#variables#enable_current_unite()
                            
    1              0.000001   if context.toggle "{{{
                                if unite#view#_close(context.buffer_name)
                                  return
                                endif
                              endif"}}}
                            
    1              0.000002   try
    1   0.041932   0.000013     call unite#init#_current_unite(a:sources, context)
    1              0.000003   catch /^unite.vim: Invalid /
                                call unite#print_error('[unite.vim] ' . v:exception)
                                return
                              endtry
                            
                              " Caching.
    1   0.000050   0.000023   let current_unite = unite#variables#current_unite()
    1              0.000011   let current_unite.last_input = context.input
    1              0.000008   let current_unite.input = context.input
    1   0.096063   0.001229   call unite#candidates#_recache(context.input, context.is_redraw)
                            
    1              0.000004   if !current_unite.is_async && (context.immediately || context.no_empty) "{{{
                                let candidates = unite#candidates#gather()
                            
                                if empty(candidates)
                                  " Ignore.
                                  call unite#variables#disable_current_unite()
                                  return
                                elseif context.immediately && len(candidates) == 1
                                  " Immediately action.
                                  call unite#action#do( context.default_action, [candidates[0]])
                                  call unite#variables#disable_current_unite()
                                  return
                                endif
                              endif"}}}
                            
    1   0.043665   0.000009   call unite#init#_unite_buffer()
                            
    1   0.000010   0.000007   call unite#variables#disable_current_unite()
                            
    1   0.000015   0.000005   let unite = unite#get_current_unite()
                            
    1              0.000003   setlocal modifiable
                            
                              " Redraw prompt.
    1              0.000005   silent % delete _
    1              0.000013   call setline(unite.prompt_linenr, unite.prompt . unite.context.input)
                            
    1   0.000890   0.000006   call unite#view#_redraw_candidates()
                            
    1   0.000195   0.000009   call unite#handlers#_on_bufwin_enter(bufnr('%'))
                            
    1   0.000202   0.000007   call unite#view#_init_cursor()

FUNCTION  <SNR>193_recache_candidates_loop()
Called 1 time
Total time:   0.090945
 Self time:   0.001106

count  total (s)   self (s)
    1   0.000068   0.000016   let unite = unite#get_current_unite()
                            
    1   0.020121   0.000030   let input_len = unite#util#strchars(a:context.input)
                            
    1   0.000019   0.000006   let custom = unite#custom#get()
                            
    1              0.000003   let candidate_sources = []
    1              0.000002   let unite.max_source_candidates = 0
    2              0.000004   for source in unite.sources
                                " Check required pattern length.
    1              0.000003     if input_len < source.required_pattern_length
                                  continue
                                endif
                            
                                " Set context.
    1              0.000003     let context = source.unite__context
    1              0.000003     let context.input = a:context.input
    1              0.000003     let context.source_name = source.name
                            
    1              0.000003     if source.required_pattern_length > 0 && !source.is_forced
                                  " Forced redraw.
                                  let context.is_redraw = 1
                                  let source.is_forced = 1
                                else
    1              0.000003       let context.is_redraw = a:context.is_redraw
    1              0.000001     endif
    1              0.000002     let context.is_changed = a:context.is_changed
    1              0.000003     let context.is_invalidate = source.unite__is_invalidate
    1              0.000003     let context.is_list_input = a:context.is_list_input
    1              0.000007     let context.input_list = split(context.input, '\\\@<! ', 1)
    1              0.000012     let context.path = get(filter(copy(context.input_list),         "v:val !~ '^[!:]'"), 0, '')
    1              0.000005     let context.unite__max_candidates = (unite.disabled_max_candidates ? 0 : source.max_candidates)
                            
    1   0.048543   0.000014     let source_candidates = s:get_source_candidates(source)
                            
    1              0.000006     let custom_source = get(custom.sources, source.name, {})
    1              0.000004     if source.ignore_pattern != '' && !context.unite__is_vimfiler
    1              0.000060       call filter(source_candidates, "get(v:val, 'action__path', v:val.word)             !~# source.ignore_pattern")
    1              0.000002     endif
                            
                                " Call pre_filter hook.
    1              0.000003     let context.candidates = source_candidates
    1   0.000074   0.000010     call unite#helper#call_hook([source], 'on_pre_filter')
                            
                                " Set filters.
    1              0.000002     let matchers = []
    1              0.000002     let sorters = []
    1              0.000002     let prev_filters = []
    1              0.000002     let post_filters = []
    4              0.000020     for Filter in (context.unite__is_vimfiler ? [] : get(custom_source, 'filters', source.filters))
    3              0.000023       if type(Filter) != type('')
                                    call add((empty(matchers) ? prev_filters : post_filters), Filter)
                            
                                    unlet Filter
                                    continue
                                  endif
                            
    3   0.011379   0.000077       let name = get(unite#get_filters(Filter),              'name', '')
    3              0.000016       if name == ''
                                    call unite#print_error(printf( 'Invalid filter name "%s" is detected.', Filter))
                                  elseif name =~# '\%(^\|_\)matcher_'
    1              0.000019         call add(matchers, Filter)
    1              0.000005       elseif name =~# '\%(^\|_\)sorter_'
    1              0.000006         if name ==# 'sorter_default'
    1   0.000124   0.000114           let sorters += unite#filters#sorter_default#get()
    1              0.000004         else
                                      call add(sorters, Filter)
                                    endif
    1              0.000002       else
    1              0.000007         call add((empty(matchers) ? prev_filters : post_filters), Filter)
    1              0.000001       endif
    3              0.000009       unlet Filter
    3              0.000009     endfor
                            
    1              0.000004     if sorters ==# ['sorter_nothing'] || unite.context.unite__is_vimfiler
                                  let sorters = []
                                endif
                            
    1              0.000006     let context.unite__is_sort_nothing = empty(sorters) && context.unite__is_interactive
    1              0.000004     let source.unite__orig_len_candidates = len(source_candidates)
    1              0.000008     let unite.max_source_candidates += (context.unite__is_sort_nothing    && context.unite__max_candidates > 0) ? source.max_candidates : source.unite__orig_len_candidates
                            
                                " Call filters.
    4              0.000012     for Filter in prev_filters + matchers + sorters + post_filters
    3              0.000011       if type(Filter) == type('')
    3   0.009771   0.000031         let source_candidates = unite#helper#call_filter( Filter, source_candidates, context)
    3              0.000003       else
                                    let source_candidates = call(Filter, [source_candidates, context], source)
                                  endif
                            
    3              0.000005       unlet Filter
    3              0.000008     endfor
                            
                                " Get execute_command.
    1              0.000003     let a:context.execute_command = context.execute_command
                            
    1              0.000003     let source.unite__candidates += source_candidates
    1              0.000003     let source.unite__len_candidates = len(source_candidates)
    1              0.000002     if !empty(source_candidates)
    1   0.000051   0.000013       call add(candidate_sources, unite#helper#convert_source_name(source.name))
    1              0.000000     endif
    1              0.000000   endfor
                            
    1              0.000004   if !a:context.hide_source_names && len(unite.sources) > 1
                                let unite.max_source_name = max(map(candidate_sources, 'len(v:val)')) + 1
                              endif

FUNCTION  <SNR>191_waitpid()
Called 1 time
Total time:   0.000161
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000001   try
    1   0.000131   0.000008     let [cond, status] = s:libcall('vp_waitpid', [a:pid])
                                " echomsg string([a:pid, cond, status])
    1              0.000002     if cond ==# 'run'
                                  " Add process list.
                                  let s:bg_processes[a:pid] = a:pid
                            
                                  let [cond, status] = ['exit', '0']
                                elseif vimproc#util#is_windows()
                                  call s:libcall('vp_close_handle', [a:pid])
                                endif
                            
    1              0.000002     let s:last_status = status
    1              0.000001   catch
                                let [cond, status] = ['error', '0']
                              endtry
                            
    1              0.000003   return [cond, str2nr(status)]

FUNCTION  unite#helper#get_substitute_input()
Called 1 time
Total time:   0.000651
 Self time:   0.000284

count  total (s)   self (s)
    1              0.000008   let input = a:input
                            
    1   0.000066   0.000013   let unite = unite#get_current_unite()
    1   0.000432   0.000139   let substitute_patterns = reverse(unite#util#sort_by( values(unite#custom#get_profile(unite.profile_name,        'substitute_patterns')), 'v:val.priority'))
    1              0.000016   if unite.input != '' && stridx(input, unite.input) == 0
                                " Substitute after input.
                                let input_save = input
                                let input = input_save[len(unite.input) :]
                                let head = input_save[: len(unite.input)-1]
                              else
                                " Substitute all input.
    1              0.000005     let head = ''
    1              0.000002   endif
                            
    1   0.000055   0.000034   let inputs = unite#helper#get_substitute_input_loop(input, substitute_patterns)
                            
    1              0.000023   return map(inputs, 'head . v:val')

FUNCTION  editorconfig#ApplyHooks()
Called 5 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
                                " apply hooks
                            
    5              0.000032     for Hook in s:hook_list
                                    let l:hook_ret = Hook(a:config)
                            
                                    if type(l:hook_ret) != type(0) && l:hook_ret != 0
                                        " TODO print some debug info here
                                    endif
                                endfor

FUNCTION  111()
Called 106 times
Total time:   0.002209
 Self time:   0.002209

count  total (s)   self (s)
  106              0.001935     return has('signs') && exists('b:syntastic_enable_signs') ? b:syntastic_enable_signs : g:syntastic_enable_signs

FUNCTION  112()
Called 53 times
Total time:   0.744804
 Self time:   0.004042

count  total (s)   self (s)
   53   0.001882   0.000706     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
   53   0.002200   0.000955     let old_signs = copy(self._bufSignIds())
   53   0.001432   0.000507     if self.enabled()
   53   0.510832   0.000675         call self._signErrors(a:loclist)
   53              0.000070     endif
   53   0.227827   0.000568     call self._removeSigns(old_signs)
   53              0.000284     let s:first_sign_id = s:next_sign_id

FUNCTION  114()
Called 53 times
Total time:   0.510157
 Self time:   0.467635

count  total (s)   self (s)
   53              0.000322     let loclist = a:loclist
   53   0.002121   0.000479     if loclist.hasErrorsOrWarningsToDisplay()
                            
                                    " errors some first, so that they are not masked by warnings
   35              0.000345         let buf = bufnr('')
   35   0.021924   0.000656         let issues = copy(loclist.errors())
   35   0.000874   0.000469         if !loclist.quietWarnings()
   35   0.015585   0.000750             call extend(issues, loclist.warnings())
   35              0.000079         endif
   35              0.001709         call filter(issues, 'v:val["bufnr"] == buf')
   35              0.000210         let seen = {}
                            
  267              0.000815         for i in issues
  232              0.002091             if !has_key(seen, i['lnum'])
  183              0.001712                 let seen[i['lnum']] = 1
                            
  183              0.001690                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
  183              0.001600                 let sign_subtype = get(i, 'subtype', '')
  183              0.001616                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
  183              0.440203                 execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
  183   0.009818   0.005446                 call add(self._bufSignIds(), s:next_sign_id)
  183              0.001384                 let s:next_sign_id += 1
  183              0.000391             endif
  232              0.000427         endfor
   35              0.000055     endif

FUNCTION  116()
Called 612 times
Total time:   0.009823
 Self time:   0.009823

count  total (s)   self (s)
  612              0.004236     if !exists("b:syntastic_sign_ids")
    7              0.000024         let b:syntastic_sign_ids = []
    7              0.000006     endif
  612              0.001763     return b:syntastic_sign_ids

FUNCTION  322()
Called 5 times
Total time:   0.076610
 Self time:   0.000051

count  total (s)   self (s)
    5   0.001116   0.000022     if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
                                endif
                            
    5   0.000125   0.000025     call self.open()
                            
    5   0.002867   0.000076     if self.path.equals(a:path.getParent())
    1   0.000590   0.000006         let n = self.findNode(a:path)
    1   0.004371   0.000008         call nerdtree#renderView()
    1   0.001773   0.000007         call n.putCursorHere(1,0)
    1              0.000001         return
                                endif
                            
    4              0.000008     let p = a:path
   14   0.007627   0.000222     while !p.getParent().equals(self.path)
   10   0.003532   0.000102         let p = p.getParent()
   10              0.000026     endwhile
                            
    4   0.003878   0.000033     let n = self.findNode(p)
    4              0.000016     call n.reveal(a:path)

FUNCTION  unite#get_filters()
Called 7 times
Total time:   0.019848
 Self time:   0.000108

count  total (s)   self (s)
    7   0.019828   0.000088   return call('unite#variables#filters', a:000)

FUNCTION  327()
Called 4 times
Total time:   0.000062
 Self time:   0.000050

count  total (s)   self (s)
    4              0.000009     if self._keepopen
                                    return
                                endif
                            
    4              0.000012     if (a:newtab && self._where == 't') || !a:newtab
    2   0.000020   0.000008         call nerdtree#closeTreeIfQuitOnOpen()
    2              0.000001     endif

FUNCTION  329()
Called 2 times
Total time:   0.000166
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000027     let newObj = copy(self)
                            
    2              0.000007     let newObj._path = a:path
    2   0.000025   0.000014     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
    2   0.000027   0.000016     let newObj._reuse = nerdtree#has_opt(a:opts, 'reuse')
    2   0.000022   0.000013     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    2              0.000010     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    2              0.000006     let newObj._treetype = b:NERDTreeType
    2   0.000028   0.000008     call newObj._saveCursorPos()
                            
    2              0.000003     return newObj

FUNCTION  <SNR>130_closeTreeWindow()
Called 1 time
Total time:   0.009274
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000012     if b:NERDTreeType ==# "secondary" && b:NERDTreePreviousBuf != -1
                                    exec "buffer " . b:NERDTreePreviousBuf
                                else
    1              0.000007         if winnr("$") > 1
    1   0.009238   0.000015             call nerdtree#closeTree()
    1              0.000000         else
                                        call nerdtree#echo("Cannot close last window")
                                    endif
    1              0.000001     endif

FUNCTION  304()
Called 6 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    6              0.000020     return len(self.children)

FUNCTION  nerdtree#treeExistsForBuf()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     return exists("b:NERDTreeRoot")

FUNCTION  GetJavaIndent()
Called 70 times
Total time:   0.084755
 Self time:   0.041936

count  total (s)   self (s)
                            
                              " Java is just like C; use the built-in C indenting and then correct a few
                              " specific cases.
   70              0.007540   let theIndent = cindent(v:lnum)
                            
                              " If we're in the middle of a comment then just trust cindent
   70              0.001736   if getline(v:lnum) =~ '^\s*\*'
                                return theIndent
                              endif
                            
                              " find start of previous line, in case it was a continuation line
   70   0.010128   0.001959   let lnum = SkipJavaBlanksAndComments(v:lnum - 1)
                            
                              " If the previous line starts with '@', we should have the same indent as
                              " the previous one
   70              0.001150   if getline(lnum) =~ '^\s*@\S\+\s*$'
    3              0.000252     return indent(lnum)
                              endif
                            
   67              0.000350   let prev = lnum
   67              0.000354   while prev > 1
   56   0.006627   0.001073     let next_prev = SkipJavaBlanksAndComments(prev - 1)
   56              0.000642     if getline(next_prev) !~ ',\s*$'
   56              0.000142       break
                                endif
                                let prev = next_prev
                              endwhile
                            
                              " Try to align "throws" lines for methods and "extends" and "implements" for
                              " classes.
   67              0.002008   if getline(v:lnum) =~ '^\s*\(extends\|implements\)\>' && getline(lnum) !~ '^\s*\(extends\|implements\)\>'
                                let theIndent = theIndent + &sw
                              endif
                            
                              " correct for continuation lines of "throws", "implements" and "extends"
   67              0.002702   let cont_kw = matchstr(getline(prev), '^\s*\zs\(throws\|implements\|extends\)\>\ze.*,\s*$')
   67              0.000523   if strlen(cont_kw) > 0
                                let amount = strlen(cont_kw) + 1
                                if getline(lnum) !~ ',\s*$'
                                  let theIndent = theIndent - (amount + &sw)
                                  if theIndent < 0
                                    let theIndent = 0
                                  endif
                                elseif prev == lnum
                                  let theIndent = theIndent + amount
                                  if cont_kw ==# 'throws'
                                    let theIndent = theIndent + &sw
                                  endif
                                endif
                              elseif getline(prev) =~ '^\s*\(throws\|implements\|extends\)\>' && (getline(prev) =~ '{\s*$'  || getline(v:lnum) =~ '^\s*{\s*$')
                                let theIndent = theIndent - &sw
                              endif
                            
                              " When the line starts with a }, try aligning it with the matching {,
                              " skipping over "throws", "extends" and "implements" clauses.
   67              0.001435   if getline(v:lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$'
   10              0.000086     call cursor(v:lnum, 1)
   10   0.023532   0.000948     silent normal %
   10              0.000081     let lnum = line('.')
   10              0.000046     if lnum < v:lnum
   10              0.000039       while lnum > 1
   10   0.001109   0.000194         let next_lnum = SkipJavaBlanksAndComments(lnum - 1)
   10              0.000361         if getline(lnum) !~ '^\s*\(throws\|extends\|implements\)\>' && getline(next_lnum) !~ ',\s*$'
   10              0.000031           break
                                    endif
                                    let lnum = prevnonblank(next_lnum)
                                  endwhile
   10              0.000056       return indent(lnum)
                                endif
                              endif
                            
                              " Below a line starting with "}" never indent more.  Needed for a method
                              " below a method with an indented "throws" clause.
   57   0.006901   0.001304   let lnum = SkipJavaBlanksAndComments(v:lnum - 1)
   57              0.001345   if getline(lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$' && indent(lnum) < theIndent
                                let theIndent = indent(lnum)
                              endif
                            
   57              0.000195   return theIndent

FUNCTION  unite#handlers#_on_buf_unload()
Called 3 times
Total time:   0.001691
 Self time:   0.001071

count  total (s)   self (s)
    3              0.000010   match
                            
                              " Save unite value.
    3              0.000963   let unite = getbufvar(a:bufname, 'unite')
    3              0.000017   if type(unite) != type({})
                                " Invalid unite.
                                return
                              endif
                            
    3              0.000005   if unite.is_finalized
    2              0.000002     return
                              endif
                            
                              " Restore options.
    1              0.000004   if has_key(unite, 'redrawtime_save')
    1              0.000008     let &redrawtime = unite.redrawtime_save
    1              0.000001   endif
    1              0.000005   let &sidescrolloff = unite.sidescrolloff_save
                            
    1   0.000046   0.000009   call unite#handlers#_restore_updatetime()
                            
                              " Call finalize functions.
    1   0.000594   0.000011   call unite#helper#call_hook(unite#loaded_sources_list(), 'on_close')
    1              0.000004   let unite.is_finalized = 1

FUNCTION  31()
Called 53 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
   53              0.000506     return has('balloon_eval') && (exists('b:syntastic_enable_balloons') ? b:syntastic_enable_balloons : g:syntastic_enable_balloons)

FUNCTION  33()
Called 37 times
Total time:   0.001438
 Self time:   0.001438

count  total (s)   self (s)
   37              0.000600     if has('balloon_eval')
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: reset')
                                    set nobeval
                                endif

FUNCTION  35()
Called 64 times
Total time:   0.000690
 Self time:   0.000690

count  total (s)   self (s)
   64              0.000406     return self._filetype

FUNCTION  36()
Called 165 times
Total time:   0.001273
 Self time:   0.001273

count  total (s)   self (s)
  165              0.000872     return self._name

FUNCTION  37()
Called 32 times
Total time:   0.001402
 Self time:   0.001402

count  total (s)   self (s)
   32              0.000686     if exists('g:syntastic_' . self._filetype . '_' . self._name . '_exec')
                                    return expand(g:syntastic_{self._filetype}_{self._name}_exec)
                                endif
                            
   32              0.000130     return self._exec

FUNCTION  38()
Called 32 times
Total time:  26.444437
 Self time:   0.009076

count  total (s)   self (s)
   32              0.000255     try
   32  26.419031   0.002918         let list = self._locListFunc()
   32   0.005239   0.002803         call syntastic#log#debug(g:SyntasticDebugTrace, 'getLocList: checker ' . self._filetype . '/' . self._name . ' returned ' . v:shell_error)
   32              0.000161     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    call syntastic#log#error('checker ' . self._filetype . '/' . self._name . ' returned abnormal status ' . v:shell_error)
                                endtry
   32   0.003910   0.000709     call self._populateHighlightRegexes(list)
   32   0.014287   0.000676     return g:SyntasticLoclist.New(list)

FUNCTION  nerdtree#findAndRevealPath()
Called 1 time
Total time:   0.062935
 Self time:   0.000433

count  total (s)   self (s)
    1              0.000008     try
    1   0.001566   0.000115         let p = g:NERDTreePath.New(expand("%:p"))
    1              0.000004     catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("no file for the current buffer")
                                    return
                                endtry
                            
    1   0.000287   0.000016     if p.isUnixHiddenPath()
                                    let showhidden=g:NERDTreeShowHidden
                                    let g:NERDTreeShowHidden = 1
                                endif
                            
    1   0.000037   0.000022     if !nerdtree#treeExistsForTab()
                                    try
                                        let cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("current directory does not exist.")
                                        let cwd = p.getParent()
                                    endtry
                            
                                    if p.isUnder(cwd)
                                        call g:NERDTreeCreator.CreatePrimary(cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreatePrimary(p.getParent().str())
                                    endif
                                else
    1   0.000924   0.000035         if !p.isUnder(g:NERDTreeFileNode.GetRootForTab().path)
                                        if !nerdtree#isTreeOpen()
                                            call g:NERDTreeCreator.TogglePrimary('')
                                        else
                                            call nerdtree#putCursorInTreeWin()
                                        endif
                                        let b:NERDTreeShowHidden = g:NERDTreeShowHidden
                                        call nerdtree#chRoot(g:NERDTreeDirNode.New(p.getParent()))
                                    else
    1   0.000141   0.000021             if !nerdtree#isTreeOpen()
    1   0.033612   0.000024                 call g:NERDTreeCreator.TogglePrimary("")
    1              0.000001             endif
    1              0.000001         endif
    1              0.000000     endif
    1   0.000118   0.000006     call nerdtree#putCursorInTreeWin()
    1   0.026047   0.000015     call b:NERDTreeRoot.reveal(p)
                            
    1   0.000039   0.000015     if p.isUnixHiddenFile()
                                    let g:NERDTreeShowHidden = showhidden
                                endif

FUNCTION  unite#handlers#_on_cursor_hold_i()
Called 1 time
Total time:   0.000594
 Self time:   0.000098

count  total (s)   self (s)
    1   0.000105   0.000030   let unite = unite#get_current_unite()
                            
    1   0.000443   0.000022   call s:change_highlight()
                            
    1              0.000007   if unite.max_source_candidates > unite.redraw_hold_candidates
                                call s:check_redraw()
                              endif
                            
    1              0.000005   if unite.is_async && &l:modifiable
                                " Ignore key sequences.
                                call feedkeys("a\<BS>", 'n')
                                " call feedkeys("\<C-r>\<ESC>", 'n')
                              endif

FUNCTION  <SNR>114_get_section()
Called 1028 times
Total time:   0.081083
 Self time:   0.066127

count  total (s)   self (s)
 1028              0.007148   if has_key(s:section_truncate_width, a:key)
  565              0.004396     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   62              0.000103       return ''
                                endif
  503              0.000601   endif
  966              0.005056   let spc = g:airline_symbols.space
  966   0.032057   0.017101   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  966              0.014295   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  966              0.008536   return empty(text) ? '' : prefix.text.suffix

FUNCTION  tagbar#currenttag()
Called 5469 times
Total time:   0.286257
 Self time:   0.252351

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
 5469              0.022922     let s:statusline_in_use = 1
                            
 5469              0.010120     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
 5469              0.056549         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
 5469              0.026251         let fullpath  = a:1 =~# 'f'
 5469              0.022709         let prototype = a:1 =~# 'p'
 5469              0.006747     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
 5469   0.064984   0.031078     if !s:Init(1)
 5469              0.011085         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(0, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  unite#sources#buffer#variables#append()
Called 74 times
Total time:   0.001545
 Self time:   0.001545

count  total (s)   self (s)
                              " Append the current buffer.
   74              0.000397   let bufnr = bufnr('%')
   74              0.000928   let s:buffer_list[bufnr] = { 'action__buffer_nr' : bufnr, 'source__time' : localtime(), }

FUNCTION  ctrlp#mrufiles#cachefile()
Called 5 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    5              0.000057 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    5              0.000014 	retu s:cafile

FUNCTION  121()
Called 2543 times
Total time:   0.027934
 Self time:   0.027934

count  total (s)   self (s)
 2543              0.007437   let self._side = 0
 2543              0.017094   let self._line .= '%#'.self._curgroup.'#'.(a:0 ? a:1 : '%=')

FUNCTION  123()
Called 12817 times
Total time:   6.539348
 Self time:   1.639008

count  total (s)   self (s)
12817              0.041862   if self._curgroup != ''
10274              0.032575     if self._curgroup == a:group
                                  let self._line .= self._side ? self._context.left_alt_sep : self._context.right_alt_sep
                                else
10274   4.995456   0.095116       call airline#highlighter#add_separator(self._curgroup, a:group, self._side)
10274              0.081793       let self._line .= '%#'.self._curgroup.'_to_'.a:group.'#'
10274              0.065510       let self._line .= self._side ? self._context.left_sep : self._context.right_sep
10274              0.012230     endif
10274              0.009286   endif
                            
12817              0.039783   if self._curgroup != a:group
12817              0.059430     let self._line .= '%#'.a:group.'#'
12817              0.014005   endif
                            
12817              0.024339   if self._context.active
12561              0.036203     let contents = []
12561              0.131040     let content_parts = split(a:contents, '__accent')
22998              0.065248     for cpart in content_parts
10437              0.103541       let accent = matchstr(cpart, '_\zs[^#]*\ze')
10437              0.086574       call add(contents, cpart)
10437              0.016932     endfor
12561              0.078020     let line = join(contents, a:group)
12561              0.119309     let line = substitute(line, '__restore__', a:group, 'g')
12561              0.014741   else
  256              0.005622     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  256              0.003748     let line = substitute(line, '%#__restore__#', '', 'g')
  256              0.000436   endif
                            
12817              0.046913   let self._line .= line
12817              0.038214   let self._curgroup = a:group

FUNCTION  124()
Called 2562 times
Total time:   0.014144
 Self time:   0.014144

count  total (s)   self (s)
 2562              0.011661   let self._line .= a:text

FUNCTION  125()
Called 2543 times
Total time:   0.033760
 Self time:   0.033760

count  total (s)   self (s)
 2543              0.006331   if !self._context.active
   65              0.005706     let self._line = substitute(self._line, '%#.\{-}\ze#', '\0_inactive', 'g')
   65              0.000131   endif
 2543              0.006655   return self._line

FUNCTION  <SNR>205_filter_alias_action()
Called 20 times
Total time:   0.000823
 Self time:   0.000823

count  total (s)   self (s)
   26              0.000147   for [alias_name, alias_action] in items(a:alias_table)
    6              0.000018     if alias_action ==# 'nop'
                                  if has_key(a:action_table, alias_name)
                                    " Delete nop action.
                                    call remove(a:action_table, alias_name)
                                  endif
                                elseif has_key(a:action_table, alias_action)
    6              0.000047       let a:action_table[alias_name] = copy(a:action_table[alias_action])
    6              0.000021       let a:action_table[alias_name].from = a:from
    6              0.000019       let a:action_table[alias_name].name = alias_name
    6              0.000007     endif
    6              0.000005   endfor

FUNCTION  vimproc#filepath#which()
Called 1 time
Total time:   0.000653
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000652   0.000010   return s:which(a:command, a:path)

FUNCTION  <SNR>168_is_beginning_of_line()
Called 17 times
Total time:   0.001596
 Self time:   0.001596

count  total (s)   self (s)
   17              0.000144   let keyword_pattern = '\S\+'
   17              0.000604   let cur_keyword_str = matchstr(a:cur_text, keyword_pattern.'$')
   17              0.000314   let line_part = a:cur_text[: -1-len(cur_keyword_str)]
   17              0.000335   let prev_word_end = matchend(line_part, keyword_pattern)
                            
   17              0.000092   return prev_word_end <= 0

FUNCTION  332()
Called 2 times
Total time:   0.102621
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000004     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
    2   0.102604   0.000015         call self._openFile()
    2              0.000002     endif

FUNCTION  333()
Called 2 times
Total time:   0.102589
 Self time:   0.000083

count  total (s)   self (s)
    2   0.001101   0.000011     if self._reuse && self._reuseWindow()
                                    return
                                endif
                            
    2   0.004710   0.000013     call self._gotoTargetWin()
                            
    2              0.000004     if self._treetype ==# "secondary"
                                    call self._path.edit()
                                else
    2   0.096741   0.000022         call self._path.edit()
                            
                            
    2              0.000007         if self._stay
                                        call self._restoreCursorPos()
                                    endif
    2              0.000001     endif

FUNCTION  337()
Called 2 times
Total time:   0.001090
 Self time:   0.000322

count  total (s)   self (s)
                                "check the current tab for the window
    2   0.000488   0.000247     let winnr = bufwinnr('^' . self._path.str() . '$')
    2              0.000005     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                else
                                    "check other tabs
    2   0.000546   0.000019         let tabnr = self._path.tabnr()
    2              0.000003         if tabnr
                                        call self._checkToCloseTree(1)
                                        call nerdtree#exec('normal! ' . tabnr . 'gt')
                                        let winnr = bufwinnr('^' . self._path.str() . '$')
                                        call nerdtree#exec(winnr . "wincmd w")
                                        return 1
                                    endif
    2              0.000002     endif
    2              0.000002     return 0

FUNCTION  338()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000009     let self._bufnr = bufnr("")
    2              0.000008     let self._tabnr = tabpagenr()

FUNCTION  unite#variables#dynamic()
Called 32 times
Total time:   0.000512
 Self time:   0.000512

count  total (s)   self (s)
   32              0.000125   if !exists('s:dynamic')
    1              0.000002     let s:dynamic = {}
    1              0.000003     let s:dynamic.sources = {}
    1              0.000002     let s:dynamic.kinds = {}
    1              0.000002     let s:dynamic.filters = {}
    1              0.000000   endif
                            
   32              0.000065   return s:dynamic

FUNCTION  41()
Called 32 times
Total time:   0.027072
 Self time:   0.000772

count  total (s)   self (s)
   32   0.027004   0.000704     return self._makeprgFunc(a:opts)

FUNCTION  43()
Called 32 times
Total time:   0.003201
 Self time:   0.003201

count  total (s)   self (s)
   32              0.000422     let list = a:errors
   32              0.000424     if !empty(self._highlightRegexFunc)
                                    for e in list
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if len(term) > 0
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif
   32              0.000125     return list

FUNCTION  45()
Called 106 times
Total time:   0.000866
 Self time:   0.000866

count  total (s)   self (s)
  106              0.000775     return exists('b:syntastic_echo_current_error') ? b:syntastic_echo_current_error : g:syntastic_echo_current_error

FUNCTION  46()
Called 53 times
Total time:   0.009827
 Self time:   0.002151

count  total (s)   self (s)
   53   0.001134   0.000448     if self.enabled() && a:loclist.hasErrorsOrWarningsToDisplay()
   35   0.000628   0.000220         call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
   35   0.007045   0.000463         let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
   35              0.000112         let b:oldLine = -1
   35              0.000267         autocmd! syntastic CursorMoved
   35              0.000250         autocmd syntastic CursorMoved * call g:SyntasticRefreshCursor()
   35              0.000034     endif

FUNCTION  47()
Called 37 times
Total time:   0.003744
 Self time:   0.002720

count  total (s)   self (s)
   37   0.001642   0.000618     call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: reset')
   37              0.000838     autocmd! syntastic CursorMoved
   37              0.000700     unlet! b:syntastic_messages
   37              0.000288     let b:oldLine = -1

FUNCTION  49()
Called 106 times
Total time:   0.001062
 Self time:   0.001062

count  total (s)   self (s)
  106              0.000969     return s:has_highlighting && (exists('b:syntastic_enable_highlighting') ? b:syntastic_enable_highlighting : g:syntastic_enable_highlighting)

FUNCTION  AutoPairsDelete()
Called 127 times
Total time:   0.051269
 Self time:   0.051269

count  total (s)   self (s)
  127              0.002670   if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
  127              0.002456   let line = getline('.')
  127              0.002319   let pos = col('.') - 1
  127              0.004603   let current_char = get(split(strpart(line, pos), '\zs'), 0, '')
  127              0.006141   let prev_chars = split(strpart(line, 0, pos), '\zs')
  127              0.001413   let prev_char = get(prev_chars, -1, '')
  127              0.001176   let pprev_char = get(prev_chars, -2, '')
                            
  127              0.001008   if pprev_char == '\'
                                return "\<BS>"
                              end
                            
                              " Delete last two spaces in parens, work with MapSpace
  127              0.001653   if has_key(b:AutoPairs, pprev_char) && prev_char == ' ' && current_char == ' '
                                return "\<BS>\<DEL>"
                              endif
                            
                              " Delete Repeated Pair eg: '''|''' [[|]] {{|}}
  127              0.000953   if has_key(b:AutoPairs, prev_char)
                                let times = 0
                                let p = -1
                                while get(prev_chars, p, '') == prev_char
                                  let p = p - 1
                                  let times = times + 1
                                endwhile
                            
                                let close = b:AutoPairs[prev_char]
                                let left = repeat(prev_char, times)
                                let right = repeat(close, times)
                            
                                let before = strpart(line, pos-times, times)
                                let after  = strpart(line, pos, times)
                                if left == before && right == after
                                  return repeat("\<BS>\<DEL>", times)
                                end
                              end
                            
                            
  127              0.001019   if has_key(b:AutoPairs, prev_char) 
                                let close = b:AutoPairs[prev_char]
                                if match(line,'^\s*'.close, col('.')-1) != -1
                                  " Delete (|___)
                                  let space = matchstr(line, '^\s*', col('.')-1)
                                  return "\<BS>". repeat("\<DEL>", len(space)+1)
                                elseif match(line, '^\s*$', col('.')-1) != -1
                                  " Delete (|__\n___)
                                  let nline = getline(line('.')+1)
                                  if nline =~ '^\s*'.close
                                    if &filetype == 'vim' && prev_char == '"'
                                      " Keep next line's comment
                                      return "\<BS>"
                                    end
                            
                                    let space = matchstr(nline, '^\s*')
                                    return "\<BS>\<DEL>". repeat("\<DEL>", len(space)+1)
                                  end
                                end
                              end
                            
  127              0.001050   return "\<BS>"

FUNCTION  nerdtree#escChars()
Called 2 times
Total time:   0.000035
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000023   0.000008     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
    2              0.000003     return " \\`\|\"#%&,?()\*^<>[]"

FUNCTION  nerdtree#version()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000008     return '4.2.0'

FUNCTION  <SNR>186__is_absolute_path()
Called 11 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   11              0.000045     return a:path[0] ==# '/'

FUNCTION  neobundle#util#uniq()
Called 3 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    3              0.000018   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
    3              0.000004   let i = 0
    3              0.000005   let seen = {}
    3              0.000009   while i < len(list)
                                let key = string(a:0 ? list[i][1] : list[i])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
    3              0.000007   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  <SNR>60_append()
Called 80 times
Total time:   0.022453
 Self time:   0.001647

count  total (s)   self (s)
   80              0.000729   if bufnr('%') != expand('<abuf>') || a:path == ''
    8              0.000014     return
                              endif
                            
   72   0.021348   0.000542   call unite#sources#mru#variables#append()

FUNCTION  <SNR>186_import()
Called 6 times
Total time:   0.048948
 Self time:   0.000278

count  total (s)   self (s)
    6              0.000024   let target = {}
    6              0.000018   let functions = []
    6              0.000018   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
    6   0.046854   0.018186   let module = s:_import(a:name)
    6              0.000014   if empty(functions)
    6              0.000076     call extend(target, module, 'keep')
    6              0.000006   else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
    6              0.000006   return target

FUNCTION  nerdtree#saveScreenState()
Called 3 times
Total time:   0.001724
 Self time:   0.000328

count  total (s)   self (s)
    3              0.000030     let win = winnr()
    3              0.000012     try
    3   0.001222   0.000042         call nerdtree#putCursorInTreeWin()
    3              0.000054         let b:NERDTreeOldPos = getpos(".")
    3              0.000059         let b:NERDTreeOldTopLine = line("w0")
    3              0.000032         let b:NERDTreeOldWindowSize = winwidth("")
    3   0.000268   0.000052         call nerdtree#exec(win . "wincmd w")
    3              0.000013     catch /^NERDTree.InvalidOperationError/
                                endtry

FUNCTION  349()
Called 5 times
Total time:   0.000348
 Self time:   0.000348

count  total (s)   self (s)
    5              0.000291     let newCreator = copy(self)
    5              0.000035     return newCreator

FUNCTION  syntastic#util#redraw()
Called 46 times
Total time:   0.459643
 Self time:   0.002142

count  total (s)   self (s)
   46              0.000325     if !g:syntastic_delayed_redraws || !pumvisible()
   46   0.458153   0.000652         call s:doRedraw(a:full)
   46              0.000303         let s:redraw_delayed = 0
   46              0.000182         let s:redraw_full = 0
   46              0.000122     else
                                    let s:redraw_delayed = 1
                                    let s:redraw_full = s:redraw_full || a:full
                                endif

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 5477 times
Total time:   1.110437
 Self time:   0.092268

count  total (s)   self (s)
 5477   1.062440   0.044271   let errors = SyntasticStatuslineFlag()
 5477              0.018342   if strlen(errors) > 0
 4134              0.016046     return errors.(g:airline_symbols.space)
                              endif
 1343              0.001424   return ''

FUNCTION  airline#extensions#tagbar#inactive_apply()
Called 65 times
Total time:   0.001226
 Self time:   0.001226

count  total (s)   self (s)
   65              0.000806   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                return -1
                              endif

FUNCTION  g:SyntasticLoclistHide()
Called 1 time
Total time:   0.000056
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000046   0.000018     call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: hide')
    1              0.000007     silent! lclose

FUNCTION  50()
Called 53 times
Total time:   0.019650
 Self time:   0.015964

count  total (s)   self (s)
   53   0.000703   0.000230     if self.enabled()
   53   0.002469   0.000286         call self.reset(a:loclist)
   53   0.000982   0.000381         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
   53              0.000223         let buf = bufnr('')
   53   0.001640   0.001211         let issues = filter(a:loclist.filteredRaw(), 'v:val["bufnr"] == buf')
  285              0.000506         for item in issues
  232              0.001039             let group = item['type'] ==? 'E' ? 'SyntasticError' : 'SyntasticWarning'
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
  232              0.000649             if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col')
  232              0.001219                 let lastcol = col([item['lnum'], '$'])
  232              0.001049                 let lcol = min([lastcol, item['col']])
                            
                                            " a bug in vim can sometimes cause there to be no 'vcol' key,
                                            " so check for its existence
  232              0.001093                 let coltype = has_key(item, 'vcol') && item['vcol'] ? 'v' : 'c'
                            
  232              0.003568                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
  232              0.000286             endif
  232              0.000218         endfor
   53              0.000121     endif

FUNCTION  51()
Called 90 times
Total time:   0.013241
 Self time:   0.011445

count  total (s)   self (s)
   90              0.000353     if s:has_highlighting
   90   0.002738   0.000942         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: reset')
  332              0.003109         for match in getmatches()
  242              0.001905             if stridx(match['group'], 'Syntastic') == 0
  240              0.002312                 call matchdelete(match['id'])
  240              0.000544             endif
  242              0.000453         endfor
   90              0.000120     endif

FUNCTION  53()
Called 108 times
Total time:   0.027491
 Self time:   0.027491

count  total (s)   self (s)
  108              0.005892     let newObj = copy(self)
  108              0.001115     let newObj._quietWarnings = g:syntastic_quiet_warnings
                            
  108              0.006275     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
  548              0.001982     for e in llist
  440              0.002968         if empty(e['type'])
                                        let e['type'] = 'E'
                                    endif
  440              0.001087     endfor
                            
  108              0.000763     let newObj._rawLoclist = llist
  108              0.000791     let newObj._hasErrorsOrWarningsToDisplay = -1
                            
  108              0.000554     let newObj._name = ''
                            
  108              0.000381     return newObj

FUNCTION  55()
Called 32 times
Total time:   0.012347
 Self time:   0.002278

count  total (s)   self (s)
   32   0.001014   0.000492     let list = self.toRaw()
   32   0.001688   0.001032     call extend(list, a:other.toRaw())
   32   0.009388   0.000497     return g:SyntasticLoclist.New(list)

FUNCTION  56()
Called 64 times
Total time:   0.001178
 Self time:   0.001178

count  total (s)   self (s)
   64              0.000984     return copy(self._rawLoclist)

FUNCTION  57()
Called 5530 times
Total time:   0.041672
 Self time:   0.041672

count  total (s)   self (s)
 5530              0.037388     return copy(self._quietWarnings ? self.errors() : self._rawLoclist)

FUNCTION  58()
Called 35 times
Total time:   0.000405
 Self time:   0.000405

count  total (s)   self (s)
   35              0.000270     return self._quietWarnings

FUNCTION  59()
Called 32 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
   32              0.000300     return empty(self._rawLoclist)

FUNCTION  unite#helper#adjustments()
Called 8 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    8              0.000071   let max_width = a:currentwinwidth - a:the_max_source_name - a:size
    8              0.000023   if max_width < 20
                                return [a:currentwinwidth - a:size, 0]
                              else
    8              0.000040     return [max_width, a:the_max_source_name]
                              endif

FUNCTION  205()
Called 647 times
Total time:   0.081359
 Self time:   0.036853

count  total (s)   self (s)
  647              0.002415     let options = a:0 ? a:1 : {}
  647              0.001539     let toReturn = ""
                            
  647              0.002032     if has_key(options, 'format')
   29              0.000125         let format = options['format']
   29              0.000164         if has_key(self, '_strFor' . format)
   29   0.001028   0.000390             exec 'let toReturn = self._strFor' . format . '()'
   29              0.000041         else
                                        raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   29              0.000028     else
  618   0.043390   0.003541         let toReturn = self._str()
  618              0.000746     endif
                            
  647   0.007490   0.003831     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
  647              0.001852     if has_key(options, 'truncateTo')
    6              0.000020         let limit = options['truncateTo']
    6              0.000024         if len(toReturn) > limit
    6              0.000055             let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
    6              0.000006         endif
    6              0.000003     endif
                            
  647              0.001009     return toReturn

FUNCTION  neobundle#autoload#unite_sources()
Called 3 times
Total time:   0.001230
 Self time:   0.000553

count  total (s)   self (s)
    3              0.000008   let bundles = []
    3   0.000572   0.000140   let sources_bundles = filter(neobundle#config#get_autoload_bundles(), "has_key(v:val.autoload, 'unite_sources')")
    9              0.000015   for source_name in a:sources
    6              0.000011     if source_name ==# 'source'
                                  " In source source, load all sources.
                                  let bundles += copy(sources_bundles)
                                else
    6   0.000431   0.000287       let bundles += filter(copy(sources_bundles), "index(neobundle#util#convert2list(    v:val.autoload.unite_sources), source_name) >= 0")
    6              0.000005     endif
    6              0.000004   endfor
                            
    3   0.000132   0.000031   call neobundle#config#source_bundles(neobundle#util#uniq(bundles))

FUNCTION  206()
Called 27 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   27              0.000271     let toReturn = '/' . join(self.pathSegments, '/')
   27              0.000116     if self.isDirectory && toReturn != '/'
   24              0.000099         let toReturn  = toReturn . '/'
   24              0.000029     endif
   27              0.000057     return toReturn

FUNCTION  unite#handlers#_restore_updatetime()
Called 5 times
Total time:   0.000163
 Self time:   0.000097

count  total (s)   self (s)
    5   0.000096   0.000030   let unite = unite#get_current_unite()
                            
    5              0.000018   if !has_key(unite, 'update_time_save')
                                return
                              endif
                            
    5              0.000012   if &updatetime < unite.update_time_save
                                let &updatetime = unite.update_time_save
                              endif

FUNCTION  unite#all_quit_session()
Called 2 times
Total time:   0.081255
 Self time:   0.000019

count  total (s)   self (s)
    2   0.081254   0.000018   call unite#view#_quit(get(a:000, 0, 1), 1)

FUNCTION  neobundle#autoload#filetype()
Called 8 times
Total time:   0.003005
 Self time:   0.000962

count  total (s)   self (s)
    8   0.002250   0.000525   let bundles = filter(neobundle#config#get_autoload_bundles(), "has_key(v:val.autoload, 'filetypes')")
   16   0.000235   0.000098   for filetype in neobundle#util#get_filetypes()
    8   0.000439   0.000258     call neobundle#config#source_bundles(filter(copy(bundles)," index(neobundle#util#convert2list(     v:val.autoload.filetypes), filetype) >= 0"))
    8              0.000009   endfor

FUNCTION  354()
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000008     if g:NERDTreeStatusline != -1
    3              0.000013         let &l:statusline = g:NERDTreeStatusline
    3              0.000002     endif

FUNCTION  355()
Called 5 times
Total time:   0.128446
 Self time:   0.000259

count  total (s)   self (s)
    5   0.000508   0.000160     let creator = s:Creator.New()
    5   0.127911   0.000072     call creator.togglePrimary(a:dir)

FUNCTION  356()
Called 5 times
Total time:   0.127839
 Self time:   0.000396

count  total (s)   self (s)
    5   0.000164   0.000086     if nerdtree#treeExistsForTab()
    5   0.000923   0.000077         if !nerdtree#isTreeOpen()
    3   0.100459   0.000047             call self._createTreeWin()
    3              0.000006             if !&hidden
                                            call nerdtree#renderView()
                                        endif
    3   0.000226   0.000024             call nerdtree#restoreScreenState()
    3              0.000003         else
    2   0.025940   0.000035             call nerdtree#closeTree()
    2              0.000000         endif
    5              0.000004     else
                                    call self.createPrimary(a:dir)
                                endif

FUNCTION  357()
Called 1 time
Total time:   0.006458
 Self time:   0.000354

count  total (s)   self (s)
    1   0.004526   0.000005   if !unite#util#has_vimproc()
                                call unite#print_source_error( 'vimproc is not installed.', s:source.name)
                                return
                              endif
                            
    1              0.000004   if type(get(a:args, 0, '')) == type([])
                                let a:context.source__target = a:args[0]
                                let targets = a:context.source__target
                              else
    1              0.000003     let default = get(a:args, 0, '')
                            
    1              0.000002     if default == ''
                                  let default = '.'
                                endif
                            
    1              0.000006     if type(get(a:args, 0, '')) == type('') && get(a:args, 0, '') == '' && a:context.input == ''
                                  let target = unite#util#substitute_path_separator( unite#util#input('Target: ', default, 'file'))
                                else
    1              0.000002       let target = default
    1              0.000001     endif
                            
    1              0.000003     if target == '%' || target == '#'
                                  let target = unite#util#escape_file_searching(bufname(target))
                                elseif target ==# '$buffers'
                                  let target = join(map(filter(range(1, bufnr('$')), 'buflisted(v:val) && filereadable(bufname(v:val))'), 'unite#util#escape_file_searching(bufname(v:val))'))
                                elseif target == '**'
                                  " Optimized.
                                  let target = '.'
                                else
                                  " Escape filename.
    1              0.000003       let target = escape(target, ' ')
    1              0.000001     endif
                            
    1              0.000004     let a:context.source__target = [target]
                            
    1              0.000025     let targets = map(filter(split(target), 'v:val !~ "^-"'), 'substitute(v:val, "\\*\\+$", "", "")')
    1              0.000001   endif
                            
    1              0.000004   let a:context.source__extra_opts = get(a:args, 1, '')
                            
    1              0.000004   let a:context.source__input = get(a:args, 2, a:context.input)
    1              0.000002   if a:context.source__input == ''
    1   0.001477   0.000032     let a:context.source__input = unite#util#input('Pattern: ')
    1              0.000017   endif
                            
    1   0.000237   0.000099   let a:context.source__directory = (len(targets) == 1) ? unite#util#substitute_path_separator(  unite#util#expand(targets[0])) : ''
                            
    1              0.000010   let a:context.source__ssh_path = ''
    1              0.000012   if exists('b:vimfiler') && exists('*vimfiler#get_current_vimfiler')
                                if !empty(b:vimfiler)
                                  let vimfiler = b:vimfiler
                                else
                                  let vimfiler = vimfiler#get_current_vimfiler()
                                endif
                            
                                if get(vimfiler, 'source', '') ==# 'ssh'
                                  let [hostname, port, path] = unite#sources#ssh#parse_path(  vimfiler.source.':'.vimfiler.current_dir)
                                  let a:context.source__ssh_path = printf('%s://%s:%s/', vimfiler.source, hostname, port)
                            
                                  call map(a:context.source__target, "substitute(v:val, 'ssh://', '', '')")
                                endif
                              endif

FUNCTION  358()
Called 1 time
Total time:   0.000134
 Self time:   0.000099

count  total (s)   self (s)
    1   0.000035   0.000004   if !unite#util#has_vimproc()
                                return
                              endif
                            
    1              0.000001   syntax case ignore
    1              0.000011   syntax region uniteSource__GrepLine start=' ' end='$' containedin=uniteSource__Grep
    1              0.000014   syntax match uniteSource__GrepFile /^[^:]*/ contained containedin=uniteSource__GrepLine nextgroup=uniteSource__GrepSeparator
    1              0.000009   syntax match uniteSource__GrepSeparator /:/ contained containedin=uniteSource__GrepLine nextgroup=uniteSource__GrepLineNr
    1              0.000010   syntax match uniteSource__GrepLineNr /\d\+\ze:/ contained containedin=uniteSource__GrepLine nextgroup=uniteSource__GrepPattern
    1              0.000020   execute 'syntax match uniteSource__GrepPattern /' . substitute(a:context.source__input, '\([/\\]\)', '\\\1', 'g') . '/ contained containedin=uniteSource__GrepLine'
    1              0.000005   highlight default link uniteSource__GrepFile Directory
    1              0.000005   highlight default link uniteSource__GrepLineNr LineNR
    1   0.000019   0.000015   execute 'highlight default link uniteSource__GrepPattern' unite#get_source_variables(a:context).search_word_highlight

FUNCTION  359()
Called 1 time
Total time:   0.000425
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000005   if has_key(a:context, 'source__proc')
    1   0.000418   0.000009     call a:context.source__proc.kill()
    1              0.000001   endif

FUNCTION  unite#util#index_name()
Called 20 times
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
   20              0.000268   return index(map(copy(a:list), 'v:val.name'), a:name)

FUNCTION  unite#init#_context()
Called 1 time
Total time:   0.000239
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000007   let source_names = get(a:000, 0, [])
                            
    1              0.000011   let profile_name = get(a:context, 'profile_name', ((len(source_names) == 1 && !has_key(a:context, 'buffer_name')) ?    'source/' . source_names[0] :    get(a:context, 'buffer_name', 'default')))
                            
                              " Overwrite default_context by profile context.
    1   0.000157   0.000044   let default_context = extend(copy(unite#variables#default_context()), unite#custom#get_profile(profile_name, 'context'))
                            
    1              0.000006   let context = extend(default_context, a:context)
                            
    1              0.000003   if context.temporary || context.script
                                " User can overwrite context by profile context.
                                let context = extend(context, unite#custom#get_profile(profile_name, 'context'))
                              endif
                            
                              " Complex initializer.
    1              0.000004   if get(context, 'complete', 1) && !has_key(a:context, 'start_insert')
                                let context.start_insert = 1
                              endif
    1              0.000002   if get(context, 'no_start_insert', 0)
                                " Disable start insert.
                                let context.start_insert = 0
                              endif
    1              0.000002   if has_key(context, 'horizontal')
                                " Disable vertically.
                                let context.vertical = 0
                              endif
    1              0.000001   if context.immediately
                                " Ignore empty unite buffer.
                                let context.no_empty = 1
                              endif
    1              0.000001   if context.tab
                                let context.no_split = 1
                              endif
    1              0.000002   if !has_key(context, 'short_source_names')
    1              0.000003     let context.short_source_names = g:unite_enable_short_source_names
    1              0.000001   endif
    1              0.000002   if get(context, 'long_source_names', 0)
                                " Disable short name.
                                let context.short_source_names = 0
                              endif
    1              0.000002   if &l:modified && !&l:hidden
                                " Split automatically.
                                let context.no_split = 0
                              endif
    1              0.000002   if !has_key(a:context, 'buffer_name') && context.script
                                " Set buffer-name automatically.
                                let context.buffer_name = join(source_names)
                              endif
                            
    1              0.000002   let context.is_changed = 0
                            
    1              0.000001   return context

FUNCTION  <SNR>187_escape_file_searching()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000021   return escape(a:buffer_name, '*[]?{}, ')

FUNCTION  <SNR>196_skip_single_quote()
Called 2 times
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
    2              0.000006   let max = len(a:script)
    2              0.000003   let string = ''
    2              0.000004   let i = a:i
                            
                              " a:script[i] is always "'" when this function is called
    2              0.000006   if i >= max || a:script[i] != ''''
                                throw 'Exception: Quote ('') is not found.'
                              endif
    2              0.000006   let string .= a:script[i]
    2              0.000004   let i += 1
                            
   30              0.000031   while i < max
   30              0.000057     if a:script[i] == ''''
    2              0.000006       if i+1 < max && a:script[i+1] == ''''
                                    " Escape quote.
                                    let string .= a:script[i]
                                    let i += 1
                                  else
    2              0.000002         break
                                  endif
                                endif
                            
   28              0.000076     let string .= a:script[i]
   28              0.000036     let i += 1
   28              0.000018   endwhile
                            
    2              0.000002   if i < max
                                " must end with "'"
    2              0.000005     if a:script[i] != ''''
                                  throw 'Exception: Quote ('') is not found.'
                                endif
    2              0.000004     let string .= a:script[i]
    2              0.000003     let i += 1
    2              0.000002   endif
                            
    2              0.000004   return [string, i]

FUNCTION  <SNR>191_funcref()
Called 49 times
Total time:   0.000809
 Self time:   0.000344

count  total (s)   self (s)
   49   0.000788   0.000323   return function(s:SID_PREFIX().a:funcname)

FUNCTION  434()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000019   return self.mtime < getftime(self.mru_file.short) || self.mtime < getftime(self.mru_file.long)

FUNCTION  unite#helper#parse_options_args()
Called 1 time
Total time:   0.005005
 Self time:   0.000243

count  total (s)   self (s)
    1              0.000014   let _ = []
    1   0.004794   0.000032   let [args, options] = unite#helper#parse_options(a:args)
    2              0.000010   for arg in args
                                " Add source name.
    1              0.000026     let source_name = matchstr(arg, '^[^:]*')
    1              0.000018     let source_arg = arg[len(source_name)+1 :]
    1              0.000057     let source_args = source_arg  == '' ? [] :  map(split(source_arg, '\\\@<!:', 1),      'substitute(v:val, ''\\\(.\)'', "\\1", "g")')
    1              0.000024     call add(_, insert(source_args, source_name))
    1              0.000003   endfor
                            
    1              0.000006   return [_, options]

FUNCTION  60()
Called 5477 times
Total time:   0.022275
 Self time:   0.022275

count  total (s)   self (s)
 5477              0.018286     return len(self._rawLoclist)

FUNCTION  62()
Called 32 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
   32              0.000324     let self._name = a:name

FUNCTION  64()
Called 5636 times
Total time:   0.035076
 Self time:   0.035076

count  total (s)   self (s)
 5636              0.016039     if self._hasErrorsOrWarningsToDisplay >= 0
 5592              0.011042         return self._hasErrorsOrWarningsToDisplay
                                endif
   44              0.000685     let self._hasErrorsOrWarningsToDisplay = empty(self._rawLoclist) ? 0 : (!self._quietWarnings || len(self.errors()))
   44              0.000163     return self._hasErrorsOrWarningsToDisplay

FUNCTION  65()
Called 4201 times
Total time:   0.068903
 Self time:   0.049313

count  total (s)   self (s)
 4201              0.017113     if !exists("self._cachedErrors")
   32   0.020467   0.000877         let self._cachedErrors = self.filter({'type': "E"})
   32              0.000078     endif
 4201              0.006976     return self._cachedErrors

FUNCTION  66()
Called 4201 times
Total time:   0.058512
 Self time:   0.044988

count  total (s)   self (s)
 4201              0.015499     if !exists("self._cachedWarnings")
   32   0.014174   0.000650         let self._cachedWarnings = self.filter({'type': "W"})
   32              0.000069     endif
 4201              0.006831     return self._cachedWarnings

FUNCTION  <SNR>29_Wholematch()
Called 12 times
Total time:   0.001459
 Self time:   0.001459

count  total (s)   self (s)
   12              0.000127   let group = '\%(' . a:pat . '\)'
   12              0.000172   let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
   12              0.000109   let len = strlen(a:string)
   12              0.000164   let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
   12              0.000631   if a:string !~ prefix . group . suffix
    8              0.000039     let prefix = ''
    8              0.000014   endif
   12              0.000091   return prefix . group . suffix

FUNCTION  68()
Called 64 times
Total time:   0.033114
 Self time:   0.033114

count  total (s)   self (s)
   64              0.000453     let rv = []
                            
  504              0.001898     for error in self._rawLoclist
  440              0.002292         let passes_filters = 1
  660              0.004279         for key in keys(a:filters)
  440              0.004939             if get(error, key, '') !=? a:filters[key]
  220              0.001161                 let passes_filters = 0
  220              0.000561                 break
                                        endif
  220              0.000497         endfor
                            
  440              0.001465         if passes_filters
  220              0.002415             call add(rv, error)
  220              0.000501         endif
  440              0.000983     endfor
   64              0.000236     return rv

FUNCTION  <SNR>212_open_current_line()
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000035   normal! zv
    2              0.000017   normal! zz
    2              0.000004   if a:is_highlight
                                execute 'match Search /\%'.line('.').'l/'
                              endif

FUNCTION  neosnippet#mappings#jumpable()
Called 17 times
Total time:   0.008823
 Self time:   0.008605

count  total (s)   self (s)
                              " Found snippet placeholder.
   17   0.008747   0.008529   return search(neosnippet#get_placeholder_marker_pattern(). '\|' .neosnippet#get_sync_placeholder_marker_pattern(), 'nw') > 0

FUNCTION  unite#util#convert2list()
Called 37 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   37              0.000224   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  airline#section#create()
Called 14 times
Total time:   0.002434
 Self time:   0.000088

count  total (s)   self (s)
   14   0.002429   0.000083   return s:create(a:parts, 0)

FUNCTION  unite#force_quit_session()
Called 1 time
Total time:   0.034737
 Self time:   0.000030

count  total (s)   self (s)
    1   0.034688   0.000008   call unite#view#_quit(1)
                            
    1   0.000043   0.000016   let context = unite#get_context()
    1              0.000003   if context.temporary && !empty(context.old_buffer_info)
                                call unite#start#resume_from_temporary(context)
                              endif

FUNCTION  <SNR>205_get_default_action()
Called 2 times
Total time:   0.002466
 Self time:   0.000127

count  total (s)   self (s)
    2   0.001907   0.000012   let source = unite#get_all_sources(a:source_name)
    2              0.000004   if empty(source)
                                return ''
                              endif
                            
    2              0.000009   let source_kind = 'source/'.a:source_name.'/'.a:kind_name
    2              0.000006   let source_kind_wild = 'source/'.a:source_name.'/*'
                            
    2   0.000040   0.000015   let custom = unite#custom#get()
                            
                              " Source/kind custom default actions.
    2              0.000006   if has_key(custom.default_actions, source_kind)
                                return custom.default_actions[source_kind]
                              endif
                            
                              " Source custom default actions.
    2              0.000005   if has_key(source.default_action, a:kind_name)
                                return source.default_action[a:kind_name]
                              endif
                            
                              " Source/* custom default actions.
    2              0.000004   if has_key(custom.default_actions, source_kind_wild)
                                return custom.default_actions[source_kind_wild]
                              endif
                            
                              " Source/* default actions.
    2              0.000004   if has_key(source.default_action, '*')
                                return source.default_action['*']
                              endif
                            
                              " Kind custom default actions.
    2              0.000005   if has_key(custom.default_actions, a:kind_name)
                                return custom.default_actions[a:kind_name]
                              endif
                            
                              " Kind default actions.
    2   0.000429   0.000010   let kind = unite#get_kinds(a:kind_name)
    2              0.000006   return get(kind, 'default_action', '')

FUNCTION  362()
Called 2 times
Total time:   0.028545
 Self time:   0.000593

count  total (s)   self (s)
    2   0.000024   0.000015   let variables = unite#get_source_variables(a:context)
                            
    2              0.000008   if !has_key(a:context, 'source__proc')
                                let a:context.is_async = 0
                                call unite#print_source_message('Completed.', s:source.name)
                                return []
                              endif
                            
    2              0.000005   let stderr = a:context.source__proc.stderr
    2              0.000002   if !stderr.eof
                                " Print error.
    1   0.012205   0.000038     let errors = filter(stderr.read_lines(-1, 100), "v:val !~ '^\\s*$'")
    1              0.000008     if !empty(errors)
                                  call unite#print_source_error(errors, s:source.name)
                                endif
    1              0.000002   endif
                            
    2              0.000011   let stdout = a:context.source__proc.stdout
    2              0.000005   if stdout.eof
                                " Disable async.
    1              0.000002     let a:context.is_async = 0
    1   0.013411   0.000008     call unite#print_source_message('Completed.', s:source.name)
                            
    1   0.000700   0.000015     call a:context.source__proc.waitpid()
    1              0.000000   endif
                            
    2   0.001767   0.000088   let candidates = map(stdout.read_lines(-1, 100), "unite#util#iconv(v:val, g:unite_source_grep_encoding, &encoding)")
    2              0.000021   if variables.default_opts =~ '^-[^-]*l' || a:context.source__extra_opts =~ '^-[^-]*l'
                                let candidates = map(filter(candidates, 'v:val != ""'), '[v:val, [v:val[2:], 0]]')
                              else
    2              0.000046     let candidates = map(filter(candidates,  'v:val =~ "^.\\+:.\\+$"'), '[v:val, split(v:val[2:], ":", 1)]')
    2              0.000002   endif
                            
    2              0.000004   if a:context.source__ssh_path != ''
                                " Use ssh command.
                                let [hostname, port, path] = unite#sources#ssh#parse_path(     a:context.source__ssh_path)
                              endif
                            
    2              0.000003   let _ = []
    3              0.000006   for candidate in candidates
    1              0.000008     if len(candidate[1]) <= 1 || candidate[1][1] !~ '^\d\+$'
                                  let dict = {   'action__path' : a:context.source__target[0], }
                                  if len(candidate[1]) <= 1
                                    let dict.action__line = candidate[0][:1][0]
                                    let dict.action__text = candidate[1][0]
                                  else
                                    let dict.action__line = candidate[0][:1].candidate[1][0]
                                    let dict.action__text = join(candidate[1][1:], ':')
                                  endif
                                else
    1              0.000014       let dict = {   'action__path' : candidate[0][:1].candidate[1][0],   'action__line' : candidate[1][1],   'action__text' : join(candidate[1][2:], ':'), }
    1              0.000001     endif
                            
    1              0.000002     if a:context.source__ssh_path != ''
                                  let dict.action__path = a:context.source__ssh_path . dict.action__path
                                else
    1   0.000042   0.000036       let dict.action__path = unite#util#substitute_path_separator(   fnamemodify(dict.action__path, ':p'))
    1              0.000002     endif
                            
    1   0.000022   0.000019     let dict.word = printf('%s:%s:%s',  unite#util#substitute_path_separator(     fnamemodify(dict.action__path, ':.')), dict.action__line, dict.action__text)
                            
    1              0.000005     call add(_, dict)
    1              0.000001   endfor
                            
    2              0.000002   return _

FUNCTION  365()
Called 1 time
Total time:   0.005351
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000009   let candidates = a:candidates
    2              0.000011   for default in s:default_converters
    1   0.005302   0.000016     let filter = unite#get_filters(default)
    1              0.000002     if !empty(filter)
    1   0.000011   0.000008       let candidates = filter.filter(candidates, a:context)
    1              0.000001     endif
    1              0.000001   endfor
                            
    1              0.000001   return candidates

FUNCTION  367()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                              " Nothing.
    1              0.000001   return a:candidates

FUNCTION  unite#action#do()
Called 2 times
Total time:   0.156304
 Self time:   0.000952

count  total (s)   self (s)
    2              0.000037   if &filetype == 'vimfiler' && has_key(b:vimfiler, 'unite')
                                " Restore unite condition in vimfiler.
                                call unite#set_current_unite(b:vimfiler.unite)
                              endif
                            
    2   0.000972   0.000027   call unite#redraw()
                            
    2   0.000628   0.000054   let candidates = get(a:000, 0, unite#helper#get_marked_candidates())
    2              0.000026   let new_context = get(a:000, 1, {})
    2              0.000020   let sources = get(a:000, 2, {})
                            
    2   0.000095   0.000032   let unite = unite#get_current_unite()
    2              0.000015   if empty(candidates)
    2              0.000034     let num = (line('.') <= unite.prompt_linenr) ? 0 : (line('.') - (unite.prompt_linenr + 1))
    2              0.000023     if line('$') - (unite.prompt_linenr + 1) < num
                                  " Ignore.
                                  return []
                                endif
                            
    2   0.000294   0.000040     let candidates = [ unite#helper#get_current_candidate() ]
    2              0.000005   endif
                            
    2              0.000052   let candidates = filter(copy(candidates), "!empty(v:val) && !get(v:val, 'is_dummy', 0)")
    2              0.000044   if empty(candidates)
                                return []
                              endif
                            
    2   0.071574   0.000055   let action_tables = s:get_candidates_action_table( a:action_name, candidates, sources)
                            
    2              0.000005   if !empty(new_context)
                                " Set new context.
                                let new_context = extend( deepcopy(unite#get_context()), new_context)
                                let old_context = unite#set_context(new_context)
                                let unite = unite#get_current_unite()
                              endif
                            
    2   0.000055   0.000016   let context = unite#get_context()
                            
                              " Execute action.
    2              0.000004   let is_quit = 0
    2              0.000004   let is_redraw = 0
    2              0.000002   let _ = []
    4              0.000006   for table in action_tables
                                " Check quit flag.
    2              0.000010     if table.action.is_quit && unite.profile_name !=# 'action' && !table.action.is_start && !(table.action.is_tab && context.no_quit)
    2   0.081269   0.000014       call unite#all_quit_session(0)
    2              0.000004       let is_quit = 1
    2              0.000000     endif
                            
    2              0.000008     if table.action.is_start && !empty(unite#helper#get_marked_candidates())
                                  call s:clear_marks(candidates)
                                  call unite#force_redraw()
                                  let is_redraw = 0
                                elseif table.action.is_selectable
    2              0.000003       let is_redraw = 1
    2              0.000001     endif
                            
    2              0.000002     try
    2   0.000722   0.000019       call add(_, table.action.func(table.candidates))
    2              0.000002     catch /^Vim\%((\a\+)\)\=:E325/
                                  " Ignore catch.
                                  call unite#print_error(v:exception)
                                  call unite#print_error('Warning: Swap file was found while executing action!')
                                  call unite#print_error('Action name is ' . table.action.name)
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error('Error occured while executing action!')
                                  call unite#print_error('Action name is ' . table.action.name)
                                endtry
                            
                                " Executes command.
    2              0.000005     if context.execute_command != ''
                                  execute context.execute_command
                                endif
                            
                                " Check invalidate cache flag.
    2              0.000004     if table.action.is_invalidate_cache
                                  for source_name in table.source_names
                                    call unite#helper#invalidate_cache(source_name)
                                  endfor
                            
                                  let is_redraw = 1
                                endif
    2              0.000001   endfor
                            
    2              0.000007   if (!is_quit || unite.context.no_quit) && unite.context.keep_focus
                                let winnr = bufwinnr(unite.bufnr)
                            
                                if winnr > 0
                                  " Restore focus.
                                  execute winnr 'wincmd w'
                                endif
                              endif
                            
    2              0.000004   if !empty(new_context)
                                " Restore context.
                                let unite.context = old_context
                              endif
                            
    2              0.000031   if is_redraw && !empty(filter(range(1, winnr('$')), "getwinvar(v:val, '&filetype') ==# 'vimfiler'"))
                                " Redraw vimfiler buffer.
                                call vimfiler#force_redraw_all_vimfiler(1)
                              endif
                            
    2              0.000002   if !is_quit && is_redraw
                                call s:clear_marks(candidates)
                                call unite#force_redraw()
                              endif
                            
    2              0.000002   return _

FUNCTION  437()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000018   if str2float(a:ver) < self.version
                                call unite#util#print_error( 'Sorry, the version of MRU file is old.')
                                return 0
                              else
    2              0.000001     return 1
                              endif

FUNCTION  unite#helper#call_hook()
Called 5 times
Total time:   0.007632
 Self time:   0.000415

count  total (s)   self (s)
    5   0.000149   0.000024   let context = unite#get_context()
    5              0.000010   if context.unite__disable_hooks
                                return
                              endif
                            
    5              0.000009   let _ = []
   10              0.000023   for source in a:sources
    5              0.000017     if !has_key(source.hooks, a:hook_name)
    1              0.000001       continue
                                endif
                            
    4              0.000005     try
    4   0.007149   0.000057       call call(source.hooks[a:hook_name], [source.args, source.unite__context], source.hooks)
    4              0.000008     catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error( '[unite.vim] Error occured in calling hook "' . a:hook_name . '"!')
                                  call unite#print_error( '[unite.vim] Source name is ' . source.name)
                                endtry
    4              0.000005   endfor

FUNCTION  unite#handlers#_on_bufwin_enter()
Called 4 times
Total time:   0.000274
 Self time:   0.000143

count  total (s)   self (s)
    4              0.000042   let unite = getbufvar(a:bufnr, 'unite')
    4              0.000036   if type(unite) != type({}) || bufwinnr(a:bufnr) < 1
    3              0.000005     return
                              endif
                            
    1              0.000003   if bufwinnr(a:bufnr) != winnr()
                                let winnr = winnr()
                                execute bufwinnr(a:bufnr) 'wincmd w'
                              endif
                            
    1   0.000025   0.000004   call unite#handlers#_save_updatetime()
                            
    1   0.000011   0.000005   call s:restore_statusline()
                            
    1              0.000003   if !unite.context.no_split && winnr('$') != 1
    1   0.000100   0.000004     call unite#view#_resize_window()
    1              0.000000   endif
                            
    1              0.000003   setlocal nomodified
                            
    1              0.000002   if exists('winnr')
                                execute winnr.'wincmd w'
                              endif
                            
    1   0.000013   0.000005   call unite#init#_tab_variables()
    1              0.000002   let t:unite.last_unite_bufnr = a:bufnr

FUNCTION  71()
Called 32 times
Total time:   0.006709
 Self time:   0.004798

count  total (s)   self (s)
   32              0.000772     let newObj = copy(self)
   32   0.002319   0.000917     let newObj._exe = (a:exe == '' && has_key(a:checker, 'getExec')) ? a:checker.getExec() : a:exe
   32              0.000239     let newObj._args = a:args
   32              0.000218     let newObj._fname = a:fname
   32              0.000235     let newObj._post_args = a:post_args
   32              0.000279     let newObj._tail = a:tail
                            
   32              0.000247     if has_key(a:checker, 'getName')
   32   0.000902   0.000586         let newObj._filetype = a:checker.getFiletype()
   32   0.000640   0.000447         let newObj._subchecker = a:checker.getName()
   32              0.000077     else
                                    let newObj._filetype = &filetype
                                    let newObj._subchecker = ''
                                endif
                            
   32              0.000107     return newObj

FUNCTION  72()
Called 32 times
Total time:   0.017522
 Self time:   0.003521

count  total (s)   self (s)
   32   0.017422   0.003421     return join(filter([self.exe(), self.args(), self.fname(), self.post_args(), self.tail()], '!empty(v:val)'))

FUNCTION  73()
Called 32 times
Total time:   0.004030
 Self time:   0.000508

count  total (s)   self (s)
   32   0.003979   0.000457     return self._getOpt('exe')

FUNCTION  74()
Called 32 times
Total time:   0.002951
 Self time:   0.000429

count  total (s)   self (s)
   32   0.002881   0.000359     return self._getOpt('args')

FUNCTION  75()
Called 32 times
Total time:   0.000879
 Self time:   0.000879

count  total (s)   self (s)
   32              0.000250     if empty(self._fname)
                                    return syntastic#util#shexpand('%')
                                else
   32              0.000133         return self._fname
                                endif

FUNCTION  76()
Called 32 times
Total time:   0.003148
 Self time:   0.000521

count  total (s)   self (s)
   32   0.003034   0.000407     return self._getOpt('post_args')

FUNCTION  77()
Called 32 times
Total time:   0.002993
 Self time:   0.000494

count  total (s)   self (s)
   32   0.002859   0.000360     return self._getOpt('tail')

FUNCTION  78()
Called 128 times
Total time:   0.011170
 Self time:   0.004056

count  total (s)   self (s)
  128   0.008748   0.001634     if self._optExists(a:name)
                                    return {self._optName(a:name)}
                                endif
                            
  128              0.000910     return self['_' . a:name]

FUNCTION  79()
Called 128 times
Total time:   0.007114
 Self time:   0.002463

count  total (s)   self (s)
  128   0.006900   0.002249     return exists(self._optName(a:name))

FUNCTION  unite#sources#mru#_save()
Called 1 time
Total time:   0.010441
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000004   let opts = {}
    1   0.000017   0.000012   if a:0 >= 1 && s:V.is_dict(a:1)
    1              0.000006     call extend(opts, a:1)
    1              0.000001   endif
                            
    3              0.000008   for m in values(s:MRUs)
    2   0.010394   0.000026     call m.save(opts)
    2              0.000002   endfor

FUNCTION  <SNR>122_add_register()
Called 404 times
Total time:   0.015053
 Self time:   0.015053

count  total (s)   self (s)
  404              0.007144   let reg = [getreg(a:name), getregtype(a:name)]
  404              0.004667   if get(s:prev_registers, a:name, []) ==# reg
                                " Skip same register value.
  384              0.000704     return
                              endif
                            
   20              0.000246   let len_history = len(reg[0])
                              " Ignore too long yank.
   20              0.000119   if len_history < 2 || len_history > 100000
    7              0.000012     return
                              endif
                            
   13              0.000107   let s:prev_registers[a:name] = reg
                            
                              " Append register value.
   13              0.000171   call insert(s:yank_histories, reg)

FUNCTION  unite#filters#sorter_rank#define()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006   return s:sorter

FUNCTION  <SNR>49_ExpandMap()
Called 7 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
    7              0.000027   let map = a:map
    7              0.000253   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
    7              0.000018   return map

FUNCTION  unite#kinds#uri#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:kind

FUNCTION  80()
Called 128 times
Total time:   0.004651
 Self time:   0.004651

count  total (s)   self (s)
  128              0.001264     let setting = "g:syntastic_" . self._filetype
  128              0.000837     if !empty(self._subchecker)
  128              0.001061         let setting .= '_' . self._subchecker
  128              0.000276     endif
  128              0.000796     return setting . '_' . a:name

FUNCTION  82()
Called 37 times
Total time:   0.002836
 Self time:   0.002836

count  total (s)   self (s)
   37              0.000508     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = get(g:syntastic_mode_map, 'active_filetypes', [])
                                    let self._passiveFiletypes = get(g:syntastic_mode_map, 'passive_filetypes', [])
                                else
   37              0.000280         let self._mode = 'active'
   37              0.000332         let self._activeFiletypes = []
   37              0.000325         let self._passiveFiletypes = []
   37              0.000081     endif

FUNCTION  83()
Called 36 times
Total time:   0.005333
 Self time:   0.002867

count  total (s)   self (s)
   36              0.001099     let fts = split(a:filetype, '\m\.')
                            
   36   0.001168   0.000529     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
   36   0.002409   0.000582         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  84()
Called 36 times
Total time:   0.000639
 Self time:   0.000639

count  total (s)   self (s)
   36              0.000433     return self._mode ==# 'passive'

FUNCTION  86()
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000058     echo "Syntastic: " . self._mode . " mode enabled"

FUNCTION  88()
Called 36 times
Total time:   0.001827
 Self time:   0.001827

count  total (s)   self (s)
   36              0.001601     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  airline#util#wrap()
Called 48459 times
Total time:   0.405056
 Self time:   0.405056

count  total (s)   self (s)
48459              0.179300   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
48459              0.080002   return a:text

FUNCTION  unite#helper#get_substitute_input_loop()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000011   if empty(a:substitute_patterns)
    1              0.000007     return [a:input]
                              endif
                            
                              let inputs = [a:input]
                              for pattern in a:substitute_patterns
                                let cnt = 0
                                for input in inputs
                                  if input =~ pattern.pattern
                                    if type(pattern.subst) == type([])
                                      if len(inputs) == 1
                                        " List substitute.
                                        let inputs = []
                                        for subst in pattern.subst
                                          call add(inputs, substitute(input, pattern.pattern, subst, 'g'))
                                        endfor
                                      endif
                                    else
                                      let inputs[cnt] = substitute( input, pattern.pattern, pattern.subst, 'g')
                                    endif
                                  endif
                            
                                  let cnt += 1
                                endfor
                              endfor
                            
                              return inputs

FUNCTION  174()
Called 56 times
Total time:   0.003331
 Self time:   0.002327

count  total (s)   self (s)
   56              0.000199     let prependCWD = 0
   56   0.001095   0.000324     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
   56              0.000393         let prependCWD = a:str !~# '^/'
   56              0.000080     endif
                            
   56              0.000178     let toReturn = a:str
   56              0.000112     if prependCWD
    8   0.000447   0.000214         let toReturn = getcwd() . s:Path.Slash() . a:str
    8              0.000017     endif
                            
   56              0.000102     return toReturn

FUNCTION  unite#get_status_string()
Called 19 times
Total time:   0.003996
 Self time:   0.000166

count  total (s)   self (s)
   19   0.003985   0.000155   return unite#view#_get_status_string()

FUNCTION  unite#helper#loaded_source_names_with_args()
Called 19 times
Total time:   0.003462
 Self time:   0.001511

count  total (s)   self (s)
   19   0.003431   0.001480   return map(copy(unite#loaded_sources_list()), " join(insert(filter(copy(v:val.args),  'type(v:val) <= 1'),   unite#helper#convert_source_name(v:val.name)), ':') . (v:val.unite__orig_len_candidates == 0 ? '' :      v:val.unite__orig_len_candidates ==            v:val.unite__len_candidates ?            '(' .  v:val.unite__len_candidates . ')' :      printf('(%s/%s)', v:val.unite__len_candidates,      v:val.unite__orig_len_candidates)) ")

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 4752 times
Total time:   1.020676
 Self time:   0.066932

count  total (s)   self (s)
 4752   1.016800   0.063056   return airline#extensions#tabline#formatters#{s:formatter}(a:nr, get(s:, 'current_buffer_list', []))

FUNCTION  sy#start()
Called 39 times
Total time:   0.468890
 Self time:   0.010394

count  total (s)   self (s)
   39              0.000253   if g:signify_locked
                                return
                              endif
                            
   39              0.002017   if &diff || !filereadable(a:path) || (exists('g:signify_skip_filetype') && has_key(g:signify_skip_filetype, &ft)) || (exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path))
                                return
                              endif
                            
                              " new buffer.. add to list of registered files
   39              0.000646   if !exists('b:sy') || b:sy.path != a:path
    4              0.000069     let b:sy = { 'path': a:path, 'buffer': bufnr(''), 'active': 0, 'type': 'unknown', 'hunks': [], 'id_top': g:id_top, 'stats': [-1, -1, -1] }
    4              0.000020     if get(g:, 'signify_disable_by_default')
                                  return
                                endif
                            
                                " register buffer as active
    4              0.000014     let b:sy.active = 1
                            
    4   0.044873   0.000107     let [ diff, b:sy.type ] = sy#repo#detect()
    4              0.000032     if b:sy.type == 'unknown'
    4              0.000007       return
                                endif
                            
                                " register file as active with found VCS
                                let b:sy.stats = [0, 0, 0]
                            
                                let dir = fnamemodify(b:sy.path, ':h')
                                if !has_key(g:sy_cache, dir)
                                  let g:sy_cache[dir] = b:sy.type
                                endif
                            
                                if empty(diff)
                                  " no changes found
                                  return
                                endif
                            
                              " inactive buffer.. bail out
                              elseif !b:sy.active
                                return
                            
                              " retry detecting VCS
                              elseif b:sy.type == 'unknown'
   35   0.415254   0.001524     let [ diff, b:sy.type ] = sy#repo#detect()
   35              0.000395     if b:sy.type == 'unknown'
                                  " no VCS found
   35              0.000105       return
                                endif
                            
                              " update signs
                              else
                                let diff = sy#repo#get_diff_{b:sy.type}()[1]
                                if empty(diff)
                                  call sy#sign#remove_all(b:sy.buffer)
                                  return
                                endif
                                let b:sy.id_top = g:id_top
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                  call sy#highlight#line_enable()
                              else
                                  call sy#highlight#line_disable()
                              endif
                            
                              execute 'sign place 99999 line=1 name=SignifyPlaceholder buffer='. b:sy.buffer
                              call sy#sign#remove_all(b:sy.buffer)
                            
                              if !g:signify_sign_overwrite
                                call sy#sign#get_others()
                              endif
                            
                              call sy#repo#process_diff(diff)
                              sign unplace 99999
                            
                              let b:sy.id_top = (g:id_top - 1)

FUNCTION  syntastic#log#debugShowVariables()
Called 37 times
Total time:   0.000916
 Self time:   0.000600

count  total (s)   self (s)
   37   0.000747   0.000431     if !s:isDebugEnabled(a:level)
   37              0.000069         return
                                endif
                            
                                let leader = s:logTimestamp()
                                call s:logRedirect(1)
                            
                                let vlist = type(a:names) == type("") ? [a:names] : a:names
                                for name in vlist
                                    echomsg leader . s:formatVariable(name)
                                endfor
                            
                                call s:logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 2376 times
Total time:   6.734259
 Self time:   0.068763

count  total (s)   self (s)
 2376              0.026340   if s:show_buffers && tabpagenr('$') == 1
                                return s:get_buffers()
                              else
 2376   6.685355   0.019859     return s:get_tabs()
                              endif

FUNCTION  90()
Called 53 times
Total time:   0.795147
 Self time:   0.013316

count  total (s)   self (s)
   53   0.001855   0.000699     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
  318              0.000840     for type in self._enabled_types
  265              0.003988         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
  265   0.006899   0.003979         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
  212   0.779748   0.001993             call self._notifier[type].refresh(a:loclist)
  212              0.000189         endif
  265              0.000245     endfor

FUNCTION  96()
Called 38 times
Total time:   0.017181
 Self time:   0.003786

count  total (s)   self (s)
   38   0.002754   0.000863     let filetype = s:SyntasticRegistryNormaliseFiletype(a:ftalias)
   38   0.002766   0.000745     let checkers = self.availableCheckersFor(a:ftalias)
                            
   38   0.002816   0.000629     if self._userHasFiletypeSettings(filetype)
                                    return self._filterCheckersByUserSettings(checkers, filetype)
                                endif
                            
   38              0.000325     if has_key(s:defaultCheckers, filetype)
   38   0.007823   0.000527         return self._filterCheckersByDefaultSettings(checkers, filetype)
                                endif
                            
                                return checkers[0:0]

FUNCTION  98()
Called 39 times
Total time:   0.002089
 Self time:   0.002089

count  total (s)   self (s)
   39              0.000488     if !has_key(self._cachedCheckersFor, a:ftalias)
                                    let filetype = s:SyntasticRegistryNormaliseFiletype(a:ftalias)
                                    let checkers = self._allCheckersFor(filetype)
                                    let self._cachedCheckersFor[a:ftalias] = self._filterCheckersByAvailability(checkers)
                                endif
                            
   39              0.000261     return self._cachedCheckersFor[a:ftalias]

FUNCTION  99()
Called 1 time
Total time:   0.001179
 Self time:   0.000370

count  total (s)   self (s)
    1              0.000051     echomsg "Syntastic info for filetype: " . join(a:ftalias_list, '.')
                            
    1              0.000014     let available = []
    1              0.000006     let active = []
    2              0.000014     for ftalias in a:ftalias_list
    1   0.000118   0.000050         call extend(available, self.availableCheckersFor(ftalias))
    1   0.000546   0.000030         call extend(active, self.getActiveCheckers(ftalias))
    1              0.000003     endfor
                            
    1   0.000235   0.000098     echomsg "Available checker(s): " . join(syntastic#util#unique(map(available, "v:val.getName()")))
    1   0.000160   0.000072     echomsg "Currently enabled checker(s): " . join(syntastic#util#unique(map(active, "v:val.getName()")))

FUNCTION  <SNR>81_SkipFile()
Called 74 times
Total time:   0.012550
 Self time:   0.006497

count  total (s)   self (s)
   74              0.001505     let force_skip = exists('b:syntastic_skip_checks') ? b:syntastic_skip_checks : 0
   74              0.000828     let fname = expand('%')
   74   0.009705   0.003652     return force_skip || !empty(&buftype) || !filereadable(fname) || getwinvar(0, '&diff') || s:IgnoreFile(fname)

FUNCTION  unite#set_context()
Called 1 time
Total time:   0.000057
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000033   0.000006   let old_context = unite#get_context()
                            
    1              0.000003   if exists('b:unite') && !unite#variables#use_current_unite()
                                let b:unite.context = a:context
                              else
    1   0.000011   0.000005     let current_unite = unite#variables#current_unite()
    1              0.000002     let current_unite.context = a:context
    1              0.000001   endif
                            
    1              0.000001   return old_context

FUNCTION  nerdtree#indentLevelFor()
Called 186 times
Total time:   0.009061
 Self time:   0.008398

count  total (s)   self (s)
  186   0.004667   0.004004     let level = match(a:line, '[^ \-+~`|]') / nerdtree#treeWid()
                                " check if line includes arrows
  186              0.001887     if match(a:line, '[]') > -1
                                    " decrement level as arrow uses 3 ascii chars
  162              0.000872         let level = level - 1
  162              0.000258     endif
  186              0.000385     return level

FUNCTION  184()
Called 90 times
Total time:   0.000655
 Self time:   0.000655

count  total (s)   self (s)
   90              0.000181     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
   90              0.000132     return self.cachedDisplayString

FUNCTION  unite#variables#static()
Called 64 times
Total time:   0.001005
 Self time:   0.001005

count  total (s)   self (s)
   64              0.000261   if !exists('s:static')
    1              0.000002     let s:static = {}
    1              0.000002     let s:static.sources = {}
    1              0.000002     let s:static.kinds = {}
    1              0.000002     let s:static.filters = {}
    1              0.000001   endif
                            
   64              0.000119   return s:static

FUNCTION  vimproc#get_command_name()
Called 1 time
Total time:   0.001729
 Self time:   0.000458

count  total (s)   self (s)
    1              0.000004   let path = get(a:000, 0, $PATH)
                            
    1              0.000002   let cnt = a:0 < 2 ? 1 : a:2
                            
    1   0.001704   0.000433   let files = split(substitute(vimproc#util#substitute_path_separator( vimproc#filepath#which(a:command, path)), '//', '/', 'g'), '\n')
                            
    1              0.000002   if cnt < 0
                                return files
                              endif
                            
    1              0.000005   let file = get(files, cnt-1, '')
                            
    1              0.000002   if file == ''
                                throw printf( 'vimproc#get_command_name: File "%s" is not found.', a:command)
                              endif
                            
    1              0.000001   return file

FUNCTION  airline#util#getwinvar()
Called 1294 times
Total time:   0.020229
 Self time:   0.020229

count  total (s)   self (s)
 1294              0.009841     let winvals = getwinvar(a:winnr, '')
 1294              0.008523     return get(winvals, a:key, a:def)

FUNCTION  <SNR>196_parse_single_quote()
Called 1 time
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    1              0.000003   if a:script[a:i] != "'"
                                return ['', a:i]
                              endif
                            
    1              0.000002   let arg = ''
    1              0.000002   let i = a:i + 1
    1              0.000003   let max = len(a:script)
   15              0.000014   while i < max
   15              0.000030     if a:script[i] == "'"
    1              0.000003       if i+1 < max && a:script[i+1] == "'"
                                    " Escape quote.
                                    let arg .= "'"
                                    let i += 2
                                  else
                                    " Quote end.
    1              0.000002         return [arg, i+1]
                                  endif
                                else
   14              0.000038       let arg .= a:script[i]
   14              0.000018       let i += 1
   14              0.000008     endif
   14              0.000010   endwhile
                            
                              throw 'Exception: Quote ('') is not found.'

FUNCTION  unite#filters#sorter_default#get()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   return s:default_sorters

FUNCTION  <SNR>81_CurrentFiletypes()
Called 75 times
Total time:   0.001858
 Self time:   0.001858

count  total (s)   self (s)
   75              0.001709     return split( get(g:syntastic_filetype_map, &filetype, &filetype), '\m\.' )

FUNCTION  airline#extensions#whitespace#check()
Called 5477 times
Total time:   0.393687
 Self time:   0.393687

count  total (s)   self (s)
 5477              0.022537   if &readonly || !&modifiable || !s:enabled
                                return ''
                              endif
                            
 5477              0.026609   if !exists('b:airline_whitespace_check')
  126              0.000932     let b:airline_whitespace_check = ''
  126              0.001401     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
  126              0.000506     let trailing = 0
  126              0.000912     if index(checks, 'trailing') > -1
  126              0.013790       let trailing = search(' $', 'nw')
  126              0.000293     endif
                            
  126              0.000523     let mixed = 0
  126              0.000731     if index(checks, 'indent') > -1
  126              0.008331       let indents = [search('^ \{2,}', 'nb'), search('^ \{2,}', 'n'), search('^\t', 'nb'), search('^\t', 'n')]
  126              0.001740       let mixed = indents[0] != 0 && indents[1] != 0 && indents[2] != 0 && indents[3] != 0
  126              0.000260     endif
                            
  126              0.000484     if trailing != 0 || mixed
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed
                                      let mixnr = indents[0] == indents[1] ? indents[0] : indents[2]
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixnr)
                                    endif
                                  endif
                                endif
  126              0.000201   endif
 5477              0.014362   return b:airline_whitespace_check

FUNCTION  281()
Called 2 times
Total time:   0.000339
 Self time:   0.000313

count  total (s)   self (s)
    2   0.000048   0.000022     if nerdtree#treeExistsForTab()
    2              0.000284         return getbufvar(t:NERDTreeBufName, 'NERDTreeRoot')
                                end
                                return {}

FUNCTION  airline#extensions#tabline#title()
Called 4752 times
Total time:   1.119571
 Self time:   0.098895

count  total (s)   self (s)
 4752              0.028800   let buflist = tabpagebuflist(a:n)
 4752              0.020264   let winnr = tabpagewinnr(a:n)
 4752   1.064015   0.043339   return airline#extensions#tabline#get_buffer_name(buflist[winnr - 1])

FUNCTION  <SNR>109_get_array()
Called 35122 times
Total time:   0.552546
 Self time:   0.552546

count  total (s)   self (s)
35122              0.095846   let fg = a:fg
35122              0.071598   let bg = a:bg
35122              0.343252   return has('gui_running') ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  unite#util#set_default()
Called 33 times
Total time:   0.000636
 Self time:   0.000636

count  total (s)   self (s)
   33              0.000183   if !exists(a:var) || type({a:var}) != type(a:val)
   33              0.000135     let alternate_var = get(a:000, 0, '')
                            
   33              0.000241     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
   33              0.000031   endif

FUNCTION  unite#handlers#_on_cursor_moved_i()
Called 1 time
Total time:   0.000402
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000025   0.000006   let unite = unite#get_current_unite()
    1              0.000004   let prompt_linenr = unite.prompt_linenr
                            
    1              0.000002   if unite.max_source_candidates <= unite.redraw_hold_candidates
    1   0.000359   0.000006     call s:check_redraw()
    1              0.000000   endif
                            
                              " Prompt check.
    1              0.000005   if line('.') == prompt_linenr && col('.') <= len(unite.prompt)
                                startinsert!
                              endif

FUNCTION  192()
Called 1 time
Total time:   0.000024
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000024   0.000009     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  194()
Called 90 times
Total time:   0.014723
 Self time:   0.004936

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   90              0.000200     if b:NERDTreeIgnoreEnabled
  270              0.000510         for i in g:NERDTreeIgnore
  180   0.010762   0.000975             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
  180              0.000186         endfor
   90              0.000069     endif
                            
                                "dont show hidden files unless instructed to
   90              0.000328     if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
   90              0.000269     if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
   90              0.000478     if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
                                    return 1
                                endif
                            
   90              0.000087     return 0

FUNCTION  196()
Called 6 times
Total time:   0.001854
 Self time:   0.000169

count  total (s)   self (s)
    6              0.000016     if a:path.isDirectory == 0
                                    return 0
                                endif
                            
    6   0.000872   0.000038     let this = self.str()
    6   0.000803   0.000039     let that = a:path.str()
    6   0.000137   0.000050     return stridx(this, that . s:Path.Slash()) == 0

FUNCTION  airline#extensions#tagbar#currenttag()
Called 7697 times
Total time:   0.382976
 Self time:   0.096719

count  total (s)   self (s)
 7697              0.034088   if get(w:, 'airline_active', 0)
 5469   0.329880   0.043623     return tagbar#currenttag('%s', '', s:flags)
                              endif
 2228              0.002112   return ''

FUNCTION  198()
Called 181 times
Total time:   0.045822
 Self time:   0.001640

count  total (s)   self (s)
  181   0.045736   0.001554     return self.str() ==# a:path.str()

FUNCTION  199()
Called 56 times
Total time:   0.025703
 Self time:   0.002817

count  total (s)   self (s)
   56              0.001545     let newPath = copy(self)
                            
   56  18.078042  18.055156     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
   48              0.000261     let newPath.cachedDisplayString = ""
                            
   48              0.000086     return newPath

FUNCTION  nerdtree#invokeKeyMap()
Called 17 times
Total time:   0.415167
 Self time:   0.000481

count  total (s)   self (s)
   17   0.415113   0.000427     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  unite#print_source_message()
Called 2 times
Total time:   0.022688
 Self time:   0.000551

count  total (s)   self (s)
    2   0.022686   0.000549   return unite#view#_print_source_message(a:message, a:source_name)

FUNCTION  unite#view#_quit()
Called 3 times
Total time:   0.115916
 Self time:   0.090098

count  total (s)   self (s)
    3              0.000011   if &filetype !=# 'unite'
                                return
                              endif
                            
    3              0.000013   let is_all = get(a:000, 0, 0)
                            
                              " Save unite value.
    3   0.000049   0.000020   let unite_save = unite#variables#current_unite()
    3   0.000044   0.000016   call unite#set_current_unite(b:unite)
    3              0.000007   let unite = b:unite
    3              0.000007   let context = unite.context
                            
    3   0.000169   0.000016   let key = unite#loaded_source_names_string()
                            
                              " Clear mark.
    6   0.000106   0.000023   for source in unite#loaded_sources_list()
    6              0.000014     for candidate in source.unite__cached_candidates
    3              0.000010       let candidate.unite__is_marked = 0
    3              0.000004     endfor
    3              0.000002   endfor
                            
                              " Save position.
    3   0.000150   0.000026   let positions = unite#custom#get_profile( unite.profile_name, 'unite__save_pos')
    3              0.000005   if key != ''
    3   0.000178   0.000035     let positions[key] = { 'pos' : getpos('.'), 'candidate' : unite#helper#get_current_candidate(), }
                            
    3              0.000007     if context.input != ''
                                  " Save input.
                                  let inputs = unite#custom#get_profile( unite.profile_name, 'unite__inputs')
                                  if !has_key(inputs, key)
                                    let inputs[key] = []
                                  endif
                                  call insert(filter(inputs[key], 'v:val !=# unite.context.input'), context.input)
                                endif
    3              0.000003   endif
                            
    3              0.000007   if a:is_force || !context.no_quit
    1              0.000006     let bufname = bufname('%')
                            
    1              0.000004     if winnr('$') == 1 || context.no_split
                                  call unite#util#alternate_buffer()
                                elseif is_all || !context.temporary
    1   0.009975   0.000068       close!
    1              0.000005       if unite.winnr != winnr()
                                    execute unite.winnr . 'wincmd w'
                                  endif
    1   0.000018   0.000009       call unite#view#_resize_window()
    1              0.000002     endif
                            
    1   0.000336   0.000008     call unite#handlers#_on_buf_unload(bufname)
                            
    1              0.000002     if !unite.has_preview_window
    1              0.000019       let preview_windows = filter(range(1, winnr('$')), 'getwinvar(v:val, "&previewwindow") != 0')
    1              0.000004       if !empty(preview_windows)
                                    " Close preview window.
                                    noautocmd pclose!
                            
                                  endif
    1              0.000001     endif
                            
    1   0.000064   0.000014     call s:clear_previewed_buffer_list()
                            
    1              0.000005     if winnr('$') != 1 && !unite.context.temporary
                                  execute unite.win_rest_cmd
                                  execute unite.prev_winnr 'wincmd w'
                                endif
    1              0.000001   else
                                " Note: Except preview window.
    2              0.000039     let winnr = get(filter(range(1, winnr('$')), "winbufnr(v:val) == unite.prev_bufnr &&  !getwinvar(v:val, '&previewwindow')"), 0, unite.prev_winnr)
                            
    2              0.000004     if winnr == winnr()
                                  new
                                else
    2   0.014950   0.000027       execute winnr 'wincmd w'
    2              0.000002     endif
    2              0.000007     let unite.prev_winnr = winnr()
    2              0.000001   endif
                            
    3              0.000005   if context.complete
                                if context.col < col('$')
                                  startinsert
                                else
                                  startinsert!
                                endif
                            
                                " Skip next auto completion.
                                if exists('*neocomplcache#skip_next_complete')
                                  call neocomplcache#skip_next_complete()
                                endif
                              else
    3              0.089282     redraw
    3              0.000008     stopinsert
    3              0.000003   endif
                            
                              " Restore unite.
    3   0.000078   0.000037   call unite#set_current_unite(unite_save)

FUNCTION  AutoPairsInit()
Called 7 times
Total time:   0.007348
 Self time:   0.004003

count  total (s)   self (s)
    7              0.000043   let b:autopairs_loaded  = 1
    7              0.000026   let b:autopairs_enabled = 1
    7              0.000026   let b:AutoPairsClosedPairs = {}
                            
    7              0.000034   if !exists('b:AutoPairs')
    7              0.000036     let b:AutoPairs = g:AutoPairs
    7              0.000007   end
                            
                              " buffer level map pairs keys
   49              0.000214   for [open, close] in items(b:AutoPairs)
   42   0.002452   0.000281     call AutoPairsMap(open)
   42              0.000137     if open != close
   21   0.001316   0.000142       call AutoPairsMap(close)
   21              0.000031     end
   42              0.000249     let b:AutoPairsClosedPairs[close] = open
   42              0.000064   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    7              0.000018   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    7              0.000206     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    7              0.000182     execute 'inoremap <buffer> <silent> <C-H> <C-R>=AutoPairsDelete()<CR>'
    7              0.000008   end
                            
    7              0.000019   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    7              0.000027     let do_abbrev = ""
    7              0.000072     if v:version == 703 && has("patch489") || v:version > 703
    7              0.000026       let do_abbrev = "<C-]>"
    7              0.000010     endif
    7              0.000219     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    7              0.000008   end
                            
    7              0.000027   if g:AutoPairsShortcutFastWrap != ''
    7              0.000224     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    7              0.000010   end
                            
    7              0.000030   if g:AutoPairsShortcutBackInsert != ''
    7              0.000239     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    7              0.000012   end
                            
    7              0.000031   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    7              0.000224     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    7              0.000260     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    7              0.000010   end
                            
    7              0.000024   if g:AutoPairsShortcutJump != ''
    7              0.000218     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    7              0.000218     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    7              0.000008   end
                            

FUNCTION  <SNR>108_create()
Called 14 times
Total time:   0.002346
 Self time:   0.002031

count  total (s)   self (s)
   14              0.000029   let _ = ''
   28              0.000076   for idx in range(len(a:parts))
   14   0.000149   0.000089     let part = airline#parts#get(a:parts[idx])
   14              0.000026     let val = ''
                            
   14              0.000041     if exists('part.function')
   14              0.000038       let func = (part.function).'()'
   14              0.000021     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let val = s:spc.g:airline_right_alt_sep.s:spc.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
   14              0.000051     let minwidth = get(part, 'minwidth', 0)
                            
   14              0.000028     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                else
   14              0.000084       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
   14              0.000012     endif
                            
   14              0.000034     if exists('part.condition')
                                  let partval = substitute(partval, '{', '{'.(part.condition).' ? ', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
   14   0.000358   0.000103     let val .= s:wrap_accent(part, partval)
   14              0.000061     let _ .= val
   14              0.000014   endfor
   14              0.000017   return _

FUNCTION  vimproc#version()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000013   return str2nr(printf('%2d%02d', 7, 1))

FUNCTION  212()
Called 2 times
Total time:   0.000527
 Self time:   0.000292

count  total (s)   self (s)
    2   0.000247   0.000012     let str = self.str()
    6              0.000016     for t in range(tabpagenr('$'))
   13              0.000033         for b in tabpagebuflist(t+1)
    9              0.000150             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    9              0.000009         endfor
    4              0.000003     endfor
    2              0.000002     return 0

FUNCTION  <SNR>197_is_case_tolerant()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:is_case_tolerant

FUNCTION  unite#handlers#_on_insert_leave()
Called 1 time
Total time:   0.000040
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000018   0.000005   let unite = unite#get_current_unite()
                            
    1              0.000004   if line('.') != unite.prompt_linenr
                                normal! 0
                              endif
                            
    1              0.000003   let unite.is_insert = 0
                            
    1              0.000003   if &filetype ==# 'unite'
    1              0.000005     setlocal nomodifiable
    1              0.000000   endif

FUNCTION  sy#repo#get_diff_git()
Called 39 times
Total time:   0.450754
 Self time:   0.013798

count  total (s)   self (s)
   39              0.000786   let diffoptions = has_key(g:signify_diffoptions, 'git') ? g:signify_diffoptions.git : ''
   39   0.447746   0.010790   let diff = system('cd '. sy#util#escape(fnamemodify(b:sy.path, ':h')) .' && git diff --no-color --no-ext-diff -U0 '. diffoptions .' -- '. sy#util#escape(fnamemodify(b:sy.path, ':t')))
                            
   39              0.001350   return v:shell_error ? [0, ''] : [1, diff]

FUNCTION  unite#get_source_variables()
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000011   return a:context.source.variables

FUNCTION  <SNR>55_chop()
Called 5 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    5              0.000082 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    5              0.000012 	retu a:mrufs

FUNCTION  unite#variables#sources()
Called 20 times
Total time:   0.001419
 Self time:   0.000585

count  total (s)   self (s)
   20   0.000471   0.000142   let unite = unite#get_current_unite()
   20              0.000078   if !has_key(unite, 'sources')
                                return {}
                              endif
                            
   20              0.000035   if a:0 == 0
                                return unite.sources
                              endif
                            
   20   0.000678   0.000173   return unite#util#get_name(unite.sources, a:1, {})

FUNCTION  <SNR>191_convert_args()
Called 1 time
Total time:   0.001791
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   if empty(a:args)
                                return []
                              endif
                            
    1   0.000006   0.000004   if vimproc#util#is_windows() && !executable(a:args[0])
                                " Search from internal commands.
                                let internal_commands = [ 'copy', 'dir', 'echo', 'erase', 'ftype', 'md', 'mkdir', 'move', 'path', 'rd', 'ren', 'rename', 'rmdir', 'start', 'time', 'type', 'ver', 'vol']
                                let index = index(internal_commands, a:args[0])
                                if index >= 0
                                  " Use cmd.exe
                                  return ['cmd', '/c', internal_commands[index]] + a:args[1:]
                                endif
                              endif
                            
    1   0.001737   0.000008   let command_name = vimproc#get_command_name(a:args[0])
                            
    1   0.000031   0.000013   return vimproc#analyze_shebang(command_name) + a:args[1:]

FUNCTION  <SNR>187_substitute_path_separator()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000015   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  fugitive#extract_git_dir()
Called 5474 times
Total time:   4.233674
 Self time:   2.762630

count  total (s)   self (s)
 5474   0.151048   0.082477   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
 5474   0.286647   0.214868   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
 5474              0.016212   let previous = ""
38327              0.105749   while root !=# previous
32853   0.653149   0.277080     let dir = s:sub(root, '[\/]$', '') . '/.git'
32853              0.201014     let type = getftype(dir)
32853              0.122502     if type ==# 'dir' && fugitive#is_git_dir(dir)
                                  return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
32853              0.091078     let previous = root
32853              0.158676     let root = fnamemodify(root, ':h')
32853              0.074951   endwhile
 5474              0.006799   return ''

FUNCTION  AutoPairsReturn()
Called 54 times
Total time:   0.007597
 Self time:   0.007597

count  total (s)   self (s)
   54              0.000398   if b:autopairs_enabled == 0
                                return ''
                              end
   54              0.000521   let line = getline('.')
   54              0.000742   let pline = getline(line('.')-1)
   54              0.000762   let prev_char = pline[strlen(pline)-1]
   54              0.000285   let cmd = ''
   54              0.000617   let cur_char = line[col('.')-1]
   54              0.000778   if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
    5              0.000058     if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Use \<BS> instead of \<ESC>cl will cause the placeholder deleted
                                  " incorrect. because <C-O>zz won't leave Normal mode.
                                  " Use \<DEL> is a bit wierd. the character before cursor need to be deleted.
    1              0.000013       let cmd = " \<C-O>zz\<ESC>cl"
    1              0.000003     end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
    5              0.000026     if &equalprg != ''
                                  return "\<ESC>O".cmd
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
    5              0.000034     if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>k==o".cmd
                                else
    5              0.000044       return "\<ESC>=ko".cmd
                                endif
                              end
   49              0.000130   return ''

FUNCTION  unite#sources#mru#variables#append()
Called 72 times
Total time:   0.020806
 Self time:   0.016241

count  total (s)   self (s)
   72              0.000800   if &l:buftype =~ 'help\|nofile'
    8              0.000012     return
                              endif
                            
   64   0.002610   0.002027   let path = s:substitute_path_separator(expand('%:p'))
   64              0.001628   if path !~ '\a\+:'
   64   0.002859   0.002360     let path = s:substitute_path_separator( simplify(resolve(path)))
   64              0.000093   endif
                            
                              " Append the current buffer to the mru list.
   64   0.001535   0.000470   if s:is_file_exist(path)
   57   0.002044   0.001123     call insert(s:mru_files, s:convert2dictionary([path, localtime()]))
   57              0.000092   endif
                            
   64              0.000570   let filetype = getbufvar(bufnr('%'), '&filetype')
   64              0.000458   if filetype ==# 'vimfiler' && type(getbufvar(bufnr('%'), 'vimfiler')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimfiler').current_dir
                              elseif filetype ==# 'vimshell' && type(getbufvar(bufnr('%'), 'vimshell')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimshell').current_dir
                              else
   64              0.000484     let path = getcwd()
   64              0.000082   endif
                            
   64   0.001927   0.001489   let path = s:substitute_path_separator(simplify(resolve(path)))
                              " Chomp last /.
   64              0.000753   let path = substitute(path, '/$', '', '')
                            
                              " Append the current buffer to the mru list.
   64              0.000421   if isdirectory(path)
   64   0.002176   0.001117     call insert(s:mru_directories, s:convert2dictionary([path, localtime()]))
   64              0.000104   endif

FUNCTION  <SNR>107_get_tabs()
Called 2376 times
Total time:   6.665496
 Self time:   0.585509

count  total (s)   self (s)
 2376   0.150221   0.023814   let b = airline#builder#new(s:builder_context)
 7128              0.027770   for i in range(1, tabpagenr('$'))
 4752              0.015341     if i == tabpagenr()
 2376              0.006983       let group = 'airline_tabsel'
 2376              0.005833       if g:airline_detect_modified
 7002              0.017939         for bi in tabpagebuflist(i)
 4626              0.023798           if getbufvar(bi, '&modified')
 2064              0.005686             let group = 'airline_tabmod'
 2064              0.002291           endif
 4626              0.004915         endfor
 2376              0.002215       endif
 2376              0.002461     else
 2376              0.007125       let group = 'airline_tab'
 2376              0.002595     endif
 4752              0.011086     let val = '%('
 4752              0.011924     if s:tab_nr_type == 0
 4752              0.031232       let val .= ' %{len(tabpagebuflist('.i.'))}'
 4752              0.005503     else
                                  let val .= (g:airline_symbols.space).i
                                endif
 4752   1.875693   0.066323     call b.add_section(group, val.'%'.i.'T %{airline#extensions#tabline#title('.i.')} %)')
 4752              0.008607   endfor
 2376   0.036486   0.023392   call b.add_raw('%T')
 2376   1.375270   0.015645   call b.add_section('airline_tabfill', '')
 2376   0.042988   0.017510   call b.split()
 2376   1.395785   0.016987   call b.add_section('airline_tab', ' %999XX ')
 2376   1.363497   0.022153   call b.add_section('airline_tabtype', ' tabs ')
 2376   0.044358   0.018487   return b.build()

FUNCTION  <SNR>186__redir()
Called 20 times
Total time:   0.012940
 Self time:   0.012940

count  total (s)   self (s)
   20              0.000126   let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
   20              0.000138   set verbose=0 verbosefile=
   20              0.000070   redir => res
   20              0.011981     silent! execute a:cmd
   20              0.000281   redir END
   20              0.000171   let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
   20              0.000117   return res

FUNCTION  unite#loaded_sources_list()
Called 28 times
Total time:   0.001248
 Self time:   0.000228

count  total (s)   self (s)
   28   0.001225   0.000205   return unite#variables#loaded_sources()

FUNCTION  unite#get_sources()
Called 20 times
Total time:   0.001600
 Self time:   0.000181

count  total (s)   self (s)
   20   0.001586   0.000167   return call('unite#variables#sources', a:000)

FUNCTION  unite#util#strwidthpart()
Called 1 time
Total time:   0.000051
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000051   0.000012   return call(unite#util#get_vital().strwidthpart, a:000)

FUNCTION  nerdtree#treeWid()
Called 186 times
Total time:   0.000663
 Self time:   0.000663

count  total (s)   self (s)
  186              0.000462     return 2

FUNCTION  <SNR>81_BufReadPostHook()
Called 3 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000015     if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufReadPost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
                                    call s:UpdateErrors(1)
                                endif

FUNCTION  <SNR>81_BufWinEnterHook()
Called 19 times
Total time:   0.074847
 Self time:   0.000673

count  total (s)   self (s)
   19   0.000553   0.000336     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufWinEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
   19              0.000055     if empty(&buftype)
   16   0.000656   0.000115         let loclist = g:SyntasticLoclist.current()
   16   0.073518   0.000102         call s:notifiers.refresh(loclist)
   16              0.000013     endif

FUNCTION  nerdtree#centerView()
Called 5 times
Total time:   0.000362
 Self time:   0.000149

count  total (s)   self (s)
    5              0.000011     if g:NERDTreeAutoCenter
    5              0.000030         let current_line = winline()
    5              0.000011         let lines_to_top = current_line
    5   0.000256   0.000043         let lines_to_bottom = winheight(nerdtree#getTreeWinNum()) - current_line
    5              0.000027         if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                        normal! zz
                                    endif
    5              0.000003     endif

FUNCTION  neosnippet#commands#_make_cache()
Called 42 times
Total time:   0.005789
 Self time:   0.004114

count  total (s)   self (s)
   42   0.001115   0.000422   call neosnippet#init#check()
                            
   42              0.000414   let filetype = a:filetype == '' ? &filetype : a:filetype
   42              0.000166   if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
   42   0.001279   0.000519   let snippets = neosnippet#variables#snippets()
   42              0.000332   if has_key(snippets, filetype)
   39              0.000084     return
                              endif
                            
    3   0.000218   0.000018   let snippets_dir = neosnippet#helpers#get_snippets_directory()
    3              0.000006   let snippet = {}
    3              0.001581   let snippets_files =   split(globpath(join(snippets_dir, ','),   filetype .  '.snip*'), '\n') + split(globpath(join(snippets_dir, ','),   filetype .  '_*.snip*'), '\n') + split(globpath(join(snippets_dir, ','),   filetype .  '/**/*.snip*'), '\n')
    3              0.000020   for snippets_file in reverse(snippets_files)
                                call neosnippet#parser#_parse(snippet, snippets_file)
                              endfor
                            
    3   0.000039   0.000017   let snippets = neosnippet#variables#snippets()
    3              0.000009   let snippets[filetype] = snippet

FUNCTION  <SNR>97_sync_active_winnr()
Called 404 times
Total time:   0.020103
 Self time:   0.008103

count  total (s)   self (s)
  404              0.004816   if exists('#airline') && winnr() != s:active_winnr
    1   0.012013   0.000013     call airline#update_statusline()
    1              0.000002   endif

FUNCTION  <SNR>196_parse_cmdline()
Called 1 time
Total time:   0.001260
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003   let cmdline = a:cmdline
                            
                              " Expand block.
    1              0.000004   if cmdline =~ '{'
                                let cmdline = s:parse_block(cmdline)
                              endif
                            
                              " Expand tilde.
    1              0.000002   if cmdline =~ '\~'
                                let cmdline = s:parse_tilde(cmdline)
                              endif
                            
                              " Expand filename.
    1              0.000004   if cmdline =~ ' ='
                                let cmdline = s:parse_equal(cmdline)
                              endif
                            
                              " Expand variables.
    1              0.000003   if cmdline =~ '\$'
                                let cmdline = s:parse_variables(cmdline)
                              endif
                            
                              " Expand wildcard.
    1              0.000012   if cmdline =~ '[[*?]\|\\[()|]'
                                let cmdline = s:parse_wildcard(cmdline)
                              endif
                            
    1   0.001211   0.000007   return s:parse_tilde(cmdline)

FUNCTION  unite#helper#call_filter()
Called 3 times
Total time:   0.009740
 Self time:   0.000099

count  total (s)   self (s)
    3   0.003287   0.000027   let filter = unite#get_filters(a:filter_name)
    3              0.000012   if empty(filter)
                                return a:candidates
                              endif
                            
    3   0.006424   0.000043   return filter.filter(a:candidates, a:context)

FUNCTION  neobundle#autoload#function()
Called 24 times
Total time:   0.012126
 Self time:   0.006014

count  total (s)   self (s)
   24              0.000212   let function = expand('<amatch>')
   24              0.000378   let function_prefix = get(split(function, '#'), 0, '') . '#'
                            
   24   0.010904   0.005086   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'function_prefix', '').'#' ==# function_prefix ||  (has_key(v:val.autoload, 'functions') &&    index(neobundle#util#convert2list(     v:val.autoload.functions), function) >= 0)")
   24   0.000543   0.000249   call neobundle#config#source_bundles(bundles)

FUNCTION  <SNR>81_OSSupportsShellredirHack()
Called 32 times
Total time:   0.003412
 Self time:   0.001963

count  total (s)   self (s)
   32   0.003301   0.001852     return !s:running_windows && executable('/bin/bash') && (s:uname() !~ "FreeBSD") && (s:uname() !~ "OpenBSD")

FUNCTION  <SNR>186__get_functions()
Called 5 times
Total time:   0.032348
 Self time:   0.026819

count  total (s)   self (s)
    5              0.000021     let prefix = '<SNR>' . a:sid . '_'
    5   0.005565   0.000036     let funcs = s:_redir('function')
    5              0.000019     let filter_pat = '^\s*function ' . prefix
    5              0.000014     let map_pat = prefix . '\zs\w\+'
    5              0.026721     return map(filter(split(funcs, "\n"),          'stridx(v:val, prefix) > 0 && v:val =~# filter_pat'),          'matchstr(v:val, map_pat)')

FUNCTION  424()
Called 2 times
Total time:   0.000703
 Self time:   0.000110

count  total (s)   self (s)
    4              0.000009     for candidate in a:candidates
    2   0.000199   0.000012       let bufnr = s:open(candidate)
    2   0.000189   0.000018       call s:jump(candidate, 0)
                            
                                  " Open folds.
    2              0.000009       normal! zv
    2   0.000180   0.000018       call s:adjust_scroll(s:best_winline())
                            
    2   0.000083   0.000010       call unite#remove_previewed_buffer_list(bufnr)
    2              0.000002     endfor

FUNCTION  unite#action#get_default_action()
Called 2 times
Total time:   0.002503
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000020   0.000011   let kinds = unite#util#convert2list(a:kind)
                            
    2   0.002481   0.000015   return s:get_default_action(a:source_name, kinds[-1])

FUNCTION  vimproc#dll_version()
Called 1 time
Total time:   0.000102
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000098   0.000007   let [dll_version] = s:libcall('vp_dlversion', [])
    1              0.000002   return str2nr(dll_version)

FUNCTION  91()
Called 37 times
Total time:   0.032237
 Self time:   0.014808

count  total (s)   self (s)
   37   0.001860   0.000671     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: reset')
  222              0.001104     for type in self._enabled_types
  185              0.004261         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
  185              0.002820         if has_key(g:{class}, 'reset')
  111   0.018382   0.002142             call self._notifier[type].reset(a:loclist)
  111              0.000231         endif
  185              0.000591     endfor

FUNCTION  <SNR>81_IsRedrawRequiredAfterMake()
Called 32 times
Total time:   0.003755
 Self time:   0.001708

count  total (s)   self (s)
   32   0.003625   0.001578     return !s:running_windows && (s:uname() =~ "FreeBSD" || s:uname() =~ "OpenBSD")

FUNCTION  285()
Called 1 time
Total time:   0.000216
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000009   0.000005     if !nerdtree#treeExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
    1   0.000204   0.000006     return self.equals(b:NERDTreeRoot)

FUNCTION  unite#init#_filters()
Called 7 times
Total time:   0.000507
 Self time:   0.000191

count  total (s)   self (s)
    7   0.000497   0.000181   return extend(copy(unite#variables#static().filters), unite#variables#dynamic().filters)

FUNCTION  <SNR>145_change_highlight()
Called 3 times
Total time:   0.000961
 Self time:   0.000352

count  total (s)   self (s)
    3              0.000042   if &filetype !=# 'unite' || !exists('b:current_syntax')
                                return
                              endif
                            
    3   0.000113   0.000035   let unite = unite#get_current_unite()
    3              0.000024   if empty(unite)
                                return
                              endif
                            
    3   0.000175   0.000033   let context = unite#get_context()
    3              0.000021   let prompt_linenr = unite.prompt_linenr
    3              0.000012   if !context.no_cursor_line
    3   0.000435   0.000046     call s:set_cursor_line()
    3              0.000006   endif
                            
    3              0.000039   silent! syntax clear uniteCandidateInputKeyword
                            
    3              0.000024   if !context.is_changed || unite#helper#get_input() == ''
    3              0.000007     return
                              endif
                            
                              syntax case ignore
                            
                              for input in unite#helper#get_substitute_input( unite#helper#get_input())
                                for pattern in map(split(input, '\\\@<! '), "substitute(escape(unite#util#escape_match(v:val), '/'),   '\\\\\\@<!|', '\\\\|', 'g')")
                                  execute 'syntax match uniteCandidateInputKeyword' '/'.pattern.'/' 'containedin=uniteCandidateAbbr contained'
                                  for source in filter(copy(unite.sources), 'v:val.syntax != ""')
                                    execute 'syntax match uniteCandidateInputKeyword' '/'.pattern.'/' 'containedin='.source.syntax.' contained'
                                  endfor
                                endfor
                              endfor
                            
                              syntax case match

FUNCTION  nerdtree#isWindowUsable()
Called 4 times
Total time:   0.003818
 Self time:   0.000219

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    4              0.000013     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    4              0.000013     let oldwinnr = winnr()
    4   0.001937   0.000035     call nerdtree#exec(a:winnumber . "wincmd p")
    4              0.000045     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    4              0.000014     let modified = &modified
    4   0.001738   0.000041     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    4              0.000006     if specialWindow
                                    return 0
                                endif
                            
    4              0.000005     if &hidden
    4              0.000004         return 1
                                endif
                            
                                return !modified || nerdtree#bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  <SNR>191_libcall()
Called 12 times
Total time:   0.016316
 Self time:   0.015096

count  total (s)   self (s)
                              " End Of Value
   12              0.000039   let EOV = "\xFF"
   12              0.000181   let args = empty(a:args) ? '' : (join(reverse(copy(a:args)), EOV) . EOV)
   12              0.014196   let stack_buf = libcall(g:vimproc#dll_path, a:func, args)
   12   0.001393   0.000215   let result = s:split(stack_buf, EOV)
   12              0.000067   if get(result, -1, 'error') != ''
    1              0.000008     if stack_buf[len(stack_buf) - 1] ==# EOV
                                  " Note: If &encoding equals "cp932" and output ends multibyte first byte,
                                  "       will fail split.
                                  return result
                                endif
    1              0.000003     let s:lasterr = result
    1   0.000065   0.000023     let msg = vimproc#util#iconv(string(result), vimproc#util#termencoding(), &encoding)
                            
    1             83.015352     throw printf('vimproc: %s: %s', a:func, msg)
                              endif
   11              0.000045   return result[:-2]

FUNCTION  <SNR>203_exit()
Called 1 time
Total time:   0.034819
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000064   0.000015   let context = unite#get_context()
                            
    1   0.034746   0.000009   call unite#force_quit_session()
                            
    1              0.000002   if context.tab && winnr('$') == 1 && !context.temporary
                                " Close window.
                                close
                              endif

FUNCTION  <SNR>188_uniq()
Called 15 times
Total time:   0.007579
 Self time:   0.007579

count  total (s)   self (s)
   15              0.000747   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
   15              0.000041   let i = 0
   15              0.000039   let seen = {}
  350              0.000715   while i < len(list)
  335              0.001882     let key = string(a:0 ? list[i][1] : list[i])
  335              0.000823     if has_key(seen, key)
  252              0.000982       call remove(list, i)
  252              0.000184     else
   83              0.000246       let seen[key] = 1
   83              0.000143       let i += 1
   83              0.000065     endif
  335              0.000275   endwhile
   15              0.000148   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  neobundle#config#source_bundles()
Called 35 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
   35              0.000132   if !empty(a:bundles)
                                call neobundle#config#source(map(copy(a:bundles), "type(v:val) == type({}) ? v:val.name : v:val"))
                              endif

FUNCTION  <SNR>205_get_action_table()
Called 20 times
Total time:   0.117508
 Self time:   0.071738

count  total (s)   self (s)
   20   0.036517   0.000169   let kind = unite#get_kinds(a:kind_name)
   20   0.001927   0.000327   let source = empty(a:source_table) ? unite#get_sources(a:source_name) : unite#util#get_name(a:source_table, a:source_name, {})
   20              0.000062   if empty(source)
                                call unite#print_error('[unite.vim] source "' . a:source_name . '" is not found.')
                                return {}
                              endif
   20              0.000049   if empty(kind)
                                call unite#print_error('[unite.vim] kind "' . a:kind_name . '" is not found.')
                                return {}
                              endif
                            
   20              0.000070   let action_table = {}
                            
   20              0.000129   let source_kind = 'source/'.a:source_name.'/'.a:kind_name
   20              0.000100   let source_kind_wild = 'source/'.a:source_name.'/*'
                            
   20   0.000551   0.000156   let custom = unite#custom#get()
                            
   20              0.000052   if !a:is_parents_action
                                " Source/kind custom actions.
   20              0.000094     if has_key(custom.actions, source_kind)
                                  let action_table = s:extend_actions(a:self_func, action_table, custom.actions[source_kind], 'custom/'.source.name.'/'.kind.name)
                                endif
                            
                                " Source/kind actions.
   20              0.000086     if has_key(source.action_table, a:kind_name)
                                  let action_table = s:extend_actions(a:self_func, action_table, source.action_table[a:kind_name], source.name.'/'.kind.name)
                                endif
                            
                                " Source/* custom actions.
   20              0.000084     if has_key(custom.actions, source_kind_wild)
                                  let action_table = s:extend_actions(a:self_func, action_table, custom.actions[source_kind_wild], 'custom/source/'.source.name)
                                endif
                            
                                " Source/* actions.
   20              0.000065     if has_key(source.action_table, '*')
                                  let action_table = s:extend_actions(a:self_func, action_table, source.action_table['*'], 'source/'.source.name)
                                endif
                            
                                " Kind custom actions.
   20              0.000095     if has_key(custom.actions, a:kind_name)
    2   0.000219   0.000041       let action_table = s:extend_actions(a:self_func, action_table, custom.actions[a:kind_name], 'custom/'.kind.name)
    2              0.000003     endif
                            
                                " Kind actions.
   20   0.003742   0.000261     let action_table = s:extend_actions(a:self_func, action_table, kind.action_table, kind.name)
   20              0.000025   endif
                            
                              " Parents actions.
   20              0.000074   for parent in source.parents
                                let parent_kind = unite#get_kinds(parent)
                                let action_table = s:extend_actions(a:self_func, action_table, parent_kind.action_table, parent)
                              endfor
   36              0.000085   for parent in kind.parents
   16              0.001026     let action_table = s:extend_actions(a:self_func, action_table, unite#action#get_action_table(a:source_name, parent,                    a:self_func, 0, a:source_table))
   16              0.000024   endfor
                            
   20              0.000053   if !a:is_parents_action
                                " Kind aliases.
   20   0.001092   0.000269     call s:filter_alias_action(action_table, kind.alias_table, kind.name)
                            
                                " Kind custom aliases.
   20              0.000086     if has_key(custom.aliases, a:kind_name)
                                  call s:filter_alias_action(action_table, custom.aliases[a:kind_name], 'custom/'.kind.name)
                                endif
                            
                                " Source/* aliases.
   20              0.000069     if has_key(source.alias_table, '*')
                                  call s:filter_alias_action(action_table, source.alias_table['*'], 'source/'.source.name)
                                endif
                            
                                " Source/* custom aliases.
   20              0.000072     if has_key(custom.aliases, source_kind_wild)
                                  call s:filter_alias_action(action_table, custom.aliases[source_kind_wild], 'custom/source/'.source.name)
                                endif
                            
                                " Source/kind aliases.
   20              0.000064     if has_key(custom.aliases, source_kind)
                                  call s:filter_alias_action(action_table, custom.aliases[source_kind], 'source/'.source.name.'/'.kind.name)
                                endif
                            
                                " Source/kind custom aliases.
   20              0.000069     if has_key(source.alias_table, a:kind_name)
                                  call s:filter_alias_action(action_table, source.alias_table[a:kind_name], 'custom/source/'.source.name.'/'.kind.name)
                                endif
   20              0.000017   endif
                            
                              " Initialize action.
  370              0.000907   for [action_name, action] in items(action_table)
  350              0.000761     if !has_key(action, 'name')
   61              0.000130       let action.name = action_name
   61              0.000033     endif
  350              0.000714     if !has_key(action, 'from')
                                  let action.from = ''
                                endif
  350              0.000770     if !has_key(action, 'description')
                                  let action.description = ''
                                endif
  350              0.000737     if !has_key(action, 'is_quit')
   42              0.000071       let action.is_quit = 1
   42              0.000023     endif
  350              0.000742     if !has_key(action, 'is_start')
   53              0.000091       let action.is_start = 0
   53              0.000028     endif
  350              0.000704     if !has_key(action, 'is_tab')
   60              0.000097       let action.is_tab = 0
   60              0.000037     endif
  350              0.000761     if !has_key(action, 'is_selectable')
   33              0.000050       let action.is_selectable = 0
   33              0.000017     endif
  350              0.000812     if !has_key(action, 'is_invalidate_cache')
   50              0.000098       let action.is_invalidate_cache = 0
   50              0.000027     endif
  350              0.000739     if !has_key(action, 'is_listed')
   51              0.000358       let action.is_listed = (action.name !~ '^unite__\|^vimfiler__')
   51              0.000039     endif
  350              0.000307   endfor
                            
                              " Filtering nop action.
   20              0.000733   return filter(action_table, 'v:key !=# "nop"')

FUNCTION  unite#view#_switch_unite_buffer()
Called 1 time
Total time:   0.031454
 Self time:   0.000611

count  total (s)   self (s)
                              " Search unite window.
    1   0.000040   0.000006   let winnr = unite#helper#get_unite_winnr(a:buffer_name)
    1              0.000003   if !a:context.no_split && winnr > 0
                                silent execute winnr 'wincmd w'
                                return
                              endif
                            
                              " Search unite buffer.
    1   0.000051   0.000008   let bufnr = unite#helper#get_unite_bufnr(a:buffer_name)
                            
    1              0.000002   if !a:context.no_split && !a:context.unite__direct_switch
                                " Split window.
    1   0.018682   0.000140     execute a:context.direction ((bufnr > 0) ? ((a:context.vertical) ? 'vsplit' : 'split') : ((a:context.vertical) ? 'vnew' : 'new'))
    1              0.000001   endif
                            
    1              0.000001   if bufnr > 0
                                silent noautocmd execute bufnr 'buffer'
                              else
    1              0.000011     if bufname('%') == ''
    1              0.000175       noautocmd silent enew
    1              0.000001     endif
    1              0.000209     silent! noautocmd edit `=a:context.real_buffer_name`
    1              0.000001   endif
                            
    1   0.000028   0.000015   call unite#handlers#_on_bufwin_enter(bufnr('%'))
    1   0.005792   0.000007   doautocmd WinEnter
    1   0.006431   0.000005   doautocmd BufWinEnter

FUNCTION  airline#highlighter#highlight()
Called 200 times
Total time:   4.737818
 Self time:   1.324220

count  total (s)   self (s)
  200              0.001344   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
  200              0.004326   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
  200              0.001149   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
  482              0.001250   for mode in mapped
  282              0.002412     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
  282              0.001712       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 9076              0.019571       for kvp in items(dict)
 8794              0.028276         let mode_colors = kvp[1]
 8794   0.442310   0.065070         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
26382              0.057215         for accent in keys(s:accents)
17588              0.052984           if !has_key(p.accents, accent)
                                        continue
                                      endif
17588              0.069791           let colors = copy(mode_colors)
17588              0.059430           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
17588              0.047289           if p.accents[accent][2] != ''
 8794              0.033657             let colors[2] = p.accents[accent][2]
 8794              0.007553           endif
17588              0.035724           if len(colors) >= 5
 2564              0.011663             let colors[4] = get(p.accents[accent], 4, '')
 2564              0.002376           else
15024              0.094605             call add(colors, get(p.accents[accent], 4, ''))
15024              0.013220           endif
17588   0.919999   0.144223           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
17588              0.018622         endfor
 8794              0.007981       endfor
                            
                                  " TODO: optimize this
 7569              0.015122       for sep in items(s:separators)
 7287   2.341677   0.081095         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
 7287              0.008047       endfor
  282              0.000233     endif
  282              0.000276   endfor

FUNCTION  unite#init#_tab_variables()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002   if !exists('t:unite')
    1              0.000004     let t:unite = { 'last_unite_bufnr' : -1 }
    1              0.000001   endif

FUNCTION  vimproc#util#is_mac()
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return s:is_mac

FUNCTION  115()
Called 53 times
Total time:   0.227259
 Self time:   0.223053

count  total (s)   self (s)
   53              0.000375     if has('signs')
  241              0.000655         for i in a:ids
  188              0.217272             execute "sign unplace " . i
  188   0.007995   0.003789             call remove(self._bufSignIds(), index(self._bufSignIds(), i))
  188              0.000257         endfor
   53              0.000051     endif

FUNCTION  <SNR>180_AddToClasspath()
Called 31 times
Total time:   0.001630
 Self time:   0.001630

count  total (s)   self (s)
   31              0.000284     if a:path == ''
                                    return a:classpath
                                endif
   31              0.000191     if a:classpath != '' && a:path != ''
                                    if has('win32') || has('win32unix') || has('win64')
                                        return a:classpath . ";" . a:path
                                    else
                                        return a:classpath . ":" . a:path
                                    endif
                                else
   31              0.000113         return a:path
                                endif

FUNCTION  airline#parts#ffenc()
Called 7697 times
Total time:   0.221196
 Self time:   0.221196

count  total (s)   self (s)
 7697              0.215353   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  vimproc#util#termencoding()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000005   return 'char'

FUNCTION  sy#util#escape()
Called 78 times
Total time:   0.005266
 Self time:   0.005266

count  total (s)   self (s)
   78              0.000662   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
   78              0.001036   let path = shellescape(a:path)
                            
   78              0.000463   if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
   78              0.000303   return path

FUNCTION  <SNR>31_invoke_funcrefs()
Called 167 times
Total time:   0.952900
 Self time:   0.014493

count  total (s)   self (s)
  167   0.013832   0.002073   let builder = airline#builder#new(a:context)
  167   0.922844   0.004085   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
  167              0.000374   if err == 1
  167   0.010286   0.002397     let a:context.line = builder.build()
  167              0.001830     let s:contexts[a:context.winnr] = a:context
  167              0.002755     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
  167              0.000259   endif

FUNCTION  <SNR>130_activateFileNode()
Called 2 times
Total time:   0.102940
 Self time:   0.000034

count  total (s)   self (s)
    2   0.102936   0.000030     call a:node.activate({'reuse': 1, 'where': 'p'})

FUNCTION  <SNR>191_is_pseudo_device()
Called 2 times
Total time:   0.000026
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000015   0.000010   if vimproc#util#is_windows() && (    a:filename ==# '/dev/stdin' || a:filename ==# '/dev/stdout' || a:filename ==# '/dev/stderr')
                                return 1
                              endif
                            
    2              0.000006   return a:filename == '' || a:filename ==# '/dev/null' || a:filename ==# '/dev/clip' || a:filename ==# '/dev/quickfix'

FUNCTION  <SNR>123_get_list()
Called 16 times
Total time:   0.029026
 Self time:   0.000264

count  total (s)   self (s)
   16              0.000080   if !exists('s:List')
    1   0.028784   0.000022     let s:List = unite#util#get_vital().import('Data.List')
    1              0.000001   endif
   16              0.000032   return s:List

FUNCTION  nerdtree#treeExistsForTab()
Called 8 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    8              0.000104     return exists("t:NERDTreeBufName")

FUNCTION  vimproc#parser#split_pipe()
Called 1 time
Total time:   0.000901
 Self time:   0.000660

count  total (s)   self (s)
    1              0.000022   let script = type(a:script) == type([]) ? a:script : split(a:script, '\zs')
    1              0.000003   let max = len(script)
    1              0.000002   let command = ''
                            
    1              0.000002   let i = 0
    1              0.000001   let commands = []
   18              0.000020   while i < max
   17              0.000032     if script[i] == '|'
                                  " Pipe.
                                  call add(commands, command)
                            
                                  " Search next command.
                                  let command = ''
                                  let i += 1
                                elseif script[i] == "'"
                                  " Single quote.
    1   0.000249   0.000008       let [string, i] = s:skip_single_quote(script, i)
    1              0.000002       let command .= string
    1              0.000001     elseif script[i] == '"'
                                  " Double quote.
                                  let [string, i] = s:skip_double_quote(script, i)
                                  let command .= string
                                elseif script[i] == '`'
                                  " Back quote.
                                  let [string, i] = s:skip_back_quote(script, i)
                                  let command .= string
                                elseif script[i] == '\' && i + 1 < max
                                  " Escape.
                                  let command .= '\' . script[i+1]
                                  let i += 2
                                else
   16              0.000042       let command .= script[i]
   16              0.000020       let i += 1
   16              0.000013     endif
   17              0.000012   endwhile
                            
    1              0.000007   call add(commands, command)
                            
    1              0.000002   return commands

FUNCTION  AutoPairsMap()
Called 63 times
Total time:   0.003345
 Self time:   0.003345

count  total (s)   self (s)
                              " | is special key which separate map command from text
   63              0.000295   let key = a:key
   63              0.000160   if key == '|'
                                let key = '<BAR>'
                              end
   63              0.000530   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   63              0.001962   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  nerdtree#isTreeOpen()
Called 13 times
Total time:   0.001808
 Self time:   0.000248

count  total (s)   self (s)
   13   0.001738   0.000178     return nerdtree#getTreeWinNum() != -1

FUNCTION  vimproc#util#is_cygwin()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:is_cygwin

FUNCTION  <SNR>191_vp_pipes_close()
Called 3 times
Total time:   0.000407
 Self time:   0.000053

count  total (s)   self (s)
    6              0.000011   for fd in self.fd
    3              0.000004     try
    3   0.000366   0.000012       call fd.close()
    3              0.000003     catch /vimproc: vp_pipe_close: /
                                  " Ignore error.
                                endtry
    3              0.000002   endfor

FUNCTION  AntSyntaxScript()
Called 2 times
Total time:   0.002089
 Self time:   0.000269

count  total (s)   self (s)
    2              0.000003 	unlet b:current_syntax
    2              0.000028 	let s:include = expand("<sfile>:p:h").'/'.a:synfilename
    2              0.000012 	if filereadable(s:include)
                            	    exe 'syn include @ant'.a:tagname.' '.s:include
                            	else
    2   0.001907   0.000087 	    exe 'syn include @ant'.a:tagname." $VIMRUNTIME/syntax/".a:synfilename
    2              0.000002 	endif
                            
    2              0.000107 	exe 'syn region ant'.a:tagname." start=#<script[^>]\\{-}language\\s*=\\s*['\"]".a:tagname."['\"]\\(>\\|[^>]*[^/>]>\\)#".' end=#</script>#'.' fold'.' contains=@ant'.a:tagname.',xmlCdataStart,xmlCdataEnd,xmlTag,xmlEndTag'.' keepend'
    2              0.000015 	exe 'syn cluster xmlRegionHook add=ant'.a:tagname

FUNCTION  185()
Called 2 times
Total time:   0.096719
 Self time:   0.007690

count  total (s)   self (s)
    2   0.096714   0.007685     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  airline#parts#get()
Called 14 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   14              0.000052   return get(s:parts, a:key, {})

FUNCTION  186()
Called 56 times
Total time:   0.002266
 Self time:   0.001651

count  total (s)   self (s)
   56   0.000905   0.000290     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   56              0.000184         let self.drive = ''
   56              0.000061     endif
                            

FUNCTION  328()
Called 2 times
Total time:   0.004697
 Self time:   0.000092

count  total (s)   self (s)
    2              0.000007     if b:NERDTreeType ==# "secondary"
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    2   0.000036   0.000011         call self._checkToCloseTree(1)
                            
    2              0.000004         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    2   0.004553   0.000010             call self._previousWindow()
    2              0.000001         endif
                            
    2   0.000051   0.000014         call self._checkToCloseTree(0)
    2              0.000001     endif

FUNCTION  neosnippet#variables#snippets_dir()
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000008   if !exists('s:snippets_dir')
                                let s:snippets_dir = []
                              endif
                            
    3              0.000005   return s:snippets_dir

FUNCTION  airline#parts#paste()
Called 5477 times
Total time:   0.034313
 Self time:   0.034313

count  total (s)   self (s)
 5477              0.029320   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  288()
Called 2 times
Total time:   0.102840
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000007     let opts = a:0 ? a:1 : {}
    2   0.000186   0.000020     let opener = g:NERDTreeOpener.New(self.path, opts)
    2   0.102642   0.000021     call opener.open(self)

FUNCTION  airline#update_statusline()
Called 102 times
Total time:   0.975181
 Self time:   0.022281

count  total (s)   self (s)
  167              0.003292   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
   65              0.000666     call setwinvar(nr, 'airline_active', 0)
   65              0.000899     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   65   0.283175   0.001171     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   65              0.000341   endfor
                            
  102              0.000445   unlet! w:airline_render_left
  102              0.000288   unlet! w:airline_render_right
  918              0.002317   for section in s:sections
  816              0.004074     unlet! w:airline_section_{section}
  816              0.001221   endfor
                            
  102              0.000498   let w:airline_active = 1
  102              0.001410   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
  102   0.672676   0.001780   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>194__vital_loaded()
Called 1 time
Total time:   0.001694
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002   let s:V = a:V
    1   0.001690   0.000007   let s:L = s:V.import('Data.List')

FUNCTION  unite#get_all_sources()
Called 2 times
Total time:   0.001895
 Self time:   0.000013

count  total (s)   self (s)
    2   0.001895   0.000013   return call('unite#variables#all_sources', a:000)

FUNCTION  neobundle#autoload#explorer()
Called 80 times
Total time:   0.008753
 Self time:   0.005780

count  total (s)   self (s)
   80              0.000936   if bufnr('%') != expand('<abuf>') || a:path == ''
    8              0.000009     return
                              endif
                            
   72              0.000352   let path = a:path
                              " For ":edit ~".
   72              0.000516   if fnamemodify(path, ':t') ==# '~'
                                let path = '~'
                              endif
                            
   72   0.003745   0.000772   let path = s:expand(path)
   72              0.002052   if !(isdirectory(path) || (!filereadable(path) && path =~ '^\h\w\+://'))
   72              0.000149     return
                              endif
                            
                              let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'explorer', 0)")
                              if !empty(bundles)
                                call neobundle#config#source_bundles(bundles)
                                execute 'doautocmd' a:event
                              endif

FUNCTION  unite#variables#options()
Called 3 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
    3              0.000035   if !exists('s:options')
    1              0.000061     let s:options = [ '-buffer-name=', '-profile-name=', '-input=', '-prompt=', '-default-action=', '-start-insert', '-no-start-insert', '-no-quit', '-winwidth=', '-winheight=', '-immediately', '-no-empty', '-auto-preview', '-auto-highlight', '-complete', '-vertical', '-horizontal', '-direction=', '-no-split', '-verbose', '-auto-resize', '-toggle', '-quick-match', '-create', '-cursor-line-highlight=', '-no-cursor-line', '-update-time=', '-hide-source-names', '-hide-status-line', '-max-multi-lines=', '-here', '-silent', '-keep-focus', '-auto-quit', '-no-focus', '-long-source-names', '-short-source-names', '-multi-line', '-resume', '-wrap', '-select=', '-log', '-truncate', '-tab',]
    1              0.000003   endif
                            
    3              0.000014   return s:options

FUNCTION  <SNR>212_jump()
Called 2 times
Total time:   0.000171
 Self time:   0.000108

count  total (s)   self (s)
    2              0.000019   let line = get(a:candidate, 'action__line', 1)
    2              0.000008   let pattern = get(a:candidate, 'action__pattern', '')
                            
    2              0.000003   if line == ''
                                " Use default line number.
                                let line = 1
                              endif
    2              0.000008   if line !~ '^\d\+$'
                                call unite#print_error('unite: jump_list: Invalid action__line format.')
                                return
                              endif
                            
    2              0.000006   if !has_key(a:candidate, 'action__pattern')
                                " Jump to the line number.
    2              0.000007     let col = get(a:candidate, 'action__col', 0)
    2              0.000002     if col == 0
    2              0.000004       if line('.') != line
    2              0.000007         execute line
    2              0.000002       endif
    2              0.000000     else
                                  call cursor(line, col)
                                endif
                            
    2   0.000076   0.000013     call s:open_current_line(a:is_highlight)
    2              0.000002     return
                              endif
                            
                              " Jump by search().
                              let source = unite#get_sources(a:candidate.source)
                              if !(has_key(a:candidate, 'action__signature') && has_key(source, 'calc_signature'))
                                " Not found signature.
                                if line != '' && getline(line) =~# pattern
                                  if line('.') != line
                                    execute line
                                  endif
                                else
                                  call search(pattern, 'w')
                                endif
                            
                                call s:open_current_line(a:is_highlight)
                                return
                              endif
                            
                              call search(pattern, 'w')
                            
                              let lnum_prev = line('.')
                              call search(pattern, 'w')
                              let lnum = line('.')
                              if lnum != lnum_prev
                                " Detected same pattern lines!!
                                let start_lnum = lnum
                                while source.calc_signature(lnum) !=# a:candidate.action__signature
                                  call search(pattern, 'w')
                                  let lnum = line('.')
                                  if lnum == start_lnum
                                    " Not found.
                                    call unite#print_error( "unite: jump_list: Target position is not found.")
                                    call cursor(1, 1)
                                    return
                                  endif
                                endwhile
                              endif
                            
                              call s:open_current_line(a:is_highlight)

FUNCTION  nerdtree#treeUpDirLine()
Called 31 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   31              0.000097     return '.. (up a dir)'

FUNCTION  unite#view#_redraw_candidates()
Called 2 times
Total time:   0.003366
 Self time:   0.000422

count  total (s)   self (s)
    2              0.000019   let is_gather_all = get(a:000, 0, 0)
                            
    2   0.000490   0.000019   call unite#view#_resize_window()
                            
    2   0.001250   0.000032   let candidates = unite#candidates#gather(is_gather_all)
                            
    2              0.000014   let modifiable_save = &l:modifiable
    2              0.000017   setlocal modifiable
                            
    2   0.000902   0.000047   let lines = unite#view#_convert_lines(candidates)
    2              0.000015   let pos = getpos('.')
    2   0.000063   0.000022   let unite = unite#get_current_unite()
    2              0.000014   if len(lines) < len(unite.current_candidates)
                                silent! execute (unite.prompt_linenr+1).',$delete _'
                              endif
    2              0.000047   call setline(unite.prompt_linenr+1, lines)
                            
    2              0.000019   let &l:modifiable = l:modifiable_save
                            
    2   0.000059   0.000019   let unite = unite#get_current_unite()
    2              0.000010   let context = unite.context
    2              0.000012   let unite.current_candidates = candidates
                            
    2              0.000013   if pos != getpos('.')
                                call setpos('.', pos)
                              endif
                            
    2              0.000012   if context.input == '' && context.log
                                " Move to bottom.
                                call cursor(line('$'), 0)
                              endif
                            
                              " Set syntax.
    2   0.000340   0.000021   call s:set_syntax()

FUNCTION  unite#action#_get_candidate_action_table()
Called 2 times
Total time:   0.068565
 Self time:   0.000078

count  total (s)   self (s)
    2   0.000104   0.000026   let Self = unite#get_self_functions()[-1]
                            
    2   0.068452   0.000043   return unite#action#get_action_table( a:candidate.source, a:candidate.kind, Self, 0, a:sources)

FUNCTION  airline#parts#readonly()
Called 5696 times
Total time:   0.030501
 Self time:   0.030501

count  total (s)   self (s)
 5696              0.025131   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  nerdtree#chRootCwd()
Called 1 time
Total time:   0.001632
 Self time:   0.000099

count  total (s)   self (s)
    1              0.000004     try
    1   0.000947   0.000030         let cwd = g:NERDTreePath.New(getcwd())
    1              0.000004     catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("current directory does not exist.")
                                    return
                                endtry
    1   0.000659   0.000043     if cwd.str() == g:NERDTreeFileNode.GetRootForTab().path.str()
    1              0.000001        return
                                endif
                                call nerdtree#chRoot(g:NERDTreeDirNode.New(cwd))

FUNCTION  unite#get_current_unite()
Called 220 times
Total time:   0.004363
 Self time:   0.003230

count  total (s)   self (s)
  220   0.004153   0.003020   return exists('b:unite') && !unite#variables#use_current_unite() ? b:unite : unite#variables#current_unite()

FUNCTION  <SNR>196_skip_else()
Called 17 times
Total time:   0.000816
 Self time:   0.000579

count  total (s)   self (s)
   17              0.000040   if a:script[a:i] == "'"
                                " Single quote.
    1   0.000243   0.000006     let [string, i] = s:skip_single_quote(a:script, a:i)
    1              0.000003     let script = a:args . string
    1              0.000002   elseif a:script[a:i] == '"'
                                " Double quote.
                                let [string, i] = s:skip_double_quote(a:script, a:i)
                                let script = a:args . string
                              elseif a:script[a:i] == '`'
                                " Back quote.
                                let [string, i] = s:skip_back_quote(a:script, a:i)
                                let script = a:args . string
                              elseif a:script[a:i] == '\'
                                " Escape.
                                let script = a:args . '\' . a:script[a:i+1]
                                let i = a:i + 2
                              else
   16              0.000052     let script = a:args . a:script[a:i]
   16              0.000027     let i = a:i + 1
   16              0.000007   endif
                            
   17              0.000027   return [script, i]

FUNCTION  <SNR>191_fdopen_pipes()
Called 3 times
Total time:   0.000376
 Self time:   0.000085

count  total (s)   self (s)
    3   0.000374   0.000083   return { 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '', 'fd' : a:fd, 'f_close' : s:funcref(a:f_close), 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  unite#util#uniq()
Called 13 times
Total time:   0.030766
 Self time:   0.000218

count  total (s)   self (s)
   13   0.030755   0.000207   return call(s:get_list().uniq, a:000)

FUNCTION  airline#extensions#apply_left_override()
Called 14 times
Total time:   0.002704
 Self time:   0.000270

count  total (s)   self (s)
   14              0.000046   let w:airline_section_a = a:section1
   14              0.000035   let w:airline_section_b = a:section2
   14   0.002535   0.000101   let w:airline_section_c = airline#section#create(['readonly'])
   14              0.000036   let w:airline_render_left = 1
   14              0.000031   let w:airline_render_right = 0

FUNCTION  <SNR>158_ApplyConfig()
Called 5 times
Total time:   0.000818
 Self time:   0.000711

count  total (s)   self (s)
                            " Set the indentation style according to the config values
                            
    5              0.000028     if has_key(a:config, "indent_style")
                                    if a:config["indent_style"] == "tab"
                                        setl noexpandtab
                                    elseif a:config["indent_style"] == "space"
                                        setl expandtab
                                    endif
                                endif
    5              0.000015     if has_key(a:config, "tab_width")
                                    let &l:tabstop = str2nr(a:config["tab_width"])
                                endif
    5              0.000014     if has_key(a:config, "indent_size")
                            
                                    " if indent_size is 'tab', set shiftwidth to tabstop;
                                    " if indent_size is a positive integer, set shiftwidth to the integer
                                    " value
                                    if a:config["indent_size"] == "tab"
                                        let &l:shiftwidth = &l:tabstop
                                        let &l:softtabstop = &l:shiftwidth
                                    else
                                        let l:indent_size = str2nr(a:config["indent_size"])
                                        if l:indent_size > 0
                                            let &l:shiftwidth = l:indent_size
                                            let &l:softtabstop = &l:shiftwidth
                                        endif
                                    endif
                            
                                endif
                            
    5              0.000016     if has_key(a:config, "end_of_line") && &l:modifiable
                                    if a:config["end_of_line"] == "lf"
                                        setl fileformat=unix
                                    elseif a:config["end_of_line"] == "crlf"
                                        setl fileformat=dos
                                    elseif a:config["end_of_line"] == "cr"
                                        setl fileformat=mac
                                    endif
                                endif
                            
    5              0.000015     if has_key(a:config, "charset") && &l:modifiable
                                    if a:config["charset"] == "utf-8"
                                        setl fileencoding=utf-8
                                        setl nobomb
                                    elseif a:config["charset"] == "utf-8-bom"
                                        setl fileencoding=utf-8
                                        setl bomb
                                    elseif a:config["charset"] == "latin1"
                                        setl fileencoding=latin1
                                        setl nobomb
                                    elseif a:config["charset"] == "utf-16be"
                                        setl fileencoding=utf-16be
                                        setl bomb
                                    elseif a:config["charset"] == "utf-16le"
                                        setl fileencoding=utf-16le
                                        setl bomb
                                    endif
                                endif
                            
    5              0.000015     if has_key(a:config, "trim_trailing_whitespace")
                                    augroup editorconfig_trim_trailing_whitespace
                                    autocmd! editorconfig_trim_trailing_whitespace
                                    if a:config["trim_trailing_whitespace"] == "true"
                                        autocmd editorconfig_trim_trailing_whitespace BufWritePre <buffer> :%s/\s\+$//e
                                    endif
                            
                                    augroup END " editorconfig_trim_trailing_whitespace group
                                endif
                            
    5              0.000016     if has_key(a:config, 'max_line_length')
                                    let l:max_line_length = str2nr(a:config['max_line_length'])
                            
                                    if l:max_line_length > 0
                                        let &l:textwidth = l:max_line_length
                            
                                        " highlight the column
                                        if exists('+colorcolumn')
                                            let &l:colorcolumn = l:max_line_length
                                        endif
                                    endif
                                endif
                            
    5   0.000156   0.000049     call editorconfig#ApplyHooks(a:config)

FUNCTION  nerdtree#has_opt()
Called 653 times
Total time:   0.003690
 Self time:   0.003690

count  total (s)   self (s)
  653              0.003245     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>4_unite_settings()
Called 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000020         nmap <buffer> Q <plug>(unite_exit)
    1              0.000015         nmap <buffer> <esc> <plug>(unite_exit)
    1              0.000013         imap <buffer> <esc> <plug>(unite_exit)

FUNCTION  <SNR>81_BufEnterHook()
Called 55 times
Total time:   0.016732
 Self time:   0.008128

count  total (s)   self (s)
   55   0.002651   0.001569     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
                                " TODO: at this point there is no b:syntastic_loclist
   55              0.003212     let loclist = filter(getloclist(0), 'v:val["valid"] == 1')
   55   0.009929   0.002407     let buffers = syntastic#util#unique(map( loclist, 'v:val["bufnr"]' ))
   55              0.000422     if &buftype == 'quickfix' && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                    call g:SyntasticLoclistHide()
                                endif

FUNCTION  <SNR>158_UseConfigFiles_Python_Builtin()
Called 5 times
Total time:   0.005191
 Self time:   0.004373

count  total (s)   self (s)
                            " Use built-in python to run the python EditorConfig core
                            
    5              0.000024     let l:config = {}
    5              0.000013     let l:ret = 0
                            
                                " ignore buffers that do not have a file path associated
    5              0.000069     if empty(expand('%:p'))
                                    return 0
                                endif
                            
    5              0.000008     python << EEOOFF
                            
                            ec_data['filename'] = vim.eval("expand('%:p')")
                            ec_data['conf_file'] = ".editorconfig"
                            
                            try:
                                ec_data['options'] = editorconfig.get_properties(ec_data['filename'])
                            except editorconfig_except.EditorConfigError, e:
                                if int(vim.eval('g:EditorConfig_verbose')) != 0:
                                    print >> sys.stderr, str(e)
                                vim.command('let l:ret = 1')
                            
                            EEOOFF
    5              0.000028     if l:ret != 0
                                    return l:ret
                                endif
                            
    5              0.000007     python << EEOOFF
                            for key, value in ec_data['options'].items():
                                vim.command("let l:config['" + key.replace("'", "''") + "'] = " +
                                    "'" + value.replace("'", "''") + "'")
                            
                            EEOOFF
                            
    5   0.000882   0.000064     call s:ApplyConfig(l:config)
                            
    5              0.000008     return 0

FUNCTION  airline#highlighter#exec()
Called 44143 times
Total time:   2.076697
 Self time:   2.076697

count  total (s)   self (s)
44143              0.122408   let colors = a:colors
44143              0.069262   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
44143              1.404541   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  unite#set_current_unite()
Called 7 times
Total time:   0.000079
 Self time:   0.000052

count  total (s)   self (s)
    7   0.000074   0.000047   return unite#variables#set_current_unite(a:unite)

FUNCTION  unite#handlers#_save_updatetime()
Called 2 times
Total time:   0.000058
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000041   0.000009   let unite = unite#get_current_unite()
                            
    2              0.000006   if unite.is_async && &updatetime > unite.context.update_time
                                let unite.update_time_save = &updatetime
                                let &updatetime = unite.context.update_time
                              endif

FUNCTION  neosnippet#get_placeholder_marker_pattern()
Called 30 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   30              0.000123   return '<`\d\+\%(:.\{-}\)\?\\\@<!`>'

FUNCTION  unite#view#_convert_lines()
Called 2 times
Total time:   0.000855
 Self time:   0.000317

count  total (s)   self (s)
    2              0.000020   let quick_match_table = get(a:000, 0, {})
                            
    2   0.000061   0.000020   let unite = unite#get_current_unite()
    2              0.000009   let context = unite.context
    2   0.000093   0.000039   let [max_width, max_source_name] = unite#helper#adjustments(winwidth(0)-1, unite.max_source_name, 2)
    2              0.000006   if unite.max_source_name == 0
    2              0.000009     let max_width -= 1
    2              0.000003   endif
                            
                              " Create key table.
    2              0.000009   let keys = {}
    2              0.000016   for [key, number] in items(quick_match_table)
                                let keys[number] = key . '|'
                              endfor
                            
    2   0.000597   0.000154   return map(copy(a:candidates), "(v:val.is_dummy ? '  ' :   v:val.unite__is_marked ? g:unite_marked_icon . ' ' :   empty(quick_match_table) ? g:unite_candidate_icon . ' ' :   get(keys, v:key, '  ')) . (unite.max_source_name == 0 ? ''   : unite#util#truncate(unite#helper#convert_source_name(     (v:val.is_dummy ? '' : v:val.source)), max_source_name)) . unite#util#truncate_wrap(v:val.unite__abbr, " . max_width    .  ", (context.truncate ? 0 : max_width/2), '..')")

FUNCTION  SyntaxCheckers_java_javac_GetLocList()
Called 32 times
Total time:  26.416113
 Self time:   0.032165

count  total (s)   self (s)
                            
   32              0.000336     let javac_opts = g:syntastic_java_javac_options
                            
   32              0.000185     if g:syntastic_java_javac_delete_output
   32              0.000285         let output_dir = g:syntastic_java_javac_temp_dir
   32              0.000339         let javac_opts .= ' -d ' . output_dir
   32              0.000081     endif
                            
                                " load classpath from config file
   32              0.000202     if g:syntastic_java_javac_config_file_enabled
                                    let loaded_classpath = s:LoadClasspathFromConfigFile()
                                    if loaded_classpath != ''
                                        let g:syntastic_java_javac_classpath = loaded_classpath
                                    endif
                                endif
                            
   32              0.000191     let javac_classpath = ''
                            
                                " add classpathes to javac_classpath
   63              0.000833     for path in split(g:syntastic_java_javac_classpath,"\n")
   31              0.000177         if path != ''
   31              0.000185             try
   31              0.003098                 let ps = glob(path,0,1)
   31              0.000133             catch
                                            let ps = split(glob(path,0),"\n")
                                        endtry
   31              0.000290             if type(ps) == type([])
   62              0.000234                 for p in ps
   31              0.000142                     if p != ''
   31   0.002631   0.001001                         let javac_classpath = s:AddToClasspath(javac_classpath,p)
   31              0.000065                     endif
   31              0.000066                 endfor
   31              0.000069             else
                                            let javac_classpath = s:AddToClasspath(javac_classpath,ps)
                                        endif
   31              0.000050         endif
   31              0.000062     endfor
                            
   32              0.000230     if s:has_maven && g:syntastic_java_javac_autoload_maven_classpath
                                    if !g:syntastic_java_javac_delete_output
                                        let javac_opts .= ' -d ' . s:MavenOutputDirectory()
                                    endif
                                    let javac_classpath = s:AddToClasspath(javac_classpath, s:GetMavenClasspath())
                                endif
                            
   32              0.000162     if javac_classpath != ''
   31              0.001270         let javac_opts .= ' -cp "' . fnameescape(javac_classpath) . '"'
   31              0.000064     endif
                            
                                " path seperator
   32              0.000684     if has('win32') || has('win32unix') || has('win64')
                                    let sep = "\\"
                                else
   32              0.000231         let sep = '/'
   32              0.000072     endif
                            
   32              0.003298     let fname = fnameescape(expand ( '%:p:h' ) . sep . expand ( '%:t' ))
                            
   32              0.000345     if has('win32unix')
                                    let fname =  s:CygwinPath(fname)
                                endif
                            
   32   0.028110   0.001038     let makeprg = self.makeprgBuild({ 'args': javac_opts, 'fname': fname, 'tail': '2>&1' })
                            
                                " unashamedly stolen from *errorformat-javac* (quickfix.txt) and modified to include error types
   32              0.000529     let errorformat = '%E%f:%l:\ error:\ %m,'. '%W%f:%l:\ warning:\ %m,'. '%A%f:%l:\ %m,'. '%+Z%p^,'. '%+C%.%#,'. '%-G%.%#'
                            
   32              0.000183     if g:syntastic_java_javac_delete_output
   32              0.003650         silent! call mkdir(output_dir,'p')
   32              0.000140     endif
   32  25.991812   0.002549     let errors = SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': ['cygwinRemoveCR'] })
                            
   32              0.000293     if g:syntastic_java_javac_delete_output
   32   0.367514   0.001531         call s:RemoveDir(output_dir)
   32              0.000190     endif
   32              0.000364     return errors
                            

FUNCTION  <SNR>212_open()
Called 2 times
Total time:   0.000187
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000153   0.000015   let bufnr = s:get_bufnr(a:candidate)
    2              0.000005   if bufnr != bufnr('%')
                                if has_key(a:candidate, 'action__buffer_nr')
                                  silent execute 'buffer' bufnr
                                else
                                  call unite#util#smart_execute_command( 'edit!', unite#util#substitute_path_separator(   fnamemodify(a:candidate.action__path, ':~:.')))
                                endif
                              endif
                            
    2              0.000002   return bufnr

FUNCTION  unite#view#_init_cursor()
Called 1 time
Total time:   0.000195
 Self time:   0.000104

count  total (s)   self (s)
    1   0.000014   0.000004   let unite = unite#get_current_unite()
    1              0.000002   let context = unite.context
                            
    1   0.000045   0.000008   let positions = unite#custom#get_profile( unite.profile_name, 'unite__save_pos')
    1   0.000050   0.000006   let key = unite#loaded_source_names_string()
    1              0.000007   let is_restore = has_key(positions, key) && context.select == 0 &&   positions[key].candidate ==#     unite#helper#get_current_candidate(positions[key].pos[1])
                            
    1              0.000002   if context.start_insert && !context.auto_quit
    1              0.000002     let unite.is_insert = 1
                            
    1              0.000004     call cursor(unite.prompt_linenr, 0)
                            
    1              0.000003     setlocal modifiable
    1              0.000003     startinsert!
    1              0.000001   else
                                let unite.is_insert = 0
                            
                                if is_restore
                                  " Restore position.
                                  call setpos('.', positions[key].pos)
                                else
                                  call cursor(unite#helper#get_current_candidate_linenr(0), 0)
                                endif
                            
                                normal! 0
                                stopinsert
                              endif
                            
    1              0.000002   if line('.') <= winheight(0)
    1              0.000017     normal! zb
    1              0.000001   endif
                            
    1              0.000002   if context.select != 0
                                " Select specified candidate.
                                call cursor(unite#helper#get_current_candidate_linenr( context.select), 0)
                              elseif context.input == '' && context.log
                                call unite#view#_redraw_candidates(1)
                              endif
                            
    1              0.000001   if context.no_focus
                                if winbufnr(winnr('#')) > 0
                                  wincmd p
                                else
                                  execute bufwinnr(unite.prev_bufnr).'wincmd w'
                                endif
                              endif
                            
    1              0.000002   if context.quick_match
                                call unite#mappings#_quick_match(0)
                              endif

FUNCTION  <SNR>55_addtomrufs()
Called 150 times
Total time:   0.041399
 Self time:   0.037179

count  total (s)   self (s)
  150              0.007150 	let fn = fnamemodify(a:fname, ':p')
  150              0.003170 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
  150              0.016792 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
  131              0.002339 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
  131              0.000431 	if idx
   46              0.001869 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   46              0.000402 		cal insert(s:mrufs, fn)
   46              0.000343 		if {s:soup} && idx < 0
    4   0.004423   0.000203 			cal s:savetofile(s:mergelists())
    4              0.000009 		en
   46              0.000068 	en

FUNCTION  <SNR>187_iconv()
Called 4 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    4              0.000015   if a:from == '' || a:to == '' || a:from ==? a:to
                                return a:expr
                              endif
    4              0.000058   let result = iconv(a:expr, a:from, a:to)
    4              0.000011   return result != '' ? result : a:expr

FUNCTION  unite#util#has_lua()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                              " Note: Disabled if_lua feature if less than 7.3.885.
                              " Because if_lua has double free problem.
    1              0.000010   return has('lua') && (v:version > 703 || v:version == 703 && has('patch885'))

FUNCTION  unite#util#is_windows()
Called 6 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    6              0.000015   return s:is_windows

FUNCTION  54()
Called 5567 times
Total time:   0.075128
 Self time:   0.074801

count  total (s)   self (s)
 5567              0.028753     if !exists("b:syntastic_loclist")
    7   0.000376   0.000049         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    7              0.000005     endif
 5567              0.012273     return b:syntastic_loclist

FUNCTION  nerdtree#exec()
Called 25 times
Total time:   0.007147
 Self time:   0.007147

count  total (s)   self (s)
   25              0.000399     let old_ei = &ei
   25              0.000393     set ei=all
   25              0.005884     exec a:cmd
   25              0.000411     let &ei = old_ei

FUNCTION  unite#init#_kinds()
Called 22 times
Total time:   0.002392
 Self time:   0.001759

count  total (s)   self (s)
   22   0.001054   0.000421   let kinds = extend(copy(unite#variables#static().kinds), unite#variables#dynamic().kinds)
   28              0.000716   for kind in values(filter(copy(kinds), '!has_key(v:val, "is_initialized")'))
    6              0.000018     let kind.is_initialized = 1
    6              0.000016     if !has_key(kind, 'action_table')
                                  let kind.action_table = {}
                                endif
    6              0.000012     if !has_key(kind, 'alias_table')
    3              0.000007       let kind.alias_table = {}
    3              0.000002     endif
    6              0.000011     if !has_key(kind, 'parents')
    3              0.000007       let kind.parents = ['common']
    3              0.000003     endif
    6              0.000005   endfor
                            
   22              0.000041   return kinds

FUNCTION  <SNR>191_read_lines()
Called 3 times
Total time:   0.013657
 Self time:   0.000250

count  total (s)   self (s)
    3              0.000013   let res = self.buffer
                            
    4              0.000021   while !self.eof && stridx(res, "\n") < 0
    2   0.013442   0.000035     let out = call(self.read, a:000, self)
    2              0.000007     if out  == ''
    1              0.000004       break
                                endif
                            
    1              0.000003     let res .= out
    1              0.000001   endwhile
                            
    3              0.000010   let self.buffer = ''
    3              0.000060   let lines = split(res, '\r*\n', 1)
    3              0.000008   if !self.__eof
    2              0.000013     let self.buffer = get(lines, -1, '')
    2              0.000014     let lines = lines[ : -2]
    2              0.000004   endif
                            
    3              0.000006   return lines

FUNCTION  unite#kinds#jump_list#define()
Called 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000010   let kind = { 'name' : 'jump_list', 'default_action' : 'open', 'action_table': {}, 'alias_table' : { 'rename' : 'replace' }, 'parents': ['openable'],}
                            
                              " Actions "{{{
    1              0.000005   let kind.action_table.open = { 'description' : 'jump to this position', 'is_selectable' : 1, }
    1              0.000003   function! kind.action_table.open.func(candidates) "{{{
                                for candidate in a:candidates
                                  let bufnr = s:open(candidate)
                                  call s:jump(candidate, 0)
                            
                                  " Open folds.
                                  normal! zv
                                  call s:adjust_scroll(s:best_winline())
                            
                                  call unite#remove_previewed_buffer_list(bufnr)
                                endfor
                              endfunction"}}}
                            
    1              0.000004   let kind.action_table.preview = { 'description' : 'preview this position', 'is_quit' : 0, }
    1              0.000001   function! kind.action_table.preview.func(candidate) "{{{
                                let filename = s:get_filename(a:candidate)
                                let buflisted = buflisted( unite#util#escape_file_searching(filename))
                                let preview_windows = filter(range(1, winnr('$')), 'getwinvar(v:val, "&previewwindow") != 0')
                                if empty(preview_windows)
                                  noautocmd silent execute 'pedit!' fnameescape(filename)
                                  if !buflisted
                                    let prev_winnr = winnr('#')
                                    let winnr = winnr()
                                    wincmd P
                                    doautoall BufRead
                                    setlocal nomodified
                                    execute prev_winnr.'wincmd w'
                                    execute winnr.'wincmd w'
                                  endif
                                endif
                            
                                let prev_winnr = winnr('#')
                                let winnr = winnr()
                                wincmd P
                                let bufnr = s:open(a:candidate)
                                call s:jump(a:candidate, 1)
                                execute prev_winnr.'wincmd w'
                                execute winnr.'wincmd w'
                            
                                if !buflisted
                                  call unite#add_previewed_buffer_list(bufnr)
                                endif
                              endfunction"}}}
                            
    1              0.000004   let kind.action_table.highlight = { 'description' : 'highlight this position', 'is_quit' : 0, }
    1              0.000002   function! kind.action_table.highlight.func(candidate) "{{{
                                let candidate_winnr = bufwinnr(s:get_bufnr(a:candidate))
                            
                                if candidate_winnr > 0
                                  let unite = unite#get_current_unite()
                                  let context = unite.context
                                  let current_winnr = winnr()
                            
                                  if context.vertical 
                                      setlocal winfixwidth
                                  else 
                                      setlocal winfixheight
                                  endif
                            
                                  noautocmd execute candidate_winnr 'wincmd w'
                            
                                  call s:jump(a:candidate, 1)
                                  let unite_winnr = bufwinnr(unite.bufnr)
                                  if unite_winnr < 0
                                    let unite_winnr = current_winnr
                                  endif
                                  if unite_winnr > 0
                                    noautocmd execute unite_winnr 'wincmd w'
                                  endif
                                endif
                              endfunction"}}}
                            
                            
    1              0.000004   let kind.action_table.replace = { 'description' : 'replace with qfreplace', 'is_selectable' : 1, }
    1              0.000001   function! kind.action_table.replace.func(candidates) "{{{
                                if globpath(&runtimepath, 'autoload/qfreplace.vim') == ''
                                  echo 'qfreplace.vim is not installed.'
                                  return
                                endif
                            
                                let qflist = []
                                for candidate in a:candidates
                                  if has_key(candidate, 'action__line') && has_key(candidate, 'action__text')
                                    let filename = s:get_filename(candidate)
                                    call add(qflist, { 'filename' : filename, 'lnum' : candidate.action__line, 'text' : candidate.action__text, })
                                  endif
                                endfor
                            
                                if !empty(qflist)
                                  call setqflist(qflist)
                                  call qfreplace#start('')
                                endif
                              endfunction"}}}
                            
    1              0.000002   return kind

FUNCTION  unite#variables#disable_current_unite()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   let s:use_current_unite = 0

FUNCTION  unite#filters#sorter_default#define()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   return s:sorter

FUNCTION  189()
Called 29 times
Total time:   0.009893
 Self time:   0.000662

count  total (s)   self (s)
   29   0.000311   0.000098     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
   29              0.000257         let path = '/'. join(self.pathSegments[0:-2], '/')
   29              0.000027     endif
                            
   29   0.009142   0.000124     return s:Path.New(path)

FUNCTION  unite#loaded_source_names()
Called 4 times
Total time:   0.000171
 Self time:   0.000053

count  total (s)   self (s)
    4   0.000166   0.000048   return map(copy(unite#loaded_sources_list()), 'v:val.name')

FUNCTION  <SNR>29_Choose()
Called 11 times
Total time:   0.004285
 Self time:   0.004285

count  total (s)   self (s)
   11              0.000253   let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
   11              0.000301   let i = matchend(tail, s:notslash . a:comma)
   11              0.000037   if a:0
   11              0.000160     let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
   11              0.000223     let j = matchend(alttail, s:notslash . a:comma)
   11              0.000025   endif
   11              0.000137   let current = strpart(tail, 0, i-1)
   11              0.000053   if a:branch == ""
                                let currpat = current
                              else
   11              0.000305     let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
   11              0.000034   endif
   21              0.000418   while a:string !~ a:prefix . currpat . a:suffix
   10              0.000097     let tail = strpart(tail, i)
   10              0.000260     let i = matchend(tail, s:notslash . a:comma)
   10              0.000037     if i == -1
                                  return -1
                                endif
   10              0.000103     let current = strpart(tail, 0, i-1)
   10              0.000045     if a:branch == ""
                                  let currpat = current
                                else
   10              0.000259       let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
   10              0.000021     endif
   10              0.000026     if a:0
   10              0.000081       let alttail = strpart(alttail, j)
   10              0.000165       let j = matchend(alttail, s:notslash . a:comma)
   10              0.000019     endif
   10              0.000062   endwhile
   11              0.000029   if a:0
   11              0.000155     let current = current . a:comma . strpart(alttail, 0, j-1)
   11              0.000025   endif
   11              0.000042   return current

FUNCTION  436()
Called 2 times
Total time:   0.001556
 Self time:   0.000248

count  total (s)   self (s)
    2              0.000009   let is_force = get(a:000, 0, 0)
                            
                              " everything is loaded, done!
    2              0.000005   if !is_force && self.is_loaded >= 2
                                return
                              endif
                            
                              " Load Order:
                              " 1. (load)  short mru list
                              " 2. (merge) long list on_redraw
    2              0.000012   let mru_file = empty(self.candidates) ? self.mru_file.short : self.mru_file.long
                            
    2              0.000019   if !filereadable(mru_file)
                                return
                              endif
                            
    2              0.000075   let file = readfile(mru_file)
    2              0.000008   if empty(file)
                                return
                              endif
                            
    2              0.000017   let [ver; items] = file
    2   0.000046   0.000015   if !self.version_check(ver)
                                return
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
    2   0.001302   0.000025   call extend(self.candidates, s:convert2candidates(items))
                            
    2              0.000008   if mru_file == self.mru_file.short
    2              0.000013     let self.mtime = getftime(mru_file)
    2              0.000004     let self.is_loaded = 1
    2              0.000004   elseif mru_file == self.mru_file.long
                                let self.is_loaded = 2
                              endif

FUNCTION  <SNR>97_is_excluded_window()
Called 164 times
Total time:   0.018598
 Self time:   0.018598

count  total (s)   self (s)
  164              0.001048   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  656              0.002109   for matchw in g:airline_exclude_filenames
  492              0.007563     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  492              0.000762   endfor
                            
  164              0.000643   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
  164              0.000294   return 0

FUNCTION  296()
Called 96 times
Total time:   0.058528
 Self time:   0.037703

count  total (s)   self (s)
   96              0.000241     let output = ""
   96              0.000153     if a:drawText ==# 1
                            
   90              0.000172         let treeParts = ''
                            
                                    "get all the leading spaces and vertical tree parts for this line
   90              0.000125         if a:depth > 1
   84              0.000158             for j in a:vertMap[0:-2]
   60              0.000095                 if g:NERDTreeDirArrows
   60              0.000155                     let treeParts = treeParts . '  '
   60              0.000043                 else
                                                if j ==# 1
                                                    let treeParts = treeParts . '| '
                                                else
                                                    let treeParts = treeParts . '  '
                                                endif
                                            endif
   60              0.000055             endfor
   24              0.000012         endif
                            
                                    "get the last vertical tree part for this line which will be different
                                    "if this node is the last child of its parent
   90              0.000203         if !g:NERDTreeDirArrows
                                        if a:isLastChild
                                            let treeParts = treeParts . '`'
                                        else
                                            let treeParts = treeParts . '|'
                                        endif
                                    endif
                            
                                    "smack the appropriate dir/file symbol on the line before the file/dir
                                    "name itself
   90              0.000154         if self.path.isDirectory
   48              0.000057             if self.isOpen
   24              0.000030                 if g:NERDTreeDirArrows
   24              0.000064                     let treeParts = treeParts . ' '
   24              0.000015                 else
                                                let treeParts = treeParts . '~'
                                            endif
   24              0.000014             else
   24              0.000036                 if g:NERDTreeDirArrows
   24              0.000065                     let treeParts = treeParts . ' '
   24              0.000025                 else
                                                let treeParts = treeParts . '+'
                                            endif
   24              0.000017             endif
   48              0.000025         else
   42              0.000054             if g:NERDTreeDirArrows
   42              0.000107                 let treeParts = treeParts . '  '
   42              0.000029             else
                                            let treeParts = treeParts . '-'
                                        endif
   42              0.000024         endif
   90   0.001512   0.000484         let line = treeParts . self.displayString()
                            
   90              0.000281         let output = output . line . "\n"
   90              0.000067     endif
                            
                                "if the node is an open dir, draw its children
   96              0.000213     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   30   0.016653   0.000191         let childNodesToDraw = self.getVisibleChildren()
   30              0.000080         if len(childNodesToDraw) > 0
                            
                                        "draw all the nodes children except the last
   30              0.000131             let lastIndx = len(childNodesToDraw)-1
   30              0.000049             if lastIndx > 0
   66              0.000105                 for i in childNodesToDraw[0:lastIndx-1]
   60              0.000642                     let output = output . i._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 1), 0)
   60              0.000056                 endfor
    6              0.000006             endif
                            
                                        "draw the last child, indicating that it IS the last
   30              0.000349             let output = output . childNodesToDraw[lastIndx]._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 0), 1)
   30              0.000021         endif
   30              0.000019     endif
                            
   96              0.000117     return output

FUNCTION  438()
Called 1 time
Total time:   0.000605
 Self time:   0.000605

count  total (s)   self (s)
    1              0.000001   if self.do_validate
    1              0.000600     call filter(self.candidates, 'getftype(v:val.action__path) ==# "file"')
    1              0.000001   endif

FUNCTION  unite#variables#loaded_defaults()
Called 32 times
Total time:   0.000410
 Self time:   0.000410

count  total (s)   self (s)
   32              0.000158   if !exists('s:loaded_defaults')
    1              0.000003     let s:loaded_defaults = {}
    1              0.000000   endif
                            
   32              0.000080   return s:loaded_defaults

FUNCTION  indent_guides#init_matches()
Called 107 times
Total time:   0.001269
 Self time:   0.001269

count  total (s)   self (s)
  107              0.001137   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  nerdtree#putCursorInTreeWin()
Called 4 times
Total time:   0.001292
 Self time:   0.000176

count  total (s)   self (s)
    4   0.000480   0.000038     if !nerdtree#isTreeOpen()
                                    throw "NERDTree.InvalidOperationError: cant put cursor in NERD tree window, no window exists"
                                endif
                            
    4   0.000768   0.000094     call nerdtree#exec(nerdtree#getTreeWinNum() . "wincmd w")

FUNCTION  <SNR>195_msg2list()
Called 6 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    6              0.000037   return type(a:expr) ==# type([]) ? a:expr : split(a:expr, '\n')

FUNCTION  unite#kinds#file#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   return s:kind

FUNCTION  vimproc#parser#split_args()
Called 1 time
Total time:   0.001127
 Self time:   0.000899

count  total (s)   self (s)
    1              0.000021   let script = type(a:script) == type([]) ? a:script : split(a:script, '\zs')
    1              0.000003   let max = len(script)
    1              0.000002   let args = []
    1              0.000001   let arg = ''
    1              0.000001   let i = 0
   18              0.000018   while i < max
   17              0.000033     if script[i] == "'"
                                  " Single quote.
    1   0.000236   0.000008       let [arg_quote, i] = s:parse_single_quote(script, i)
    1              0.000002       let arg .= arg_quote
    1              0.000001       if arg == ''
                                    call add(args, '')
                                  endif
    1              0.000001     elseif script[i] == '"'
                                  " Double quote.
                                  let [arg_quote, i] = s:parse_double_quote(script, i)
                                  let arg .= arg_quote
                                  if arg == ''
                                    call add(args, '')
                                  endif
                                elseif script[i] == '`'
                                  " Back quote.
                                  let head = i > 0 ? script[: i-1] : []
                                  let [arg_quote, i] = s:parse_back_quote(script, i)
                            
                                  " Re-parse script.
                                  return vimproc#parser#split_args( head + split(arg_quote, '\zs') + script[i :])
                                elseif script[i] == '\'
                                  " Escape.
                                  let i += 1
                            
                                  if i >= max
                                    throw 'Exception: Join to next line (\).'
                                  endif
                            
                                  let arg .= script[i]
                                  let i += 1
                                elseif script[i] == '#'
                                  " Comment.
                                  break
                                elseif script[i] != ' '
   11              0.000027       let arg .= script[i]
   11              0.000012       let i += 1
   11              0.000009     else
                                  " Space.
    5              0.000007       if arg != ''
    4              0.000014         call add(args, arg)
    4              0.000002       endif
                            
    5              0.000008       let arg = ''
                            
    5              0.000005       let i += 1
    5              0.000003     endif
   17              0.000010   endwhile
                            
    1              0.000001   if arg != ''
    1              0.000004     call add(args, arg)
    1              0.000001   endif
                            
    1              0.000001   return args

FUNCTION  neosnippet#variables#runtime_dir()
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000008   if !exists('s:runtime_dir')
                                let s:runtime_dir = []
                              endif
                            
    3              0.000004   return s:runtime_dir

FUNCTION  neosnippet#variables#current_neosnippet()
Called 17 times
Total time:   0.000666
 Self time:   0.000666

count  total (s)   self (s)
   17              0.000180   if !exists('b:neosnippet')
    2              0.000037     let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0,}
    2              0.000004   endif
                            
   17              0.000097   return b:neosnippet

FUNCTION  airline#extensions#default#apply()
Called 164 times
Total time:   0.815611
 Self time:   0.017919

count  total (s)   self (s)
  164              0.001090   let winnr = a:context.winnr
  164              0.000863   let active = a:context.active
                            
  164   0.005338   0.002435   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
  103   0.247178   0.001614     call <sid>build_sections(a:builder, a:context, s:layout[0])
  103              0.000114   else
   61   0.009862   0.000950     call a:builder.add_section('airline_c'.(a:context.bufnr), ' %f%m ')
   61              0.000085   endif
                            
  164   0.019115   0.003660   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
  164   0.004055   0.001685   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
  154   0.524752   0.002264     call <sid>build_sections(a:builder, a:context, s:layout[1])
  154              0.000190   endif
                            
  164              0.000302   return 1

FUNCTION  <SNR>81_UpdateErrors()
Called 37 times
Total time:  27.313645
 Self time:   0.009386

count  total (s)   self (s)
   37   0.007764   0.000655     if s:SkipFile()
                                    return
                                endif
                            
   37   0.003502   0.000666     call s:modemap.synch()
   37   0.006171   0.000838     let run_checks = !a:auto_invoked || s:modemap.allowsAutoChecking(&filetype)
   37              0.000163     if run_checks
   37  26.567691   0.001653         call s:CacheErrors(a:000)
   37              0.000179     endif
                            
   37   0.001978   0.000766     let loclist = g:SyntasticLoclist.current()
                            
   37              0.000295     let w:syntastic_loclist_set = 0
   37              0.000307     if g:syntastic_always_populate_loc_list || g:syntastic_auto_jump
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.filteredRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && g:syntastic_auto_jump && loclist.hasErrorsOrWarningsToDisplay()
                                        call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: jump')
                                        silent! lrewind
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype == ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                            
   37   0.722446   0.000715     call s:notifiers.refresh(loclist)

FUNCTION  nerdtree#stripMarkupFromLine()
Called 600 times
Total time:   0.086679
 Self time:   0.081039

count  total (s)   self (s)
  600              0.002996     let line = a:line
                                "remove the tree parts and the leading space
  600   0.020162   0.014522     let line = substitute (line, nerdtree#treeMarkupReg(),"","")
                            
                                "strip off any read only flag
  600              0.007589     let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
  600              0.007178     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
  600              0.007268     let line = substitute (line, '*\ze\($\| \)', "","")
                            
  600              0.002385     let wasdir = 0
  600              0.003305     if line =~# '/$'
  179              0.000569         let wasdir = 1
  179              0.000256     endif
  600              0.006842     let line = substitute (line,' -> .*',"","") " remove link to
  600              0.001862     if wasdir ==# 1
  179              0.002553         let line = substitute (line, '/\?$', '/', "")
  179              0.000308     endif
                            
  600              0.001920     if a:removeLeadingSpaces
  575              0.006232         let line = substitute (line, '^ *', '', '')
  575              0.001031     endif
                            
  600              0.001465     return line

FUNCTION  unite#filters#converter_nothing#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:converter

FUNCTION  SyntasticCheckerMakeprgBuild()
Called 32 times
Total time:   0.026300
 Self time:   0.002069

count  total (s)   self (s)
   32   0.008247   0.001538     let builder = g:SyntasticMakeprgBuilder.New( get(a:opts, 'checker', self), get(a:opts, 'exe', ''), get(a:opts, 'args', ''), get(a:opts, 'fname', ''), get(a:opts, 'post_args', ''), get(a:opts, 'tail', '') )
                            
   32   0.017886   0.000364     return builder.makeprg()

FUNCTION  <SNR>9_expand()
Called 72 times
Total time:   0.002973
 Self time:   0.002266

count  total (s)   self (s)
   72   0.002847   0.002140   return neobundle#util#substitute_path_separator( (a:path =~ '^\~') ? substitute(a:path, '^\~', expand('~'), '') : (a:path =~ '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path)

FUNCTION  indent_guides#disable()
Called 107 times
Total time:   0.006721
 Self time:   0.001394

count  total (s)   self (s)
  107              0.000501   let g:indent_guides_autocmds_enabled = 0
  107   0.006054   0.000727   call indent_guides#clear_matches()

FUNCTION  <SNR>81_QuitPreHook()
Called 1 time
Total time:   0.000212
 Self time:   0.000109

count  total (s)   self (s)
    1   0.000116   0.000069     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: QuitPre, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
    1              0.000018     let b:syntastic_skip_checks = !g:syntastic_check_on_wq
    1   0.000071   0.000015     call g:SyntasticLoclistHide()

FUNCTION  unite#get_self_functions()
Called 4 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    4              0.000180   return split(matchstr(expand('<sfile>'), '^function \zs.*$'), '\.\.')[: -2]

FUNCTION  airline#extensions#tabline#formatters#default()
Called 4752 times
Total time:   0.953744
 Self time:   0.840854

count  total (s)   self (s)
 4752              0.013402   let _ = ''
                            
 4752              0.021751   let name = bufname(a:bufnr)
 4752              0.013899   if empty(name)
                                let _ .= '[No Name]'
                              else
 4752              0.009203     if s:fnamecollapse
 4752              0.667073       let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
 4752              0.008314     else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
 4752              0.004286   endif
                            
 4752   0.163443   0.050553   return s:wrap_name(a:bufnr, _)

FUNCTION  <SNR>191_split()
Called 12 times
Total time:   0.001178
 Self time:   0.001178

count  total (s)   self (s)
   12              0.000088     let [result, pos] = [[], 0]
   25              0.000048     while 1
   25              0.000199       let tmp = stridx(a:str, a:sep, pos)
   25              0.000058       if tmp == -1
   12              0.000099         call add(result, strpart(a:str, pos))
   12              0.000019         break
                                  endif
   13              0.000211       call add(result, strpart(a:str, pos, tmp - pos))
   13              0.000073       let pos = tmp + 1
   13              0.000042     endwhile
                            
   12              0.000026     return result

FUNCTION  unite#util#truncate()
Called 2 times
Total time:   0.000299
 Self time:   0.000040

count  total (s)   self (s)
    2   0.000297   0.000038   return call(unite#util#get_vital().truncate, a:000)

FUNCTION  unite#init#_sources()
Called 3 times
Total time:   0.036391
 Self time:   0.000982

count  total (s)   self (s)
                              " args: source_names or source_definition
                            
                              " Initialize load.
    3              0.000013   if type(get(a:000, 0, [])) != type({})
    3              0.000017     let source_names = type(get(a:000, 0, [])) == type([]) ? get(a:000, 0, []) : []
    3              0.000009     let head_name = get(a:000, 1, '')
    3              0.000010     if empty(source_names) && head_name != ''
    2              0.000005       let source_names = [head_name]
    2              0.000002     endif
    3   0.035317   0.000019     call unite#init#_default_scripts('sources', source_names)
    3              0.000001   endif
                            
    3              0.000030   let default_source = { 'is_volatile' : 0, 'is_listed' : 1, 'is_forced' : 0, 'required_pattern_length' : 0, 'action_table' : {}, 'default_action' : {}, 'default_kind' : 'common', 'alias_table' : {}, 'parents' : [], 'description' : '', 'syntax' : '', }
                            
    3              0.000005   let sources = {}
    3   0.000057   0.000028   let sources = extend(sources, unite#variables#static().sources)
    3   0.000057   0.000024   let sources = extend(sources, unite#variables#dynamic().sources)
    3              0.000014   if type(get(a:000, 0, [])) == type({})
                                let sources[a:1.name] = a:1
                              endif
                            
    3   0.000050   0.000014   let custom = unite#custom#get()
                            
    6              0.000020   for source in type(sources) == type([]) ? sources : values(sources)
    3              0.000003     try
    3              0.000009       if !get(source, 'is_initialized', 0)
    1              0.000003         let source.is_initialized = 1
                            
    1              0.000003         if !has_key(source, 'hooks')
                                      let source.hooks = {}
                                    elseif has_key(source.hooks, 'on_pre_init')
                                      " Call pre_init hook.
                            
                                      " Set dummy value.
                                      let source.args = []
                                      let source.unite__context = { 'source' : source }
                            
                                      " Overwrite source values.
                                      call unite#helper#call_hook([source], 'on_pre_init')
                                    endif
                            
    1              0.000008         let source = extend(source, default_source, 'keep')
                            
    1              0.000003         if !empty(source.action_table)
                                      let action = values(source.action_table)[0]
                            
                                      " Check if '*' action_table?
                                      if has_key(action, 'func') && type(action.func) == type(function('type'))
                                        " Syntax sugar.
                                        let source.action_table = { '*' : source.action_table }
                                      endif
                                    endif
                            
    1              0.000003         if type(source.default_action) == type('')
                                      " Syntax sugar.
                                      let source.default_action = { '*' : source.default_action }
                                    endif
                            
    1              0.000002         if !empty(source.alias_table)
                                      " Check if '*' alias_table?
                                      if type(values(source.alias_table)[0]) == type('')
                                        " Syntax sugar.
                                        let source.alias_table = { '*' : source.alias_table }
                                      endif
                                    endif
    1              0.000002         if source.is_volatile && !has_key(source, 'change_candidates')
                                      let source.change_candidates = source.gather_candidates
                                      call remove(source, 'gather_candidates')
                                    endif
    1              0.000001       endif
                            
                                  " For custom sources.
    3              0.000015       let custom_source = get(custom.sources, source.name, {})
                            
                                  " Set filters.
    3              0.000008       if has_key(custom_source, 'filters')
                                    let source.filters = custom_source.filters
                                  elseif !has_key(source, 'filters') || has_key(custom_source, 'matchers') || has_key(custom_source, 'sorters') || has_key(custom_source, 'converters')
    1   0.000014   0.000009         let matchers = unite#util#convert2list( get(custom_source, 'matchers',   get(source, 'matchers', 'matcher_default')))
    1   0.000012   0.000008         let sorters = unite#util#convert2list( get(custom_source, 'sorters',   get(source, 'sorters', 'sorter_default')))
    1   0.000012   0.000008         let converters = unite#util#convert2list( get(custom_source, 'converters',   get(source, 'converters', 'converter_default')))
    1              0.000005         let source.filters = matchers + sorters + converters
    1              0.000001       endif
                            
    3              0.000031       let source.max_candidates = get(custom_source, 'max_candidates',    get(source, 'max_candidates', 0))
    3              0.000016       let source.ignore_pattern = get(custom_source, 'ignore_pattern',    get(source, 'ignore_pattern', ''))
    3              0.000028       let source.variables = extend(get(custom_source, 'variables', {}),    get(source, 'variables', {}), 'keep')
                            
    3              0.000007       let source.unite__len_candidates = 0
    3              0.000006       let source.unite__orig_len_candidates = 0
    3              0.000006       let source.unite__candidates = []
    3              0.000003     catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error( '[unite.vim] Error occured in source initialization!')
                                  call unite#print_error( '[unite.vim] Source name is ' . source.name)
                                endtry
    3              0.000003   endfor
                            
    3              0.000004   return sources

FUNCTION  <SNR>130_displayHelp()
Called 5 times
Total time:   0.035375
 Self time:   0.000118

count  total (s)   self (s)
    5              0.000038     let b:treeShowHelp = b:treeShowHelp ? 0 : 1
    5   0.034938   0.000043     call nerdtree#renderView()
    5   0.000393   0.000031     call nerdtree#centerView()

FUNCTION  190()
Called 230 times
Total time:   0.004073
 Self time:   0.004073

count  total (s)   self (s)
  230              0.000720     if empty(self.pathSegments)
                                    return ''
                                endif
  230              0.000979     let toReturn = self.pathSegments[-1]
  230              0.000569     if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
  230              0.000354     return toReturn

FUNCTION  unite#variables#enable_current_unite()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   let s:use_current_unite = 1

FUNCTION  193()
Called 1 time
Total time:   0.000271
 Self time:   0.000225

count  total (s)   self (s)
    1   0.000065   0.000019     if self.getLastPathComponent(0) =~# '^\.'
                                    return 1
                                else
   11              0.000043         for segment in self.pathSegments
   10              0.000063             if segment =~# '^\.'
                                            return 1
                                        endif
   10              0.000026         endfor
    1              0.000003         return 0
                                endif

FUNCTION  335()
Called 2 times
Total time:   0.004543
 Self time:   0.000101

count  total (s)   self (s)
    2   0.002009   0.000023     if !nerdtree#isWindowUsable(winnr("#")) && nerdtree#firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
    2              0.000004         try
    2   0.001851   0.000019             if !nerdtree#isWindowUsable(winnr("#"))
                                            call nerdtree#exec(nerdtree#firstUsableWindow() . "wincmd w")
                                        else
    2   0.000638   0.000014                 call nerdtree#exec('wincmd p')
    2              0.000002             endif
    2              0.000002         catch /^Vim\%((\a\+)\)\=:E37/
                                        call nerdtree#putCursorInTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    2              0.000001     endif

FUNCTION  195()
Called 180 times
Total time:   0.009787
 Self time:   0.006742

count  total (s)   self (s)
  180              0.000564     let pat = a:pattern
  180              0.001022     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
  180   0.004512   0.001467     return self.getLastPathComponent(0) =~# pat

FUNCTION  unite#init#_candidates_source()
Called 1 time
Total time:   0.000079
 Self time:   0.000045

count  total (s)   self (s)
    1   0.000042   0.000008   let source = unite#variables#loaded_sources(a:source_name)
                            
    1              0.000007   let default_candidate = { 'kind' : source.default_kind, 'is_dummy' : 0, 'is_matched' : 1, 'is_multiline' : 0, 'unite__is_marked' : 0, }
                            
    1              0.000002   let candidates = []
    2              0.000004   for candidate in a:candidates
    1              0.000006     let candidate = extend(candidate, default_candidate, 'keep')
    1              0.000003     let candidate.source = a:source_name
                            
    1              0.000004     call add(candidates, candidate)
    1              0.000001   endfor
                            
    1              0.000001   return candidates

FUNCTION  nerdtree#getTreeWinNum()
Called 28 times
Total time:   0.002883
 Self time:   0.002883

count  total (s)   self (s)
   28              0.000244     if exists("t:NERDTreeBufName")
   28              0.002577         return bufwinnr(t:NERDTreeBufName)
                                else
                                    return -1
                                endif

FUNCTION  200()
Called 1252 times
Total time:   0.018503
 Self time:   0.006441

count  total (s)   self (s)
 1252   0.017873   0.005811     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  201()
Called 96 times
Total time:   0.005676
 Self time:   0.005676

count  total (s)   self (s)
   96              0.001617     let tmp = resolve(a:path)
   96              0.003942     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  202()
Called 56 times
Total time:   0.019555
 Self time:   0.008829

count  total (s)   self (s)
   56   0.002670   0.000404     call self.extractDriveLetter(a:fullpath)
                            
   56   0.001630   0.000504     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   56              0.000650     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   56              0.000751     let self.pathSegments = split(fullpath, '/')
                            
   56              0.000299     let self.isReadOnly = 0
   56              0.000396     if isdirectory(a:fullpath)
   32              0.000143         let self.isDirectory = 1
   32              0.000069     elseif filereadable(a:fullpath)
   16              0.000130         let self.isDirectory = 0
   16              0.000271         let self.isReadOnly = filewritable(a:fullpath) ==# 0
   16              0.000032     else
    8             18.055775         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   48              0.000228     let self.isExecutable = 0
   48              0.000102     if !self.isDirectory
   16              0.000212         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   16              0.000029     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   48   0.001394   0.000427     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   48   0.003886   0.000605     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   48   0.003774   0.000688     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   48              0.000101     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  208()
Called 2 times
Total time:   0.000327
 Self time:   0.000126

count  total (s)   self (s)
    2   0.000203   0.000038     let p = escape(self.str({'format': 'UI'}), nerdtree#escChars())
    2   0.000040   0.000018     let cwd = getcwd() . s:Path.Slash()
                            
                                "return a relative path if we can
    2              0.000005     let isRelative = 0
    2   0.000022   0.000008     if nerdtree#runningWindows()
                                    let isRelative = stridx(tolower(p), tolower(cwd)) == 0
                                else
    2              0.000008         let isRelative = stridx(p, cwd) == 0
    2              0.000002     endif
                            
    2              0.000002     if isRelative
    2              0.000009         let p = strpart(p, strlen(cwd))
                            
                                    "handle the edge case where the file begins with a + (vim interprets
                                    "the +foo in `:e +foo` as an option to :edit)
    2              0.000006         if p[0] == "+"
                                        let p = '\' . p
                                    endif
    2              0.000002     endif
                            
    2              0.000002     if p ==# ''
                                    let p = '.'
                                endif
                            
    2              0.000002     return p

FUNCTION  348()
Called 3 times
Total time:   0.100412
 Self time:   0.001235

count  total (s)   self (s)
                                "create the nerd tree window
    3              0.000046     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    3              0.000025     let splitSize = g:NERDTreeWinSize
                            
    3              0.000029     if !exists('t:NERDTreeBufName')
                                    let t:NERDTreeBufName = self._nextBufferName()
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' new'
                                    silent! exec "edit " . t:NERDTreeBufName
                                else
    3   0.048070   0.000828         silent! exec splitLocation . 'vertical ' . splitSize . ' split'
    3   0.018364   0.000163         silent! exec "buffer " . t:NERDTreeBufName
    3              0.000003     endif
                            
    3              0.000016     setlocal winfixwidth
    3   0.033752   0.000018     call self._setCommonBufOptions()

FUNCTION  neosnippet#view#_on_insert_leave()
Called 43 times
Total time:   0.003281
 Self time:   0.001937

count  total (s)   self (s)
   43   0.002297   0.000953   let expand_stack = neosnippet#variables#expand_stack()
                            
                              " Get patterns and count.
   43              0.000525   if empty(expand_stack) || neosnippet#variables#current_neosnippet().trigger
   43              0.000106     return
                              endif
                            
                              let expand_info = expand_stack[-1]
                            
                              if expand_info.begin_line != expand_info.end_line
                                return
                              endif
                            
                              " Search patterns.
                              let [begin, end] = s:get_snippet_range( expand_info.begin_line, expand_info.begin_patterns, expand_info.end_line, expand_info.end_patterns)
                            
                              let pos = getpos('.')
                            
                              " Found snippet.
                              let found = 0
                              try
                                while s:search_snippet_range(begin, end, expand_info.holder_cnt, 0)
                                  " Next count.
                                  let expand_info.holder_cnt += 1
                                  let found = 1
                                endwhile
                            
                                " Search placeholder 0.
                                if s:search_snippet_range(begin, end, 0)
                                  let found = 1
                                endif
                              finally
                                if found
                                  stopinsert
                                endif
                            
                                call setpos('.', pos)
                              endtry

FUNCTION  <SNR>128_Init()
Called 5469 times
Total time:   0.033906
 Self time:   0.033906

count  total (s)   self (s)
 5469              0.019215     if s:checked_ctags == 2 && a:silent
 5469              0.007071         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                return 1

FUNCTION  <SNR>186__get_module_path()
Called 11 times
Total time:   0.006475
 Self time:   0.005905

count  total (s)   self (s)
   11   0.000135   0.000084   if s:_is_absolute_path(a:name) && filereadable(a:name)
                                return s:_unify_path(a:name)
                              endif
   11              0.000018   if a:name ==# ''
    2              0.000013     let tailpath = printf('autoload/vital/%s.vim', s:self_version)
    2              0.000002   elseif a:name =~# '\v^\u\w*%(\.\u\w*)*$'
    9              0.000103     let target = '/' . substitute(a:name, '\W\+', '/', 'g')
    9              0.000072     let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
    9              0.000011   else
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                            
   11              0.000020   if s:globpath_third_arg
   11              0.004798     let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
   11              0.000021   else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
   11              0.000308   call filter(paths, 'filereadable(v:val)')
   11   0.000646   0.000127   return s:_unify_path(get(paths, 0, ''))

FUNCTION  <SNR>191_read()
Called 2 times
Total time:   0.013278
 Self time:   0.000256

count  total (s)   self (s)
    2              0.000007   if self.__eof
                                let self.eof = 1
                                return ''
                              endif
                            
    2              0.000013   let number = get(a:000, 0, -1)
    2              0.000013   let timeout = get(a:000, 1, s:read_timeout)
    2   0.012844   0.000050   let [hd, eof] = self.f_read(number, timeout)
    2              0.000021   let self.eof = eof
    2              0.000016   let self.__eof = eof
                            
    2              0.000013   if hd == ''
    1              0.000002     return ''
                              endif
                            
                              " Note: if output string is too long, if_lua is too slow.
    1   0.000308   0.000080   return (vimproc#util#has_lua() && len(hd) < 1024) ? s:hd2str_lua([hd]) : s:hd2str([hd])
                              " return s:hd2str([hd])

FUNCTION  sy#stop()
Called 2 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    2              0.000098   let bvars = getbufvar(a:bnum, '')
    2              0.000006   if empty(bvars) || !has_key(bvars, 'sy')
    2              0.000001     return
                              endif
                            
                              call sy#sign#remove_all(a:bnum)
                            
                              augroup signify
                                execute 'autocmd! * <buffer='. a:bnum .'>'
                              augroup END

FUNCTION  unite#util#get_name()
Called 20 times
Total time:   0.000505
 Self time:   0.000220

count  total (s)   self (s)
   20   0.000494   0.000209   return get(a:list, unite#util#index_name(a:list, a:name), a:default)

FUNCTION  unite#init#_candidates()
Called 6 times
Total time:   0.001837
 Self time:   0.001551

count  total (s)   self (s)
    6   0.000142   0.000045   let unite = unite#get_current_unite()
    6              0.000022   let context = unite.context
    6   0.000238   0.000100   let [max_width, max_source_name] = unite#helper#adjustments(winwidth(0)-5, unite.max_source_name, 2)
    6              0.000020   let is_multiline = 0
                            
    6              0.000019   let candidates = []
    8              0.000028   for candidate in a:candidates
    2              0.000023     let candidate.unite__abbr = get(candidate, 'abbr', candidate.word)
                            
                                " Delete too long abbr.
    2              0.000016     if !&l:wrap && (candidate.is_multiline || context.multi_line)
    1              0.000006       let candidate.unite__abbr = candidate.unite__abbr[: max_width *  (context.max_multi_lines + 1)+10]
    1              0.000003     elseif len(candidate.unite__abbr) > max_width * 2 && !context.wrap
                                  let candidate.unite__abbr = candidate.unite__abbr[: max_width * 2]
                                endif
                            
                                " Substitute tab.
    2              0.000023     if candidate.unite__abbr =~ '\t'
                                  let candidate.unite__abbr = substitute( candidate.unite__abbr, '\t', repeat(' ', &tabstop), 'g')
                                endif
                            
    2              0.000011     if context.wrap || (!candidate.is_multiline && !context.multi_line)
    1              0.000017       call add(candidates, candidate)
    1              0.000006       continue
                                endif
                            
    1              0.000003     if candidate.unite__abbr !~ '\n'
                                  " Auto split.
    1              0.000002       let abbr = candidate.unite__abbr
    1              0.000002       let candidate.unite__abbr = ''
                            
    2              0.000008       while abbr !~ '^\s\+$'
    1   0.000062   0.000011         let trunc_abbr = unite#util#strwidthpart( abbr, max_width)
    1              0.000004         let candidate.unite__abbr .= trunc_abbr . "~\n"
    1              0.000005         let abbr = '  ' . abbr[len(trunc_abbr):]
    1              0.000001       endwhile
                            
    1              0.000008       let candidate.unite__abbr = substitute(candidate.unite__abbr,    '\~\n$', '', '')
    1              0.000001     else
                                  let candidate.unite__abbr = substitute(candidate.unite__abbr,    '\r\?\n$', '^@', '')
                                endif
                            
    1              0.000003     if candidate.unite__abbr !~ '\n'
    1              0.000002       let candidate.is_multiline = 0
    1              0.000005       call add(candidates, candidate)
    1              0.000003       continue
                                endif
                            
                                " Convert multi line.
                                let cnt = 0
                                for multi in split( candidate.unite__abbr, '\r\?\n', 1)[:   context.max_multi_lines-1]
                                  let candidate_multi = (cnt != 0) ? deepcopy(candidate) : candidate
                                  let candidate_multi.unite__abbr = (cnt == 0 ? '+ ' : '| ') . multi
                            
                                  if cnt != 0
                                    let candidate_multi.is_dummy = 1
                                  endif
                            
                                  let is_multiline = 1
                                  call add(candidates, candidate_multi)
                            
                                  let cnt += 1
                                endfor
                              endfor
                            
                              " Multiline check.
    6              0.000024   if is_multiline || context.multi_line
                                for candidate in filter(copy(candidates), '!v:val.is_multiline')
                                  let candidate.unite__abbr = '  ' . candidate.unite__abbr
                                endfor
                            
                                let unite.is_multi_line = 1
                              endif
                            
    6              0.000013   return candidates

FUNCTION  unite#sources#mru#variables#get_mrus()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   return a:type ==# 'file' ? s:mru_files : s:mru_directories

FUNCTION  <SNR>197_which()
Called 1 time
Total time:   0.000642
 Self time:   0.000423

count  total (s)   self (s)
    1              0.000021   let pathlist = a:command =~# s:path_sep_pattern ? [''] :              !a:0                  ? split($PATH, s:path_separator) :              type(a:1) == type([]) ? copy(a:1) :                                      split(a:1, s:path_separator)
    1   0.000195   0.000009   let pathlist = vimproc#util#uniq(pathlist)
                            
    1   0.000032   0.000007   let pathext = s:path_extensions()
    1              0.000007   if index(pathext, '.' . tolower(fnamemodify(a:command, ':e'))) != -1
                                let pathext = ['']
                              endif
                            
    1   0.000011   0.000006   let dirsep = s:separator()
    8              0.000010   for dir in pathlist
    8              0.000024     let head = dir ==# '' ? '' : dir . dirsep
   15              0.000016     for ext in pathext
    8              0.000047       let full = fnamemodify(head . a:command . ext, ':p')
    8              0.000027       if getftype(full) ==# 'link' && s:is_windows
                                    let full = resolve(full)
                                  endif
                            
    8              0.000021       if executable(full)
    1   0.000009   0.000006         if s:is_case_tolerant()
                                      let full = glob(substitute(               vimproc#util#substitute_path_separator( toupper(full)), '\u:\@!', '[\0\L\0]', 'g'), 1)
                                    endif
    1              0.000002         if full != ''
    1              0.000001           return full
                                    endif
                                  endif
    7              0.000004     endfor
    7              0.000004   endfor
                            
                              return ''

FUNCTION  210()
Called 618 times
Total time:   0.039849
 Self time:   0.015896

count  total (s)   self (s)
  618   0.012688   0.003343     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
  618   0.008820   0.003028     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
  618   0.014701   0.005885     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  211()
Called 48 times
Total time:   0.000691
 Self time:   0.000691

count  total (s)   self (s)
   48              0.000648     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  213()
Called 56 times
Total time:   0.001126
 Self time:   0.000494

count  total (s)   self (s)
   56   0.000919   0.000287     if !nerdtree#runningWindows()
   56              0.000145         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>24_LoadIndent()
Called 8 times
Total time:   0.002888
 Self time:   0.002468

count  total (s)   self (s)
    8              0.000037     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    8              0.000040     let s = expand("<amatch>")
    8              0.000019     if s != ""
    8              0.000023       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   16              0.000074       for name in split(s, '\.')
    8   0.002536   0.002116 	exe 'runtime! indent/' . name . '.vim'
    8              0.000020       endfor
    8              0.000008     endif

FUNCTION  <SNR>196_parse_tilde()
Called 1 time
Total time:   0.001204
 Self time:   0.000388

count  total (s)   self (s)
    1              0.000002   let script = ''
                            
    1              0.000001   let i = 0
    1              0.000003   let max = len(a:script)
   18              0.000021   while i < max
   17              0.000050     if a:script[i] == ' ' && a:script[i+1] == '~'
                                  " Tilde.
                                  " Expand home directory.
                                  let script .= ' ' . escape(substitute($HOME, '\\', '/', 'g'), '\ ')
                                  let i += 2
                            
                                elseif i == 0 && a:script[i] == '~'
                                  " Tilde.
                                  " Expand home directory.
                                  let script .= escape(substitute($HOME, '\\', '/', 'g'), '\ ')
                                  let i += 1
                                else
   17   0.000921   0.000105       let [script, i] = s:skip_else(script, a:script, i)
   17              0.000012     endif
   17              0.000011   endwhile
                            
    1              0.000001   return script

FUNCTION  unite#util#truncate_wrap()
Called 2 times
Total time:   0.000443
 Self time:   0.000058

count  total (s)   self (s)
    2   0.000111   0.000025   let width = unite#util#wcswidth(a:str)
    2              0.000008   if width <= a:max
    2   0.000321   0.000022     return unite#util#truncate(a:str, a:max)
                              elseif &l:wrap
                                return a:str
                              endif
                            
                              let header_width = a:max - unite#util#wcswidth(a:separator) - a:footer_width
                              return unite#util#strwidthpart(a:str, header_width) . a:separator . unite#util#strwidthpart_reverse(a:str, a:footer_width)

FUNCTION  unite#variables#kinds()
Called 22 times
Total time:   0.036555
 Self time:   0.000768

count  total (s)   self (s)
   22              0.000054   if a:0 == 0
                                call unite#init#_default_scripts('kinds', [])
                              else
   22   0.033590   0.000195     call unite#init#_default_scripts('kinds', [a:1])
   22              0.000023   endif
                            
   22   0.002588   0.000196   let kinds = unite#init#_kinds()
   22              0.000130   return (a:0 == 0) ? kinds : get(kinds, a:1, {})

FUNCTION  361()
Called 1 time
Total time:   0.034083
 Self time:   0.000181

count  total (s)   self (s)
    1   0.000013   0.000010   let variables = unite#get_source_variables(a:context)
    1              0.000018   if !executable(variables.command)
                                call unite#print_source_message(printf( 'command "%s" is not executable.',    variables.command), s:source.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
    1   0.000033   0.000003   if !unite#util#has_vimproc()
                                call unite#print_source_message( 'vimproc plugin is not installed.', self.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
    1              0.000004   if empty(a:context.source__target) || a:context.source__input == ''
                                call unite#print_source_message('Canceled.', s:source.name)
                                let a:context.is_async = 0
                                return []
                              endif
                            
    1              0.000002   if a:context.is_redraw
                                let a:context.is_async = 1
                              endif
                            
    1   0.000028   0.000026   let cmdline = printf('%s %s %s %s %s %s',   unite#util#substitute_path_separator(variables.command),   variables.default_opts,   variables.recursive_opt,   a:context.source__extra_opts,   string(a:context.source__input),   join(map(a:context.source__target,           "substitute(v:val, '/$', '', '')")),)
    1              0.000002   if a:context.source__ssh_path != ''
                                " Use ssh command.
                                let [hostname, port, path] = unite#sources#ssh#parse_path(a:context.source__ssh_path)
                                let cmdline = substitute(substitute( g:unite_kind_file_ssh_command . ' ' . cmdline,   '\<HOSTNAME\>', hostname, 'g'), '\<PORT\>', port, 'g')
                              endif
                            
    1   0.009295   0.000010   call unite#print_source_message('Command-line: ' . cmdline, s:source.name)
                            
    1              0.000004   let save_term = $TERM
    1              0.000002   try
                                " Disable colors.
    1              0.000007     let $TERM = 'dumb'
                            
    1   0.010390   0.000027     let a:context.source__proc = vimproc#plineopen3( vimproc#util#iconv(cmdline, &encoding, 'char'), 1)
    1              0.000002   finally
    1              0.000010     let $TERM = save_term
    1              0.000001   endtry
                            
    1   0.014235   0.000016   return self.async_gather_candidates(a:args, a:context)

FUNCTION  unite#helper#get_source_names()
Called 3 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    3              0.000052   return map(map(copy(a:sources), "type(v:val) == type([]) ? v:val[0] : v:val"), "type(v:val) == type('') ? v:val : v:val.name")

FUNCTION  fugitive#is_git_dir()
Called 32853 times
Total time:   0.954625
 Self time:   0.596331

count  total (s)   self (s)
32853   0.629913   0.271619   let path = s:sub(a:path, '[\/]$', '') . '/'
32853              0.286115   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10

FUNCTION  <SNR>191_vp_dlclose()
Called 1 time
Total time:   0.000146
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000145   0.000007   call s:libcall('vp_dlclose', [a:handle])

FUNCTION  airline#extensions#branch#head()
Called 5469 times
Total time:   5.125159
 Self time:   0.453025

count  total (s)   self (s)
 5469              0.015952   let head = ''
                            
 5469              0.031208   if s:has_fugitive && !exists('b:mercurial_dir')
 5469   0.069602   0.034807     let head = fugitive#head()
                            
 5469              0.037511     if empty(head) && s:has_fugitive_detect && !exists('b:git_dir')
 5469   4.680363   0.075915       call fugitive#detect(getcwd())
 5469   0.074524   0.041633       let head = fugitive#head()
 5469              0.006156     endif
 5469              0.004936   endif
                            
 5469              0.015295   if empty(head)
 5469              0.011031     if s:has_lawrencium
                                  let head = lawrencium#statusline()
                                endif
 5469              0.004476   endif
                            
 5469              0.012579   if empty(head)
 5469              0.009443     if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
 5469              0.004523   endif
                            
 5469              0.030251   return empty(head) || !s:check_in_path() ? '' : head

FUNCTION  unite#start()
Called 1 time
Total time:   0.188089
 Self time:   0.000837

count  total (s)   self (s)
    1   0.188086   0.000834   return call('unite#start#standard', a:000)

FUNCTION  syntastic#log#debugDump()
Called 37 times
Total time:   0.001019
 Self time:   0.000692

count  total (s)   self (s)
   37   0.000754   0.000427     if !s:isDebugEnabled(a:level)
   37              0.000081         return
                                endif
                            
                                call syntastic#log#debugShowVariables(a:level, s:global_options)

FUNCTION  <SNR>195_clear_previewed_buffer_list()
Called 1 time
Total time:   0.000050
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000033   0.000009   let unite = unite#get_current_unite()
    1              0.000005   for bufnr in unite.previewd_buffer_list
                                if buflisted(bufnr)
                                  silent execute 'bdelete!' bufnr
                                endif
                              endfor
                            
    1              0.000004   let unite.previewd_buffer_list = []

FUNCTION  unite#handlers#_on_insert_enter()
Called 1 time
Total time:   0.000023
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000015   0.000005   let unite = unite#get_current_unite()
    1              0.000002   let unite.is_insert = 1
                            
    1              0.000002   if &filetype ==# 'unite'
    1              0.000002     setlocal modifiable
    1              0.000001   endif

FUNCTION  neosnippet#init#check()
Called 59 times
Total time:   0.001312
 Self time:   0.001312

count  total (s)   self (s)
   59              0.000682   if !exists('s:is_initialized')
                                call neosnippet#init#_initialize()
                              endif

FUNCTION  syntastic#util#wideMsg()
Called 45 times
Total time:   0.461586
 Self time:   0.009670

count  total (s)   self (s)
   45              0.000403     let old_ruler = &ruler
   45              0.000349     let old_showcmd = &showcmd
                            
                                "convert tabs to spaces so that the tabs count towards the window width
                                "as the proper amount of characters
   45              0.001091     let msg = substitute(a:msg, "\t", repeat(" ", &tabstop), "g")
   45              0.000614     let msg = strpart(msg, 0, winwidth(0)-1)
                            
                                "This is here because it is possible for some error messages to begin with
                                "\n which will cause a "press enter" prompt. I have noticed this in the
                                "javascript:jshint checker and have been unable to figure out why it
                                "happens
   45              0.000824     let msg = substitute(msg, "\n", "", "g")
                            
   45              0.000718     set noruler noshowcmd
   45   0.452501   0.000585     call syntastic#util#redraw(0)
                            
   45              0.003435     echo msg
                            
   45              0.000481     let &ruler=old_ruler
   45              0.000320     let &showcmd=old_showcmd

FUNCTION  unite#sources#grep#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  SkipJavaBlanksAndComments()
Called 193 times
Total time:   0.020235
 Self time:   0.020235

count  total (s)   self (s)
  193              0.001433   let lnum = a:startline
  211              0.001063   while lnum > 1
  194              0.001677     let lnum = prevnonblank(lnum)
  194              0.002490     if getline(lnum) =~ '\*/\s*$'
                                  while getline(lnum) !~ '/\*' && lnum > 1
                                    let lnum = lnum - 1
                                  endwhile
                                  if getline(lnum) =~ '^\s*/\*'
                                    let lnum = lnum - 1
                                  else
                                    break
                                  endif
                                elseif getline(lnum) =~ '^\s*//'
   18              0.000123       let lnum = lnum - 1
   18              0.000039     else
  176              0.000445       break
                                endif
   18              0.000049   endwhile
  193              0.000679   return lnum

FUNCTION  238()
Called 150 times
Total time:   0.007181
 Self time:   0.007181

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
  150              0.000476     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  150              0.000965     if self.key =~# specialNotationRegex
   24              0.000302         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
   24              0.000025     else
  126              0.000310         let keymapInvokeString = self.key
  126              0.000079     endif
                            
  150              0.000416     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
  150              0.003435     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  unite#view#_print_source_message()
Called 2 times
Total time:   0.021170
 Self time:   0.000053

count  total (s)   self (s)
    2   0.021168   0.000051   call unite#view#_print_message( map(copy(s:msg2list(a:message)),    "printf('[%s] %s', a:source_name, v:val)"))

FUNCTION  236()
Called 35 times
Total time:   0.008301
 Self time:   0.007949

count  total (s)   self (s)
 1145   0.001905   0.001553     for i in s:KeyMap.All()
 1127              0.003111          if i.key ==# a:key && i.scope ==# a:scope
   17              0.000029             return i
                                    endif
 1110              0.000960     endfor
   18              0.000023     return {}

FUNCTION  airline#parts#mode()
Called 5477 times
Total time:   0.035405
 Self time:   0.035405

count  total (s)   self (s)
 5477              0.029506   return get(w:, 'airline_current_mode', '')

FUNCTION  435()
Called 2 times
Total time:   0.010368
 Self time:   0.001283

count  total (s)   self (s)
    2              0.000008   let opts = {}
    2   0.000024   0.000015   if a:0 >= 1 && s:V.is_dict(a:1)
    2              0.000012     call extend(opts, a:1)
    2              0.000002   endif
                            
                              " should load all candidates
    2   0.001574   0.000018   call self.load(1)
                            
    2   0.000081   0.000072   let self.candidates = unite#sources#mru#variables#get_mrus(self.type) + self.candidates
    2   0.000054   0.000016   call unite#sources#mru#variables#clear(self.type)
                            
    2              0.000005   if empty(self.candidates)
                                " nothing to save, mru is not loaded
                                return
                              endif
                            
    2   0.000041   0.000021   if self.has_external_update() && filereadable(self.mru_file.short)
                                " only need to get the short list which contains the latest MRUs
                                let [ver; items] = readfile(self.mru_file.short)
                                if self.version_check(ver)
                                  let self.candidates = s:L.uniq(extend(self.candidates, s:convert2candidates(items)), 'v:val.action__path')
                                endif
                              endif
                            
    2              0.000007   if get(opts, 'event') ==# 'VimLeavePre'
    2   0.001116   0.000010     call self.validate()
    2              0.000002   endif
                            
    2   0.006176   0.000201   let self.candidates = s:L.uniq(self.candidates, 'v:val.action__path')
                            
    2   0.001159   0.000787   call writefile([self.version] + map(copy( self.candidates[: self.limit.short - 1]), 'join(s:convert2list(v:val), "\t")'), self.mru_file.short)
                            
    2              0.000012   if len(self.candidates) > self.limit.short
                                call writefile([self.version] + map(copy( self.candidates[self.limit.short : self.limit.long - 1]), 'join(s:convert2list(v:val), "\t")'), self.mru_file.long)
                                let self.mtime = getftime(self.mru_file.long)
                              else
    2              0.000013     let self.mtime = getftime(self.mru_file.short)
    2              0.000003   endif

FUNCTION  <SNR>55_savetofile()
Called 5 times
Total time:   0.001991
 Self time:   0.000083

count  total (s)   self (s)
    5   0.001985   0.000077 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  439()
Called 1 time
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
    1              0.000002   if self.do_validate
    1              0.000497     call filter(self.candidates, 'getftype(v:val.action__path) ==# "dir"')
    1              0.000001   endif

FUNCTION  <SNR>212_best_winline()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000013   return max([1, winheight(0) * g:unite_kind_jump_list_after_jump_scroll / 100])

FUNCTION  <SNR>142_convert2dictionary()
Called 121 times
Total time:   0.001980
 Self time:   0.001980

count  total (s)   self (s)
  121              0.001822   return { 'word' : a:list[0], 'source__time' : str2nr(a:list[1]), 'action__path' : a:list[0], }

FUNCTION  unite#filters#matcher_regexp#define()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   return s:matcher

FUNCTION  sy#repo#get_stats()
Called 5469 times
Total time:   0.078880
 Self time:   0.078880

count  total (s)   self (s)
 5469              0.039404   if !exists('b:sy') || !has_key(b:sy, 'stats')
  326              0.001162     return [-1, -1, -1]
                              endif
                            
 5143              0.011927   return b:sy.stats

FUNCTION  airline#extensions#quickfix#apply()
Called 102 times
Total time:   0.002599
 Self time:   0.002599

count  total (s)   self (s)
  102              0.000733   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>148_XmlIndentSum()
Called 174 times
Total time:   0.015307
 Self time:   0.008423

count  total (s)   self (s)
  174              0.001142     let line = getline(a:lnum)
  174              0.001923     if a:style == match(line, '^\s*</')
   85   0.010258   0.003374 	return (&sw *  (<SID>XmlIndentWithPattern(line, b:xml_indent_open) - <SID>XmlIndentWithPattern(line, b:xml_indent_close) - <SID>XmlIndentWithPattern(line, '.\{-}/>'))) + a:add
                                else
   89              0.000207 	return a:add
                                endif

FUNCTION  <SNR>125_wrap_name()
Called 4752 times
Total time:   0.112890
 Self time:   0.112890

count  total (s)   self (s)
 4752              0.028563   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
 4752              0.017667   let _ .= a:buffer_name
 4752              0.027944   if getbufvar(a:bufnr, '&modified') == 1
 2064              0.008993     let _ .= s:buf_modified_symbol
 2064              0.002191   endif
 4752              0.007530   return _

FUNCTION  unite#helper#get_marked_candidates()
Called 2 times
Total time:   0.000574
 Self time:   0.000133

count  total (s)   self (s)
    2   0.000571   0.000130   return unite#util#sort_by(filter(copy(unite#get_unite_candidates()), 'v:val.unite__is_marked'), 'v:val.unite__marked_time')

FUNCTION  vimproc#util#uniq()
Called 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    1              0.000008   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
    1              0.000002   let i = 0
    1              0.000001   let seen = {}
   11              0.000021   while i < len(list)
   10              0.000044     let key = string(a:0 ? list[i][1] : list[i])
   10              0.000023     if has_key(seen, key)
                                  call remove(list, i)
                                else
   10              0.000021       let seen[key] = 1
   10              0.000014       let i += 1
   10              0.000006     endif
   10              0.000008   endwhile
    1              0.000003   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  <SNR>187_is_dict()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000013   return type(a:Value) ==# s:__TYPE_DICT

FUNCTION  235()
Called 41 times
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
   41              0.000178     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
   41              0.000070     return s:keyMaps

FUNCTION  237()
Called 3 times
Total time:   0.008196
 Self time:   0.000991

count  total (s)   self (s)
  153   0.000224   0.000200     for i in s:KeyMap.All()
  150   0.007772   0.000591         call i.bind()
  150              0.000149     endfor

FUNCTION  <SNR>38_diff_window_count()
Called 36 times
Total time:   0.001698
 Self time:   0.001698

count  total (s)   self (s)
   36              0.000185   let c = 0
   97              0.000520   for nr in range(1,winnr('$'))
   61              0.000439     let c += getwinvar(nr,'&diff')
   61              0.000109   endfor
   36              0.000091   return c

FUNCTION  <SNR>123_get_string()
Called 1 time
Total time:   0.020064
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000008   if !exists('s:String')
    1   0.020051   0.000027     let s:String = unite#util#get_vital().import('Data.String')
    1              0.000001   endif
    1              0.000001   return s:String

FUNCTION  unite#sources#alias#define()
Called 1 time
Total time:   0.000089
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000088   0.000008   return s:make_aliases()

FUNCTION  <SNR>197_path_extensions()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   if !exists('s:path_extensions')
    1              0.000001     if s:is_windows
                                  if exists('$PATHEXT')
                                    let pathext = $PATHEXT
                                  else
                                    " get default PATHEXT
                                    let pathext = matchstr(system('set pathext'), '^pathext=\zs.*\ze\n', 'i')
                                  endif
                                  let s:path_extensions = map(split(pathext, s:path_separator), 'tolower(v:val)')
                                elseif s:is_cygwin
                                  " cygwin is not use $PATHEXT
                                  let s:path_extensions = ['', '.exe']
                                else
    1              0.000003       let s:path_extensions = ['']
    1              0.000001     endif
    1              0.000000   endif
    1              0.000002   return s:path_extensions

FUNCTION  unite#helper#get_source_args()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000026   return map(copy(a:sources), 'type(v:val) == type([]) ? [v:val[0], v:val[1:]] : [v:val, []]')

FUNCTION  <SNR>219_convert2candidates()
Called 2 times
Total time:   0.001277
 Self time:   0.000534

count  total (s)   self (s)
    2              0.000004   try
    2   0.001259   0.000516     return map(a:items, 's:convert2dictionary(split(v:val, "\t"))')
                              catch
                                call unite#util#print_error('Sorry, MRU file is invalid.')
                                return []
                              endtry

FUNCTION  nerdtree#checkForBrowse()
Called 55 times
Total time:   0.000877
 Self time:   0.000877

count  total (s)   self (s)
   55              0.000488     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif

FUNCTION  <SNR>148_XmlIndentSynCheck()
Called 174 times
Total time:   0.051555
 Self time:   0.051555

count  total (s)   self (s)
  174              0.001097     if '' != &syntax
  174              0.024693 	let syn1 = synIDattr(synID(a:lnum, 1, 1), 'name')
  174              0.020037 	let syn2 = synIDattr(synID(a:lnum, strlen(getline(a:lnum)) - 1, 1), 'name')
  174              0.001876 	if '' != syn1 && syn1 !~ 'xml' && '' != syn2 && syn2 !~ 'xml'
                            	    " don't indent pure non-xml code
                            	    return 0
                            	elseif syn1 =~ '^xmlComment' && syn2 =~ '^xmlComment'
                            	    " indent comments specially
                            	    return -1
                            	endif
  174              0.000233     endif
  174              0.000266     return 1

FUNCTION  <SNR>191_hd2str()
Called 1 time
Total time:   0.000167
 Self time:   0.000041

count  total (s)   self (s)
                              " a:hd is a list because to avoid copying the value.
    1   0.000160   0.000034   return get(s:libcall('vp_decode', [a:hd[0]]), 0, '')

FUNCTION  unite#init#_default_scripts()
Called 32 times
Total time:   0.087480
 Self time:   0.028496

count  total (s)   self (s)
   32              0.000209   let names = empty(a:names) ? [''] : a:names
   32              0.000131   if a:kind ==# 'sources' && !empty(a:names)
    3              0.000014     call add(names, 'alias')
                            
    3              0.000012     if !exists('*neobundle#autoload#unite_sources')
                                  " Dummy call.
                                  try
                                    call neobundle#autoload#unite_sources([])
                                  catch /E117.*/
                                  endtry
                                endif
                            
    3              0.000009     if exists('*neobundle#autoload#unite_sources')
    3   0.001251   0.000021       call neobundle#autoload#unite_sources(a:names)
    3              0.000001     endif
    3              0.000002   endif
                            
   32   0.000708   0.000298   let loaded_defaults = unite#variables#loaded_defaults()
                            
   32              0.000258   if get(loaded_defaults, a:kind, '') ==# &runtimepath
                                return
                              endif
                            
   32   0.000747   0.000241   let static = unite#variables#static()
                            
   67              0.000175   for name in names
   35              0.000380     if name != '' && has_key(static[a:kind], name) || (a:kind ==# 'sources' && name ==# 'alias' &&     has_key(loaded_defaults, 'alias'))
   22              0.000062       continue
                                endif
                            
   13              0.000030     if name == ''
                                  let loaded_defaults[a:kind] = &runtimepath
                                elseif a:kind ==# 'sources' && name ==# 'alias'
    1              0.000003       let loaded_defaults.alias = 1
    1              0.000001     endif
                            
                                " Search files by prefix or postfix.
   13              0.000031     if a:kind ==# 'filters'
    5              0.000206       let prefix_name = substitute(name,'^\%(matcher\|sorter\|converter\)_[^/_-]\+\zs[/_-].*$', '', '')
    5              0.000026       let postfix_name = ''
    5              0.000020       let postfix_name2 = ''
    5              0.000008     else
    8              0.000065       let prefix_name = matchstr(name, '^[^/_-]\+')
    8              0.000053       let postfix_name = matchstr(name, '[^/_-]\+$')
    8              0.000066       let postfix_name2 = matchstr(name, '^[^/_-]\+[/_-]\+\zs[^/_-]\+')
    8              0.000010     endif
                            
   13              0.000035     let files = []
   27   0.031139   0.000373     for prefix in filter(unite#util#uniq([ prefix_name, postfix_name, postfix_name2]), "name == '' || v:val != ''")
   14              0.014526       let files += split(globpath(&runtimepath, 'autoload/unite/'.a:kind.'/'.prefix.'*.vim', 1), '\n')
   14              0.000059     endfor
                            
   13              0.000047     if a:kind == 'sources'
    2              0.000026       call filter(files, "index(g:unite_ignore_source_files, fnamemodify(v:val, ':t')) < 0")
    2              0.000002     endif
                            
   26   0.032336   0.006350     for define in map(files, "unite#{a:kind}#{fnamemodify(v:val, ':t:r')}#define()")
   25   0.000386   0.000300       for dict in filter(unite#util#convert2list(define), '!empty(v:val) && !has_key(static[a:kind], v:val.name)')
   12              0.000072         let static[a:kind][dict.name] = dict
   12              0.000015       endfor
   13              0.000019       unlet define
   13              0.000014     endfor
   13              0.000021   endfor

FUNCTION  unite#variables#set_current_unite()
Called 7 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    7              0.000023   let s:current_unite = a:unite

FUNCTION  <SNR>102_get_hunks_signify()
Called 5469 times
Total time:   0.169826
 Self time:   0.090946

count  total (s)   self (s)
 5469   0.120020   0.041140   let hunks = sy#repo#get_stats()
 5469              0.019149   if hunks[0] >= 0
                                return hunks
                              endif
 5469              0.008121   return []

FUNCTION  airline#highlighter#add_separator()
Called 10274 times
Total time:   4.900340
 Self time:   0.242403

count  total (s)   self (s)
10274              0.100938   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
10274   4.789793   0.131856   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  240()
Called 17 times
Total time:   0.195191
 Self time:   0.000513

count  total (s)   self (s)
   17              0.000182     let Callback = function(self.callback)
   17              0.000033     if a:0
    2   0.102971   0.000031         call Callback(a:1)
    2              0.000002     else
   15   0.091874   0.000136         call Callback()
   15              0.000013     endif

FUNCTION  241()
Called 17 times
Total time:   0.414686
 Self time:   0.002243

count  total (s)   self (s)
   17   0.208717   0.000430     let node = g:NERDTreeFileNode.GetSelected()
   17              0.000069     if !empty(node)
                            
                                    "try file node
   11              0.000021         if !node.path.isDirectory
    9   0.001871   0.000095             let km = s:KeyMap.FindFor(a:key, "FileNode")
    9              0.000022             if !empty(km)
    2   0.103028   0.000023                 return km.invoke(node)
                                        endif
    7              0.000002         endif
                            
                                    "try dir node
    9              0.000016         if node.path.isDirectory
    2   0.001190   0.000047             let km = s:KeyMap.FindFor(a:key, "DirNode")
    2              0.000011             if !empty(km)
                                            return km.invoke(node)
                                        endif
    2              0.000003         endif
                            
                                    "try generic node
    9   0.002820   0.000065         let km = s:KeyMap.FindFor(a:key, "Node")
    9              0.000024         if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
    9              0.000008     endif
                            
                                "try bookmark
   15   0.000872   0.000208     let bm = g:NERDTreeBookmark.GetSelected()
   15              0.000052     if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
   15   0.002792   0.000165     let km = s:KeyMap.FindFor(a:key, "all")
   15              0.000054     if !empty(km)
   15   0.092284   0.000098         return km.invoke()
                                endif

FUNCTION  <SNR>81_uname()
Called 128 times
Total time:   0.003496
 Self time:   0.003496

count  total (s)   self (s)
  128              0.001498     if !exists('s:uname')
                                    let s:uname = system('uname')
                                endif
  128              0.000481     return s:uname

FUNCTION  fugitive#head()
Called 10938 times
Total time:   0.067686
 Self time:   0.067686

count  total (s)   self (s)
10938              0.039432   if !exists('b:git_dir')
10938              0.014779     return ''
                              endif
                            
                              return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>188_sort_by()
Called 3 times
Total time:   0.000345
 Self time:   0.000193

count  total (s)   self (s)
    3              0.000094   let pairs = map(a:list, printf('[v:val, %s]', a:expr))
    3   0.000240   0.000088   return map(s:sort(pairs,      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')

FUNCTION  <SNR>68_UpdateList()
Called 99 times
Total time:   0.013169
 Self time:   0.013169

count  total (s)   self (s)
                              " Function to update the window list with info about the current buffer
   99              0.000571   if !exists('w:BufKillList')
    6              0.000013     let w:BufKillList = []
    6              0.000006   endif
   99              0.000466   if !exists('w:BufKillColumnList')
    6              0.000012     let w:BufKillColumnList = []
    6              0.000005   endif
   99              0.000380   if !exists('w:BufKillIndex')
    6              0.000011     let w:BufKillIndex = -1
    6              0.000004   endif
   99              0.000425   if !exists('w:BufKillLastCmd')
    6              0.000011     let w:BufKillLastCmd = ''
    6              0.000003   endif
   99              0.000556   let bufferNum = bufnr('%')
                            
   99              0.000792   if (w:BufKillLastCmd=~'bufchange')
                                " When stepping through files, the w:BufKillList should not be changed
                                " here, only by the GotoBuffer command since the files must already
                                " exist in the list to jump to them.
                              else
                                " Increment index
   99              0.000435     let w:BufKillIndex += 1
   99              0.000528     if w:BufKillIndex < len(w:BufKillList)
                                  " The branch is diverging, remove the end of the list
                                  call remove(w:BufKillList, w:BufKillIndex, -1)
                                  " Same for column list
                                  if w:BufKillIndex < len(w:BufKillColumnList)
                                    call remove(w:BufKillColumnList, w:BufKillIndex, -1)
                                  endif
                                endif
                                " Now remove any pre-existing instances of the buffer in the list
   99              0.000716     let existingIndex = index(w:BufKillList, bufferNum)
   99              0.000271     if existingIndex != -1
   81              0.000740       call remove(w:BufKillList, existingIndex)
   81              0.000351       let w:BufKillIndex -= 1
   81              0.000532       if existingIndex < len(w:BufKillColumnList)
   41              0.000372         call remove(w:BufKillColumnList, existingIndex)
   41              0.000067       endif
   81              0.000089     endif
                                " Now add the buffer to the list, at the end
   99              0.000568     let w:BufKillList += [bufferNum]
   99              0.000131   endif
                            
                              " Reset since command processed
   99              0.000346   let w:BufKillLastCmd = ''
                            

FUNCTION  <SNR>203_rotate_source()
Called 1 time
Total time:   0.002792
 Self time:   0.000165

count  total (s)   self (s)
    1   0.000093   0.000035   let unite = unite#get_current_unite()
                            
    1   0.000107   0.000020   for source in unite#loaded_sources_list()
    1              0.000052     let unite.sources = a:is_next ? add(unite.sources[1:], unite.sources[0]) : insert(unite.sources[: -2], unite.sources[-1])
                            
    1              0.000014     if !empty(unite.sources[0].unite__candidates)
    1              0.000005       break
                                endif
                              endfor
                            
    1   0.002501   0.000019   call unite#view#_redraw_candidates()

FUNCTION  <SNR>187_escape_pattern()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000006   return escape(a:str, '~"\.^$[]*')

FUNCTION  <SNR>122_load()
Called 404 times
Total time:   0.017401
 Self time:   0.017401

count  total (s)   self (s)
  404              0.014528   if !filereadable(g:unite_source_history_yank_file)  || s:yank_histories_file_mtime == getftime(g:unite_source_history_yank_file)
  404              0.001331     return
                              endif
                            
                              let file = readfile(g:unite_source_history_yank_file)
                              if empty(file)
                                return
                              endif
                            
                              try
                                sandbox let s:yank_histories = eval(file[0])
                            
                                " Type check.
                                let history = s:yank_histories[0]
                                let history[0] = history[0]
                              catch
                                let s:yank_histories = []
                              endtry
                            
                              let s:yank_histories_file_mtime = getftime(g:unite_source_history_yank_file)

FUNCTION  <SNR>142_substitute_path_separator()
Called 192 times
Total time:   0.001520
 Self time:   0.001520

count  total (s)   self (s)
  192              0.001306   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  neobundle#config#get_autoload_bundles()
Called 78 times
Total time:   0.028141
 Self time:   0.028141

count  total (s)   self (s)
   78              0.027985   return filter(values(s:neobundles), "!v:val.sourced && v:val.rtp != '' && v:val.lazy")

FUNCTION  indent_guides#clear_matches()
Called 107 times
Total time:   0.005327
 Self time:   0.004058

count  total (s)   self (s)
  107   0.001941   0.000672   call indent_guides#init_matches()
  107              0.000483   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif

FUNCTION  <SNR>20_FTxml()
Called 2 times
Total time:   0.013833
 Self time:   0.002453

count  total (s)   self (s)
    2              0.000006   let n = 1
  107              0.000224   while n < 100 && n < line("$")
  105              0.000251     let line = getline(n)
  105              0.000470     if line =~ '<!DOCTYPE.*DocBook'
                                  let b:docbk_type = "xml"
                                  setf docbk
                                  return
                                endif
  105              0.000689     if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
  105              0.000149     let n += 1
  105              0.000089   endwhile
    2   0.011386   0.000006   setf xml

FUNCTION  <SNR>194_strchars()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return strchars(a:str)

FUNCTION  SyntasticMake()
Called 32 times
Total time:  25.989263
 Self time:   0.112076

count  total (s)   self (s)
   32   0.001743   0.000724     call syntastic#log#debug(g:SyntasticDebugTrace, 'SyntasticMake: called with options:', a:options)
                            
   32              0.000286     let old_shell = &shell
   32              0.000237     let old_shellredir = &shellredir
   32              0.000249     let old_local_errorformat = &l:errorformat
   32              0.000264     let old_errorformat = &errorformat
   32              0.000518     let old_cwd = getcwd()
   32              0.000349     let old_lc_messages = $LC_MESSAGES
   32              0.000215     let old_lc_all = $LC_ALL
                            
   32   0.003830   0.000418     if s:OSSupportsShellredirHack()
                                    "this is a hack to stop the screen needing to be ':redraw'n when
                                    "when :lmake is run. Otherwise the screen flickers annoyingly
   32              0.000535         let &shellredir = '&>'
   32              0.000268         let &shell = '/bin/bash'
   32              0.000063     endif
                            
   32              0.000293     if has_key(a:options, 'errorformat')
   32              0.000486         let &errorformat = a:options['errorformat']
   32              0.000075     endif
                            
   32              0.000222     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
   32              0.000335     let $LC_MESSAGES = 'C'
   32              0.000264     let $LC_ALL = ''
   32  25.867622   0.015463     let err_lines = split(system(a:options['makeprg']), "\n", 1)
   32              0.001120     let $LC_ALL = old_lc_all
   32              0.000331     let $LC_MESSAGES = old_lc_messages
                            
   32   0.003931   0.001785     call syntastic#log#debug(g:SyntasticDebugLoclist, "checker output:", err_lines)
                            
   32              0.000483     if has_key(a:options, 'preprocess')
                                    let err_lines = call(a:options['preprocess'], [err_lines])
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, "preprocess:", err_lines)
                                endif
   32              0.062620     lgetexpr err_lines
                            
   32              0.004278     let errors = copy(getloclist(0))
                            
   32              0.000373     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(old_cwd)
                                endif
                            
   32              0.001426     silent! lolder
   32              0.000871     let &errorformat = old_errorformat
   32              0.000366     let &l:errorformat = old_local_errorformat
   32              0.000467     let &shellredir = old_shellredir
   32              0.000276     let &shell=old_shell
                            
   32   0.004630   0.000875     if s:IsRedrawRequiredAfterMake()
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
   32   0.001706   0.000681     call syntastic#log#debug(g:SyntasticDebugLoclist, "raw loclist:", errors)
                            
   32              0.000457     if has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                                    throw 'Syntastic: checker error'
                                endif
                            
   32              0.000212     if has_key(a:options, 'defaults')
                                    call SyntasticAddToErrors(errors, a:options['defaults'])
                                endif
                            
                                " Apply ignore patterns
   32              0.000249     let ignored = {}
   32              0.000212     let do_ignore = 0
   64   0.010154   0.002768     for buf in syntastic#util#unique(map(copy(errors), 'v:val["bufnr"]'))
   32   0.004201   0.001105         let ignored[buf] = s:IgnoreFile(bufname(str2nr(buf)))
   32              0.000392         let do_ignore = do_ignore || ignored[buf]
   32              0.000095     endfor
   32              0.000113     if do_ignore
                                    call filter(errors, '!ignored[v:val["bufnr"]]')
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, "filtered loclist:", errors)
                                endif
                            
                                " Add subtype info if present.
   32              0.000236     if has_key(a:options, 'subtype')
                                    call SyntasticAddToErrors(errors, {'subtype': a:options['subtype']})
                                endif
                            
   32              0.000430     if has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
   64              0.000393         for rule in a:options['postprocess']
   32   0.003075   0.000830             let errors = call('syntastic#postprocess#' . rule, [errors])
   32              0.000084         endfor
   32   0.001583   0.000639         call syntastic#log#debug(g:SyntasticDebugLoclist, "postprocess:", errors)
   32              0.000064     endif
                            
   32              0.000104     return errors

FUNCTION  <SNR>187_path2directory()
Called 1 time
Total time:   0.000024
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000022   0.000017   return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))

FUNCTION  unite#kinds#cdable#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:kind

FUNCTION  unite#filters#filter_matcher()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007   if a:context.unite__max_candidates <= 0 || !a:context.unite__is_interactive || len(a:context.input_list) > 1
                            
                                return a:expr == '' ? a:list : (a:expr ==# 'if_lua') ?   unite#filters#lua_matcher(      a:list, a:context, &ignorecase) : (a:expr ==# 'if_lua_fuzzy') ?   unite#filters#lua_fuzzy_matcher(      a:list, a:context, &ignorecase) : filter(a:list, a:expr)
                              endif
                            
    1              0.000002   if a:expr == ''
    1              0.000004     return a:list[: a:context.unite__max_candidates - 1]
                              endif
                            
                              let _ = []
                              let len = 0
                            
                              let max = a:context.unite__max_candidates
                              let offset = max*4
                              for cnt in range(0, len(a:list) / offset)
                                let list = a:list[cnt*offset : cnt*offset + offset]
                                let list = (a:expr ==# 'if_lua') ?   unite#filters#lua_matcher(list, a:context, &ignorecase) : (a:expr ==# 'if_lua_fuzzy') ?   unite#filters#lua_fuzzy_matcher(list, a:context, &ignorecase) : filter(list, a:expr)
                                let len += len(list)
                                let _ += list
                            
                                if len >= max
                                  break
                                endif
                              endfor
                            
                              return _[: max]

FUNCTION  <SNR>191_SID_PREFIX()
Called 49 times
Total time:   0.000465
 Self time:   0.000465

count  total (s)   self (s)
   49              0.000139   if !exists('s:sid_prefix')
    1              0.000029     let s:sid_prefix = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
    1              0.000001   endif
   49              0.000069   return s:sid_prefix

FUNCTION  256()
Called 15 times
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
   15              0.000100     let line = getline(".")
   15              0.000251     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
   15              0.000064     if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
   15              0.000021     return {}

FUNCTION  airline#statusline()
Called 7979 times
Total time:   0.192713
 Self time:   0.192713

count  total (s)   self (s)
 7979              0.081675   if has_key(s:contexts, a:winnr)
 7979              0.087636     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  unite#init#_unite_buffer()
Called 1 time
Total time:   0.043656
 Self time:   0.000887

count  total (s)   self (s)
    1   0.000012   0.000004   let current_unite = unite#variables#current_unite()
    1              0.000018   let is_bufexists = bufexists(current_unite.real_buffer_name)
    1              0.000006   let current_unite.context.real_buffer_name = current_unite.real_buffer_name
                            
    1              0.000002   let context = current_unite.context
                            
    1              0.000002   if !context.temporary && context.tab
                                tabnew
                              endif
                            
    1   0.031463   0.000009   call unite#view#_switch_unite_buffer( current_unite.buffer_name, context)
                            
    1              0.000003   let b:unite = current_unite
    1   0.000027   0.000005   let unite = unite#get_current_unite()
                            
    1              0.000005   let unite.bufnr = bufnr('%')
                            
                              " Note: If unite buffer initialize is incomplete, &modified or &modifiable.
    1              0.000002   if !is_bufexists || &modified || &modifiable
                                " Basic settings.
    1              0.000004     setlocal bufhidden=hide
    1              0.000002     setlocal buftype=nofile
    1              0.000003     setlocal nolist
    1   0.000074   0.000003     setlocal nobuflisted
    1              0.000003     setlocal noswapfile
    1              0.000002     setlocal nospell
    1              0.000003     setlocal noreadonly
    1              0.000002     setlocal nofoldenable
    1              0.000001     setlocal nomodeline
    1              0.000001     setlocal nonumber
    1              0.000004     setlocal foldcolumn=0
    1              0.000030     setlocal iskeyword+=-,+,\\,!,~
    1              0.000003     setlocal matchpairs-=<:>
    1              0.000002     setlocal completefunc=unite#dummy_completefunc
    1              0.000002     setlocal omnifunc=
    1              0.000001     match
    1              0.000002     if has('conceal')
    1              0.000002       setlocal conceallevel=3
    1              0.000002       setlocal concealcursor=n
    1              0.000001     endif
    1              0.000003     if exists('+cursorcolumn')
    1              0.000002       setlocal nocursorcolumn
    1              0.000001     endif
    1              0.000002     if exists('+colorcolumn')
    1              0.000002       setlocal colorcolumn=0
    1              0.000000     endif
    1              0.000003     if exists('+relativenumber')
    1              0.000001       setlocal norelativenumber
    1              0.000001     endif
                            
                                " Autocommands.
    1              0.000002     augroup plugin-unite
    1              0.000063       autocmd! * <buffer>
    1              0.000009       autocmd InsertEnter <buffer> call unite#handlers#_on_insert_enter()
    1              0.000006       autocmd InsertLeave <buffer> call unite#handlers#_on_insert_leave()
    1              0.000004       autocmd CursorHoldI <buffer> call unite#handlers#_on_cursor_hold_i()
    1              0.000004       autocmd CursorMovedI <buffer> call unite#handlers#_on_cursor_moved_i()
    1              0.000006       autocmd CursorMoved,CursorMovedI <buffer>  nested call unite#handlers#_on_cursor_moved()
    1              0.000006       autocmd BufUnload,BufHidden <buffer> call unite#handlers#_on_buf_unload(expand('<afile>'))
    1              0.000007       autocmd WinEnter,BufWinEnter <buffer> call unite#handlers#_on_bufwin_enter(bufnr(expand('<abuf>')))
    1              0.000006       autocmd WinLeave,BufWinLeave <buffer> call unite#handlers#_restore_updatetime()
    1              0.000001     augroup END
                            
    1              0.000006     if v:version > 703 || v:version == 703 && has('patch418')
                                  " Enable auto narrow feature.
    1              0.000005       autocmd plugin-unite InsertCharPre <buffer> call unite#handlers#_on_insert_char_pre()
    1              0.000001     endif
                            
    1   0.003783   0.000554     call unite#mappings#define_default_mappings()
    1              0.000001   endif
                            
    1              0.000007   let &l:wrap = context.wrap
                            
    1              0.000003   if exists('&redrawtime')
                                " Save redrawtime
    1              0.000004     let unite.redrawtime_save = &redrawtime
    1              0.000003     let &redrawtime = 100
    1              0.000001   endif
                            
    1   0.000043   0.000006   call unite#handlers#_save_updatetime()
                            
                              " User's initialization.
    1              0.000004   setlocal nomodifiable
    1              0.000004   set sidescrolloff=0
    1              0.000002   setlocal nocursorline
    1   0.007951   0.000003   setfiletype unite

FUNCTION  neosnippet#get_sync_placeholder_marker_pattern()
Called 30 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
   30              0.000117   return '<{\d\+\%(:.\{-}\)\?\\\@<!}>'

FUNCTION  XmlIndentGet()
Called 89 times
Total time:   0.076901
 Self time:   0.010039

count  total (s)   self (s)
                                " Find a non-empty line above the current line.
   89              0.001489     let lnum = prevnonblank(a:lnum - 1)
                            
                                " Hit the start of the file, use zero indent.
   89              0.000339     if lnum == 0
    2              0.000010 	return 0
                                endif
                            
   87              0.000255     if a:use_syntax_check
   87   0.031284   0.001267 	let check_lnum = <SID>XmlIndentSynCheck(lnum)
   87   0.022866   0.001328 	let check_alnum = <SID>XmlIndentSynCheck(a:lnum)
   87              0.000369 	if 0 == check_lnum || 0 == check_alnum
                            	    return indent(a:lnum)
                            	elseif -1 == check_lnum || -1 == check_alnum
                            	    return -1
                            	endif
   87              0.000097     endif
                            
   87   0.012987   0.001431     let ind = <SID>XmlIndentSum(lnum, -1, indent(lnum))
   87   0.004724   0.000973     let ind = <SID>XmlIndentSum(a:lnum, 0, ind)
                            
   87              0.000175     return ind

FUNCTION  <SNR>29_ParseSkip()
Called 11 times
Total time:   0.000806
 Self time:   0.000806

count  total (s)   self (s)
   11              0.000070   let skip = a:str
   11              0.000079   if skip[1] == ":"
   11              0.000061     if skip[0] == "s"
   11              0.000148       let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" . strpart(skip,2) . "'"
   11              0.000037     elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" . strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
   11              0.000019   endif
   11              0.000038   return skip

FUNCTION  <SNR>191_finalize()
Called 1 time
Total time:   0.000202
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000042   0.000007   call s:garbage_collect(1)
                            
    1              0.000004   if exists('s:dll_handle')
    1   0.000153   0.000007     call s:vp_dlclose(s:dll_handle)
    1              0.000001   endif

FUNCTION  unite#util#strchars()
Called 1 time
Total time:   0.020091
 Self time:   0.000023

count  total (s)   self (s)
    1   0.020090   0.000022   return call(s:get_string().strchars, a:000)

FUNCTION  <SNR>212_adjust_scroll()
Called 2 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    2              0.000017   normal! zt
    2              0.000010   let save_cursor = getpos('.')
    2              0.000004   let winl = 1
                              " Scroll the cursor line down.
    4              0.000010   while winl <= a:best_winline
    2              0.000004     let winl_prev = winl
    2              0.000028     execute "normal! \<C-y>"
    2              0.000006     let winl = winline()
    2              0.000002     if winl == winl_prev
                                  break
                                end
    2              0.000004     let winl_prev = winl
    2              0.000002   endwhile
    2              0.000004   if winl > a:best_winline
    2              0.000025     execute "normal! \<C-e>"
    2              0.000001   endif
    2              0.000008   call setpos('.', save_cursor)

FUNCTION  neobundle#autoload#insert()
Called 43 times
Total time:   0.027703
 Self time:   0.007537

count  total (s)   self (s)
   43   0.026471   0.006305   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'insert', 0)")
   43              0.000375   if !empty(bundles)
                                call neobundle#config#source_bundles(bundles)
                                doautocmd InsertEnter
                              endif

FUNCTION  vimproc#util#has_lua()
Called 2 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                              " Note: Disabled if_lua feature if less than 7.3.885.
                              " Because if_lua has double free problem.
    2              0.000057   return has('lua') && (v:version > 703 || v:version == 703 && has('patch885'))

FUNCTION  neosnippet#get_mirror_placeholder_marker_pattern()
Called 13 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   13              0.000025   return '<|\d\+|>'

FUNCTION  syntastic#util#unique()
Called 121 times
Total time:   0.018169
 Self time:   0.018169

count  total (s)   self (s)
  121              0.000923     let seen = {}
  121              0.000649     let uniques = []
  868              0.002153     for e in a:list
  747              0.003603         if !has_key(seen, e)
  108              0.000876             let seen[e] = 1
  108              0.001375             call add(uniques, e)
  108              0.000239         endif
  747              0.001177     endfor
  121              0.000376     return uniques

FUNCTION  vimproc#analyze_shebang()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000014   if !filereadable(a:filename) || getfsize(a:filename) > 100000 || (vimproc#util#is_windows() && '.'.fnamemodify(a:filename, ':e') !~?   '^'.substitute($PATHEXT, ';', '$\\|^', 'g').'$')
                                  " Maybe a binary file.
    1              0.000002     return [a:filename]
                              endif
                            
                              let lines = readfile(a:filename, '', 1)
                              if empty(lines) || lines[0] !~ '^#!.\+'
                                " Shebang not found.
                                return [a:filename]
                              endif
                            
                              " Get shebang line.
                              let shebang = split(matchstr(lines[0], '^#!\zs.\+'))
                            
                              " Convert command name.
                              if vimproc#util#is_windows() && shebang[0] =~ '^/'
                                let shebang[0] = vimproc#get_command_name( fnamemodify(shebang[0], ':t'))
                              endif
                            
                              return shebang + [a:filename]

FUNCTION  unite#util#wcswidth()
Called 2 times
Total time:   0.000086
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000084   0.000036   return call(unite#util#get_vital().wcswidth, a:000)

FUNCTION  unite#variables#current_unite()
Called 29 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
   29              0.000121   if !exists('s:current_unite')
                                let s:current_unite = {}
                              endif
                            
   29              0.000049   return s:current_unite

FUNCTION  nerdtree#renderBookmarks()
Called 6 times
Total time:   0.000398
 Self time:   0.000327

count  total (s)   self (s)
                            
    6              0.000015     if g:NERDTreeMinimalUI == 0
    6              0.000049         call setline(line(".")+1, ">----------Bookmarks----------")
    6              0.000038         call cursor(line(".")+1, col("."))
    6              0.000007     endif
                            
    6   0.000124   0.000053     for i in g:NERDTreeBookmark.Bookmarks()
                                    call setline(line(".")+1, i.str())
                                    call cursor(line(".")+1, col("."))
                                endfor
                            
    6              0.000045     call setline(line(".")+1, '')
    6              0.000037     call cursor(line(".")+1, col("."))

FUNCTION  sy#repo#detect()
Called 39 times
Total time:   0.458496
 Self time:   0.007742

count  total (s)   self (s)
   39              0.000745   let dir = fnamemodify(b:sy.path, ':h')
                            
                              " Simple cache. If there is a registered VCS-controlled file in this
                              " directory already, assume that this file is probably controlled by
                              " the same VCS. Thus we shuffle that VCS to the top of our vcs_list.
   39              0.000372   if has_key(g:sy_cache, dir)
                                let idx = index(s:vcs_list, g:sy_cache[dir])
                                if idx != -1
                                  call remove(s:vcs_list, idx)
                                  call insert(s:vcs_list, g:sy_cache[dir], 0)
                                endif
                              endif
                            
   78              0.000782   for type in s:vcs_list
   39   0.452603   0.001849     let [istype, diff] = sy#repo#get_diff_{type}()
   39              0.000310     if istype
                                  return [ diff, type ]
                                endif
   39              0.000230   endfor
                            
   39              0.000294   return [ '', 'unknown' ]

FUNCTION  airline#extensions#apply()
Called 164 times
Total time:   0.046239
 Self time:   0.024937

count  total (s)   self (s)
  164              0.001154   let s:active_winnr = winnr()
                            
  164   0.020190   0.001592   if s:is_excluded_window()
                                return -1
                              endif
                            
  164              0.000659   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
  164              0.000372   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
  164              0.002891   if has_key(s:filetype_overrides, &ft)
   14              0.000102     let args = s:filetype_overrides[&ft]
   14   0.002813   0.000109     call airline#extensions#apply_left_override(args[0], args[1])
   14              0.000010   endif
                            
  328              0.002097   for item in items(s:filetype_regex_overrides)
  164              0.003893     if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
  164              0.000272   endfor

FUNCTION  269()
Called 2 times
Total time:   0.102906
 Self time:   0.000066

count  total (s)   self (s)
    2   0.102901   0.000061     call self.open(a:0 ? a:1 : {})

FUNCTION  neosnippet#variables#expand_stack()
Called 43 times
Total time:   0.001344
 Self time:   0.001344

count  total (s)   self (s)
   43              0.000546   if !exists('s:expand_stack')
                                let s:expand_stack = []
                              endif
                            
   43              0.000220   return s:expand_stack

FUNCTION  <SNR>38_shellslash()
Called 10948 times
Total time:   0.140350
 Self time:   0.140350

count  total (s)   self (s)
10948              0.051696   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
10948              0.020490     return a:path
                              endif

FUNCTION  <SNR>205_filter_self_func()
Called 38 times
Total time:   0.002610
 Self time:   0.002610

count  total (s)   self (s)
   38              0.002575   return filter(copy(a:action_table), printf("string(v:val.func) !=# \"function('%s')\"", a:self_func))

FUNCTION  unite#util#has_vimproc()
Called 3 times
Total time:   0.004582
 Self time:   0.000029

count  total (s)   self (s)
    3   0.004580   0.000027   return call(unite#util#get_vital().has_vimproc, a:000)

FUNCTION  nerdtree#dumpHelp()
Called 6 times
Total time:   0.006925
 Self time:   0.006868

count  total (s)   self (s)
    6              0.000039     let old_h = @h
    6              0.000025     if b:treeShowHelp ==# 1
    3   0.000069   0.000056         let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
    3              0.000018         let @h=@h."\" ============================\n"
    3              0.000016         let @h=@h."\" File node mappings~\n"
    3              0.000033         let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
    3              0.000018         let @h=@h."\" <CR>,\n"
    3              0.000014         if b:NERDTreeType ==# "primary"
    3              0.000031             let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
    3              0.000003         else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
    3              0.000010         if b:NERDTreeType ==# "primary"
    3              0.000031             let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
    3              0.000005         endif
    3              0.000035         let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
    3              0.000034         let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
    3              0.000032         let @h=@h."\" middle-click,\n"
    3              0.000031         let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
    3              0.000032         let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
    3              0.000034         let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
    3              0.000035         let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
    3              0.000030         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000031         let @h=@h."\" Directory node mappings~\n"
    3              0.000045         let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
    3              0.000042         let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
    3              0.000046         let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
    3              0.000045         let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
    3              0.000045         let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
    3              0.000037         let @h=@h."\"    current node recursively\n"
    3              0.000037         let @h=@h."\" middle-click,\n"
    3              0.000047         let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
    3              0.000041         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000042         let @h=@h."\" Bookmark table mappings~\n"
    3              0.000041         let @h=@h."\" double-click,\n"
    3              0.000052         let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
    3              0.000053         let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
    3              0.000055         let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
    3              0.000055         let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
    3              0.000051         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000051         let @h=@h."\" Tree navigation mappings~\n"
    3              0.000060         let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
    3              0.000060         let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
    3              0.000065         let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
    3              0.000065         let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
    3              0.000068         let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
    3              0.000067         let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
    3              0.000060         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000060         let @h=@h."\" Filesystem mappings~\n"
    3              0.000071         let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
    3              0.000064         let @h=@h."\"    selected dir\n"
    3              0.000077         let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
    3              0.000077         let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
    3              0.000068         let @h=@h."\"    but leave old root open\n"
    3              0.000081         let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
    3              0.000082         let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
    3              0.000080         let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
    3              0.000081         let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
    3              0.000071         let @h=@h."\"    selected dir\n"
    3              0.000084         let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
    3              0.000077         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000076         let @h=@h."\" Tree filtering mappings~\n"
    3              0.000105         let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (b:NERDTreeShowHidden ? "on" : "off") . ")\n"
    3              0.000106         let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (b:NERDTreeIgnoreEnabled ? "on" : "off") . ")\n"
    3              0.000106         let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (b:NERDTreeShowFiles ? "on" : "off") . ")\n"
    3              0.000105         let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (b:NERDTreeShowBookmarks ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
    3              0.000085         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000084         let @h=@h."\" Custom mappings~\n"
  153   0.000290   0.000246         for i in g:NERDTreeKeyMap.All()
  150              0.000447             if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
  150              0.000146         endfor
                            
    3              0.000060         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000053         let @h=@h."\" Other mappings~\n"
    3              0.000062         let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
    3              0.000063         let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
    3              0.000054         let @h=@h."\"    the NERDTree window\n"
    3              0.000062         let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
    3              0.000058         let @h=@h."\"\n\" ----------------------------\n"
    3              0.000057         let @h=@h."\" Bookmark commands~\n"
    3              0.000057         let @h=@h."\" :Bookmark <name>\n"
    3              0.000057         let @h=@h."\" :BookmarkToRoot <name>\n"
    3              0.000057         let @h=@h."\" :RevealBookmark <name>\n"
    3              0.000059         let @h=@h."\" :OpenBookmark <name>\n"
    3              0.000058         let @h=@h."\" :ClearBookmarks [<names>]\n"
    3              0.000059         let @h=@h."\" :ClearAllBookmarks\n"
    3              0.000075         silent! put h
    3              0.000007     elseif g:NERDTreeMinimalUI == 0
    3              0.000024         let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
    3              0.000048         silent! put h
    3              0.000007     endif
                            
    6              0.000029     let @h = old_h

FUNCTION  airline#highlighter#get_highlight()
Called 35122 times
Total time:   4.798856
 Self time:   1.354494

count  total (s)   self (s)
35122   1.744086   0.249141   let fg = s:get_syn(a:group, 'fg')
35122   1.650117   0.253246   let bg = s:get_syn(a:group, 'bg')
35122              0.471234   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', has('gui_running') ? 'gui' : 'term')
35122   0.889579   0.337033   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  <SNR>29_CleanUp()
Called 11 times
Total time:   0.001535
 Self time:   0.001421

count  total (s)   self (s)
   11              0.000246   execute "set" a:options
                              " Open folds, if appropriate.
   11              0.000053   if a:mode != "o"
   10              0.000146     if &foldopen =~ "percent"
   10              0.000135       normal! zv
   10              0.000023     endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
   10              0.000107   elseif (a:startline < line(".")) || (a:startline == line(".") && a:startcol < col("."))
    1              0.000004     if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
    1              0.000013       let matchline = getline(".")
    1              0.000008       let currcol = col(".")
    1   0.000142   0.000028       let regexp = s:Wholematch(matchline, a:1, currcol-1)
    1              0.000033       let endcol = matchend(matchline, regexp)
    1              0.000006       if endcol > currcol  " This is NOT off by one!
                            	execute "normal!" . (endcol - currcol) . "l"
                                  endif
    1              0.000003     endif " a:0
    1              0.000003   endif " a:mode != "o" && etc.
   11              0.000027   return 0

FUNCTION  <SNR>186__unify_path()
Called 62 times
Total time:   0.002356
 Self time:   0.002356

count  total (s)   self (s)
   62              0.002306     return resolve(fnamemodify(a:path, ':p:gs?[\\/]\+?/?'))

FUNCTION  275()
Called 90 times
Total time:   0.001028
 Self time:   0.000373

count  total (s)   self (s)
   90   0.000982   0.000327     return self.path.displayString()

FUNCTION  276()
Called 1 time
Total time:   0.000198
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000198   0.000008     return self.path.str() ==# a:treenode.path.str()

FUNCTION  277()
Called 38 times
Total time:   0.007277
 Self time:   0.000233

count  total (s)   self (s)
   38   0.007183   0.000139     if a:path.equals(self.path)
   16              0.000019         return self
                                endif
   22              0.000019     return {}

FUNCTION  <SNR>148_XmlIndentWithPattern()
Called 255 times
Total time:   0.006884
 Self time:   0.006884

count  total (s)   self (s)
  255              0.003576     let s = substitute('x'.a:line, a:pat, "\1", 'g')
  255              0.002949     return strlen(substitute(s, "[^\1].*$", '', ''))

FUNCTION  <SNR>48_set_find_char()
Called 2 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                              "call inputsave()
                              " Do not use this if 'showcmd' is not set or running tests.
                              " this_is_a_test
                              " let showcmd = a:a >= 0 && &showcmd && !exists('g:runVimTests')
                              " if showcmd
                              "   " show command.
                              "   let lead = repeat(' ', &columns - 11)
                              "   let cr = repeat("\n", &cmdheight - 1)
                              "   echon cr . lead . a:cmd
                              " endif
                            
    2              0.000022   if type(a:args) == type('')
    2              0.000043     let s:fchar = empty(a:args) ? nr2char(getchar()) : a:args
    2              0.000008   elseif len(a:args) == 2
                                let s:fchar = a:args[1]
                              else
                                let s:fchar = nr2char(getchar())
                              endif
                              "call inputrestore()
                              " if showcmd
                              "   "call feedkeys((v:operator ==# 'c' ? "\<CR>" : "\<Esc>"), 'n')
                              "   call feedkeys("\<CR>", 'n')
                              " endif

FUNCTION  <SNR>191_vp_waitpid()
Called 1 time
Total time:   0.000685
 Self time:   0.000052

count  total (s)   self (s)
    1   0.000484   0.000012   call s:close_all(self)
                            
    1              0.000001   let self.is_valid = 0
                            
    1              0.000004   if has_key(self, 'cond') && has_key(self, 'status')
                                " Use cache.
                                let [cond, status] = [self.cond, self.status]
                              else
    1   0.000172   0.000011     let [cond, status] = s:waitpid(self.pid)
    1              0.000001   endif
                            
    1              0.000001   if cond ==# 'exit'
    1              0.000002     let self.pid = 0
    1              0.000000   endif
                            
    1              0.000002   if has_key(self, 'pid_list')
    1              0.000003     for pid in self.pid_list[: -2]
                                  call s:waitpid(pid)
                                endfor
    1              0.000001   endif
                            
    1              0.000002   return [cond, str2nr(status)]

FUNCTION  unite#variables#default_context()
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000004   if !exists('s:default_context')
    1              0.000059     let s:default_context = { 'input' : '', 'start_insert' : g:unite_enable_start_insert, 'complete' : 0, 'script' : 0, 'col' : col('.'), 'no_quit' : 0, 'buffer_name' : 'default', 'profile_name' : '', 'prompt' : g:unite_prompt, 'default_action' : 'default', 'winwidth' : g:unite_winwidth, 'winheight' : g:unite_winheight, 'immediately' : 0, 'no_empty' : 0, 'auto_preview' : 0, 'auto_highlight' : 0, 'vertical' : g:unite_enable_split_vertically, 'direction' : g:unite_split_rule, 'no_split' : 0, 'temporary' : 0, 'verbose' : 0, 'auto_resize' : 0, 'old_buffer_info' : [], 'toggle' : 0, 'quick_match' : 0, 'create' : 0, 'cursor_line_highlight' :    g:unite_cursor_line_highlight, 'no_cursor_line' : 0, 'update_time' : g:unite_update_time, 'no_buffer' : 0, 'hide_source_names' : 0, 'max_multi_lines' : 5, 'here' : 0, 'silent' : 0, 'keep_focus' : 0, 'auto_quit' : 0, 'is_redraw' : 0, 'is_restart' : 0, 'is_resize' : 0, 'no_focus' : 0, 'multi_line' : 0, 'resume' : 0, 'wrap' : 0, 'select' : 0, 'log' : 0, 'truncate' : 0, 'tab' : 0, 'execute_command' : '', 'unite__direct_switch' : 0, 'unite__is_interactive' : 1, 'unite__is_complete' : 0, 'unite__is_vimfiler' : 0, 'unite__old_winwidth' : 0, 'unite__old_winheight' : 0, 'unite__disable_hooks' : 0, 'unite__disable_max_candidates' : 0, }
    1              0.000001   endif
                            
    1              0.000001   return s:default_context

FUNCTION  <SNR>58_append()
Called 74 times
Total time:   0.012619
 Self time:   0.011074

count  total (s)   self (s)
   74              0.000572   if bufnr('%') != expand('<abuf>')
                                return
                              endif
                            
   74              0.000441   if !exists('t:unite_buffer_dictionary')
                                let t:unite_buffer_dictionary = {}
                              endif
                            
                              " Append the current buffer.
   74              0.000363   let bufnr = bufnr('%')
                            
   74              0.000337   if exists('*gettabvar')
                                " Delete same buffer in other tab pages.
  222              0.000900     for tabnr in range(1, tabpagenr('$'))
  148              0.001040       let buffer_dict = gettabvar(tabnr, 'unite_buffer_dictionary')
  148              0.001298       if type(buffer_dict) == type({}) && has_key(buffer_dict, bufnr)
   68              0.000592         call remove(buffer_dict, bufnr)
   68              0.000122       endif
  148              0.000322       unlet buffer_dict
  148              0.000239     endfor
   74              0.000092   endif
                            
   74              0.000530   let t:unite_buffer_dictionary[bufnr] = 1
                            
   74              0.000593   if !has('vim_starting') || bufname('%') != ''
   74   0.002180   0.000635     call unite#sources#buffer#variables#append()
   74              0.000107   endif

FUNCTION  <SNR>142_is_file_exist()
Called 64 times
Total time:   0.001065
 Self time:   0.001065

count  total (s)   self (s)
   64              0.000994   return a:path !~ '^\a\w\+:' && getftype(a:path) ==# 'file'

FUNCTION  <SNR>186__import()
Called 11 times
Total time:   0.071498
 Self time:   0.005700

count  total (s)   self (s)
   11              0.000047   if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
   11   0.006566   0.000091   let path = s:_get_module_path(a:name)
   11              0.000029   if path ==# ''
                                throw 'vital: module not found: ' . a:name
                              endif
   11   0.015768   0.000146   let sid = get(s:_scripts(), path, 0)
   11              0.000013   if !sid
    4              0.000005     try
    4   0.002479   0.000929       execute 'source' fnameescape(path)
    4              0.000009     catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
    4   0.005390   0.000045     let sid = s:_scripts()[path]
    4              0.000004   endif
   11   0.034080   0.006950   return s:_build_module(sid)

FUNCTION  unite#helper#get_unite_bufnr()
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000025   for bufnr in filter(range(1, bufnr('$')), "getbufvar(v:val, '&filetype') ==# 'unite'")
                                let buffer_context = get(getbufvar(bufnr, 'unite'), 'context', {})
                                if !empty(buffer_context) && buffer_context.buffer_name ==# a:buffer_name
                                  if buffer_context.temporary && !empty(filter(copy(buffer_context.old_buffer_info), 'v:val.buffer_name ==# buffer_context.buffer_name'))
                                    " Disable resume.
                                    let buffer_context.old_buffer_info = []
                                  endif
                            
                                  return bufnr
                                endif
                              endfor
                            
    1              0.000002   return -1

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 200 times
Total time:   0.023809
 Self time:   0.010476

count  total (s)   self (s)
  200              0.001308   if getbufvar(a:bufnr, '&modified')
   82              0.001669     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   82              0.000114   else
  118              0.001784     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
  118              0.000130   endif
                            
  200              0.000608   if !empty(colors)
  200   0.015528   0.002195     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
  200              0.000332   endif

FUNCTION  unite#util#input()
Called 1 time
Total time:   0.001445
 Self time:   0.001420

count  total (s)   self (s)
    1   0.000030   0.000005   let context = unite#get_context()
    1              0.000002   let prompt = a:prompt
    1              0.000002   let default = get(a:000, 0, '')
    1              0.000003   let completion = get(a:000, 1, '')
    1              0.000003   let source_name = get(a:000, 2, '')
    1              0.000001   if source_name != ''
                                let prompt = printf('[%s] %s', source_name, prompt)
                              endif
                            
    1              0.000003   let args = [prompt, default]
    1              0.000002   if completion != ''
                                call add(args, completion)
                              endif
                            
    1              0.001387   return context.unite__is_interactive ? call('input', args) : default

FUNCTION  unite#util#escape_file_searching()
Called 2 times
Total time:   0.000071
 Self time:   0.000034

count  total (s)   self (s)
    2   0.000070   0.000033   return call(unite#util#get_vital().escape_file_searching, a:000)

FUNCTION  <SNR>82_doRedraw()
Called 46 times
Total time:   0.457501
 Self time:   0.457501

count  total (s)   self (s)
   46              0.000155     if a:full
    1              0.007702         redraw!
    1              0.000001     else
   45              0.449202         redraw
   45              0.000135     endif

FUNCTION  <SNR>186__scripts()
Called 15 times
Total time:   0.020967
 Self time:   0.011719

count  total (s)   self (s)
   15              0.000048   let scripts = {}
   66   0.017298   0.009887   for line in filter(split(s:_redir('scriptnames'), "\n"),                  'stridx(v:val, s:self_version) > 0')
   51              0.000678     let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
   51              0.000120     if !empty(list)
   51   0.002442   0.000605       let scripts[s:_unify_path(list[2])] = list[1] - 0
   51              0.000063     endif
   51              0.000114   endfor
   15              0.000021   return scripts

FUNCTION  unite#init#_current_unite()
Called 1 time
Total time:   0.041919
 Self time:   0.000264

count  total (s)   self (s)
    1              0.000002   let context = a:context
                            
                              " Quit previous unite buffer.
    1              0.000002   if !context.create && !context.temporary && context.unite__is_interactive
    1   0.000043   0.000009     let winnr = unite#helper#get_unite_winnr(context.buffer_name)
    1              0.000005     if winnr > 0 && unite#helper#get_source_args(a:sources) !=# getbufvar(winbufnr(winnr), 'unite').args
                                  " Quit unite buffer.
                                  execute winnr 'wincmd w'
                            
                                  if context.input == ''
                                    " Get input text.
                                    let context.input = unite#helper#get_input()
                                  endif
                            
                                  " Get winwidth.
                                  let context.winwidth = winwidth(0)
                            
                                  " Get winheight.
                                  let context.winheight = winheight(0)
                            
                                  call unite#force_quit_session()
                                endif
    1              0.000001   endif
                            
                              " The current buffer is initialized.
    1              0.000003   let buffer_name = '[unite] - '
    1              0.000003   let buffer_name .= context.buffer_name
                            
    1              0.000003   let winnr = winnr()
    1              0.000004   let win_rest_cmd = winrestcmd()
                            
                              " Check sources.
    1   0.034807   0.000010   let sources = unite#init#_loaded_sources(a:sources, a:context)
                            
                              " Set parameters.
    1              0.000002   let unite = {}
    1              0.000002   let unite.winnr = winnr
    1              0.000004   let unite.win_rest_cmd = (!context.unite__direct_switch) ? win_rest_cmd : ''
    1              0.000002   let unite.context = context
    1              0.000002   let unite.current_candidates = []
    1              0.000002   let unite.sources = sources
    1   0.000023   0.000006   let unite.source_names = unite#helper#get_source_names(sources)
    1              0.000004   let unite.buffer_name = (context.buffer_name == '') ? 'default' : context.buffer_name
    1              0.000008   let unite.profile_name = (context.profile_name != '') ? context.profile_name : (len(sources) == 1) ? 'source/' . sources[0].name : unite.buffer_name
    1              0.000004   let unite.prev_bufnr = bufnr('%')
    1              0.000002   let unite.prev_winnr = winnr()
    1              0.000002   let unite.update_time_save = &updatetime
    1              0.000003   let unite.statusline = '*unite* : %{unite#get_status_string()}'
                            
                              " Create new buffer name.
    1   0.000054   0.000007   let postfix = unite#helper#get_postfix( buffer_name, unite.context.create)
    1              0.000002   let unite.buffer_name .= postfix
                            
    1              0.000003   let unite.real_buffer_name = buffer_name . postfix
    1              0.000002   let unite.prompt = context.prompt
    1              0.000003   let unite.input = context.input
    1              0.000003   let unite.last_input = context.input
    1              0.000003   let unite.sidescrolloff_save = &sidescrolloff
    1              0.000002   let unite.prompt_linenr = 1
    1              0.000008   let unite.is_async = len(filter(copy(sources),  'v:val.unite__context.is_async')) > 0
    1              0.000003   let unite.access_time = localtime()
    1              0.000002   let unite.is_finalized = 0
    1              0.000002   let unite.previewd_buffer_list = []
    1   0.000058   0.000011   let unite.post_filters = unite#util#convert2list( unite#custom#get_profile(unite.profile_name, 'filters'))
    1              0.000002   let unite.preview_candidate = {}
    1              0.000002   let unite.highlight_candidate = {}
    1              0.000002   let unite.max_source_name = 0
    1              0.000002   let unite.candidates_pos = 0
    1              0.000002   let unite.candidates = []
    1              0.000002   let unite.max_source_candidates = 0
    1              0.000002   let unite.is_multi_line = 0
    1   0.000018   0.000006   let unite.args = unite#helper#get_source_args(a:sources)
    1              0.000002   let unite.msgs = []
    1              0.000002   let unite.err_msgs = []
    1   0.000018   0.000007   let unite.redraw_hold_candidates = (unite#util#has_lua() ? 20000 : 10000)
    1              0.000003   let unite.disabled_max_candidates = 0
    1              0.000003   let unite.cursor_line_time = reltime()
                            
    1              0.000001   if context.here
                                let context.winheight = winheight(0) - winline() + unite.prompt_linenr + 1
                                if context.winheight < 7
                                  let context.winheight = 7
                                endif
                              endif
                            
                              " Preview windows check.
    1              0.000011   let unite.has_preview_window = len(filter(range(1, winnr('$')),  'getwinvar(v:val, "&previewwindow")')) > 0
                            
    1   0.000019   0.000009   call unite#set_current_unite(unite)
    1   0.000062   0.000005   call unite#set_context(context)
                            
    1              0.000001   if !context.unite__is_complete
    1   0.006634   0.000011     call unite#helper#call_hook(sources, 'on_init')
    1              0.000003   endif
                            
    1              0.000004   return unite

FUNCTION  <SNR>81_IgnoreFile()
Called 106 times
Total time:   0.009149
 Self time:   0.009149

count  total (s)   self (s)
  106              0.005464     let fname = fnamemodify(a:filename, ':p')
  106              0.001288     for p in g:syntastic_ignore_files
                                    if fname =~# p
                                        return 1
                                    endif
                                endfor
  106              0.000281     return 0

FUNCTION  airline#extensions#branch#get_head()
Called 5469 times
Total time:   5.216986
 Self time:   0.091827

count  total (s)   self (s)
 5469   5.167233   0.042074   let head = airline#extensions#branch#head()
 5469              0.043125   return empty(head) ? s:empty_message : printf('%s%s', empty(s:symbol) ? '' : s:symbol.(g:airline_symbols.space), head)

FUNCTION  246()
Called 6 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    6              0.000029     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
    6              0.000013     return g:NERDTreeBookmarks

FUNCTION  280()
Called 1 time
Total time:   0.001733
 Self time:   0.000527

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
    1   0.000223   0.000007     if self.isRoot()
                                    return s:TreeFileNode.GetRootLineNum()
                                endif
                            
    1              0.000003     let totalLines = line("$")
                            
                                "the path components we have matched so far
    1   0.000082   0.000018     let pathcomponents = [substitute(b:NERDTreeRoot.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
    1              0.000002     let curPathComponent = 1
                            
    1   0.000067   0.000006     let fullpath = self.path.str({'format': 'UI'})
                            
                            
    1   0.000060   0.000006     let lnum = s:TreeFileNode.GetRootLineNum()
    9              0.000010     while lnum > 0
    9              0.000019         let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
    9              0.000016         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
    9              0.000024         let curLine = getline(lnum)
                            
    9   0.000254   0.000043         let indent = nerdtree#indentLevelFor(curLine)
    9              0.000017         if indent ==# curPathComponent
    9   0.000651   0.000051             let curLine = nerdtree#stripMarkupFromLine(curLine, 1)
                            
    9              0.000054             let curPath =  join(pathcomponents, '/') . '/' . curLine
    9              0.000029             if stridx(fullpath, curPath, 0) ==# 0
    5              0.000028                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
    5              0.000029                     let curLine = substitute(curLine, '/ *$', '', '')
    5              0.000025                     call add(pathcomponents, curLine)
    5              0.000015                     let curPathComponent = curPathComponent + 1
                            
    5              0.000009                     if fullpath ==# curPath
    1              0.000001                         return lnum
                                                endif
    4              0.000002                 endif
    4              0.000002             endif
    8              0.000004         endif
    8              0.000007     endwhile
                                return -1

FUNCTION  <SNR>38_sub()
Called 65706 times
Total time:   0.734363
 Self time:   0.734363

count  total (s)   self (s)
65706              0.684789   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  282()
Called 26 times
Total time:   0.018540
 Self time:   0.018540

count  total (s)   self (s)
   26              0.000144     let rootLine = 1
  804              0.009729     while getline(rootLine) !~# '^\(/\|<\)'
  778              0.005522         let rootLine = rootLine + 1
  778              0.002268     endwhile
   26              0.000101     return rootLine

FUNCTION  283()
Called 25 times
Total time:   0.252808
 Self time:   0.001521

count  total (s)   self (s)
   25              0.000150     try
   25   0.178251   0.000538         let path = nerdtree#getPath(line("."))
   17              0.000058         if path ==# {}
                                        return {}
                                    endif
   17   0.073774   0.000200         return b:NERDTreeRoot.findNode(path)
                                catch /^NERDTree/
    8              0.000043         return {}
                                endtry

FUNCTION  <SNR>48_str2coll()
Called 2 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    2              0.000029   let pat = escape(a:str, '\]^')
    2              0.000072   let pat = substitute(pat, '\m^\(.*\)-\(.*\)', '\1\2-', 'g')
    2              0.000017   let pat = '[' . pat . ']'
    2              0.000009   return pat

FUNCTION  ctrlp#utils#mkdir()
Called 5 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    5              0.000075 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    5              0.000012 	retu a:dir

FUNCTION  airline#extensions#ctrlp#apply()
Called 99 times
Total time:   0.001934
 Self time:   0.001934

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
   99              0.001646   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  indent_guides#process_autocmds()
Called 107 times
Total time:   0.008529
 Self time:   0.001808

count  total (s)   self (s)
  107              0.000405   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
  107   0.007327   0.000606     call indent_guides#disable()
  107              0.000124   end

FUNCTION  <SNR>191_vp_pty_open()
Called 1 time
Total time:   0.001923
 Self time:   0.000029

count  total (s)   self (s)
    1   0.001917   0.000023   let [pid; fdlist] = s:libcall('vp_pty_open', [a:npipe, a:width, a:height,  a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
    1              0.000006   return [pid] + fdlist

FUNCTION  airline#extensions#hunks#get_hunks()
Called 5469 times
Total time:   0.553584
 Self time:   0.220618

count  total (s)   self (s)
 5469              0.026818   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
 5469   0.376411   0.043445   let hunks = s:get_hunks()
 5469              0.014092   let string = ''
 5469              0.015873   if !empty(hunks)
                                for i in [0, 1, 2]
                                  if s:non_zero_only == 0 || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
                              endif
 5469              0.010596   return string

FUNCTION  g:SyntasticRefreshCursor()
Called 311 times
Total time:   0.479565
 Self time:   0.017979

count  total (s)   self (s)
  311              0.003692     if !exists('b:syntastic_messages') || empty(b:syntastic_messages)
                                    " file not checked
  129              0.000232         return
                                endif
                            
  182              0.001063     if !exists('b:oldLine')
                                    let b:oldLine = -1
                                endif
  182              0.001149     let l = line('.')
  182              0.000704     if l == b:oldLine
   29              0.000052         return
                                endif
  153              0.000702     let b:oldLine = l
                            
  153              0.001366     if has_key(b:syntastic_messages, l)
   45   0.462423   0.000837         call syntastic#util#wideMsg(b:syntastic_messages[l])
   45              0.000086     else
  108              0.002209         echo
  108              0.000226     endif

FUNCTION  <SNR>30_init()
Called 101 times
Total time:   0.005123
 Self time:   0.005123

count  total (s)   self (s)
  101              0.000570   if !s:airline_initialized
                                let s:airline_initialized = 1
                            
                                call airline#init#bootstrap()
                                call airline#extensions#load()
                                call airline#init#sections()
                            
                                let s:airline_theme_defined = exists('g:airline_theme')
                                if s:airline_theme_defined || !airline#switch_matching_theme()
                                  let g:airline_theme = get(g:, 'airline_theme', 'dark')
                                  call airline#switch_theme(g:airline_theme)
                                endif
                              endif

FUNCTION  <SNR>212_get_bufnr()
Called 2 times
Total time:   0.000138
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000136   0.000065   return has_key(a:candidate, 'action__buffer_nr') ? a:candidate.action__buffer_nr : bufnr(unite#util#escape_file_searching(     a:candidate.action__path))

FUNCTION  neobundle#util#substitute_path_separator()
Called 72 times
Total time:   0.000707
 Self time:   0.000707

count  total (s)   self (s)
   72              0.000588   return (s:is_windows && a:path =~ '\\') ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  292()
Called 1 time
Total time:   0.001766
 Self time:   0.000033

count  total (s)   self (s)
    1   0.001741   0.000008     let ln = self.getLineNum()
    1              0.000002     if ln != -1
    1              0.000001         if a:isJump
    1              0.000001             mark '
    1              0.000000         endif
    1              0.000004         call cursor(ln, col("."))
    1              0.000001     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && node.getLineNum() ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call nerdtree#renderView()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  295()
Called 6 times
Total time:   0.029189
 Self time:   0.000085

count  total (s)   self (s)
    6   0.029182   0.000078     return self._renderToString(0, 0, [], self.getChildCount() ==# 1)

FUNCTION  unite#helper#get_current_candidate()
Called 5 times
Total time:   0.000397
 Self time:   0.000178

count  total (s)   self (s)
    5              0.000039   let linenr = a:0 >= 1? a:1 : line('.')
    5   0.000164   0.000069   let num = linenr <= unite#get_current_unite().prompt_linenr ? 0 : linenr - (unite#get_current_unite().prompt_linenr+1)
                            
    5   0.000179   0.000055   return get(unite#get_unite_candidates(), num, {})

FUNCTION  <SNR>187_has_vimproc()
Called 3 times
Total time:   0.004531
 Self time:   0.000506

count  total (s)   self (s)
    3              0.000009   if !exists('s:exists_vimproc')
    1              0.000001     try
    1   0.004490   0.000465       call vimproc#version()
    1              0.000003       let s:exists_vimproc = 1
    1              0.000000     catch
                                  let s:exists_vimproc = 0
                                endtry
    1              0.000001   endif
    3              0.000004   return s:exists_vimproc

FUNCTION  unite#view#_remove_previewed_buffer_list()
Called 2 times
Total time:   0.000058
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000040   0.000009   let unite = unite#get_current_unite()
    2              0.000015   call filter(unite.previewd_buffer_list, 'v:val != a:bufnr')

FUNCTION  AutoPairsTryInit()
Called 55 times
Total time:   0.010090
 Self time:   0.002426

count  total (s)   self (s)
   55              0.000438   if exists('b:autopairs_loaded')
   48              0.000079     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted. 
                              " so always load AutoPairs at last
                              
                              " Buffer level keys mapping
                              " comptible with other plugin
    7              0.000016   if g:AutoPairsMapCR
    7              0.000076     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    7              0.000378       let info = maparg('<CR>', 'i', 0, 1)
    7              0.000027       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
    7              0.000030         let old_cr = info['rhs']
    7   0.000397   0.000081         let old_cr = s:ExpandMap(old_cr)
    7              0.000098         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
    7              0.000032         let is_expr = info['expr']
    7              0.000027         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    7              0.000010       endif
    7              0.000007     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
    7              0.000061     if old_cr !~ 'AutoPairsReturn'
    7              0.000016       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
    7              0.000373       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    7              0.000012     end
    7              0.000008   endif
    7   0.007418   0.000070   call AutoPairsInit()

FUNCTION  <SNR>81_CacheErrors()
Called 37 times
Total time:  26.566038
 Self time:   0.031126

count  total (s)   self (s)
   37   0.040068   0.000492     call s:ClearCache()
   37   0.005942   0.001280     let newLoclist = g:SyntasticLoclist.New([])
                            
   37   0.005921   0.000480     if !s:SkipFile()
   37              0.000247         let active_checkers = 0
   37              0.000165         let names = []
                            
   37   0.002148   0.000992         call syntastic#log#debugShowOptions(g:SyntasticDebugTrace, ['shell', 'shellcmdflag', 'shellxquote', 'shellredir', 'shellslash'])
   37   0.001555   0.000536         call syntastic#log#debugDump(g:SyntasticDebugVariables)
   37   0.001550   0.000634         call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'syntastic_aggregate_errors')
                            
   37              0.000706         let aggregate_errors = exists('b:syntastic_aggregate_errors') ? b:syntastic_aggregate_errors : g:syntastic_aggregate_errors
   37   0.002275   0.001195         let decorate_errors = (aggregate_errors || len(s:CurrentFiletypes()) > 1) && (exists('b:syntastic_id_checkers') ? b:syntastic_id_checkers : g:syntastic_id_checkers)
                            
   74   0.001587   0.000858         for ft in s:CurrentFiletypes()
   37   0.017769   0.001104             let clist = empty(a:checkers) ? s:registry.getActiveCheckers(ft) : s:registry.getCheckers(ft, a:checkers)
                            
   37              0.000222             for checker in clist
   32              0.000259                 let active_checkers += 1
   32   0.001899   0.000863                 call syntastic#log#debug(g:SyntasticDebugTrace, "CacheErrors: Invoking checker: " . checker.getName())
                            
   32  26.445576   0.001139                 let loclist = checker.getLocList()
                            
   32   0.001004   0.000549                 if !loclist.isEmpty()
   32              0.000287                     if decorate_errors
                                                    call loclist.decorate(checker.getName(), checker.getFiletype())
                                                endif
                            
   32   0.014830   0.002483                     let newLoclist = newLoclist.extend(loclist)
                            
   32   0.002351   0.001627                     call add(names, [checker.getName(), checker.getFiletype()])
                            
   32              0.000183                     if !aggregate_errors
   32              0.000131                         break
                                                endif
                                            endif
                                        endfor
   37              0.000096         endfor
                            
   37              0.000259         if !empty(names)
   32   0.004662   0.001605             if len(syntastic#util#unique(map(copy(names), 'v:val[1]'))) == 1
   32              0.000370                 let type = names[0][1]
   32              0.000884                 let name = join(map(names, 'v:val[0]'), ', ')
   32   0.001048   0.000646                 call newLoclist.setName( name . ' ('. type . ')' )
   32              0.000092             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(map(names, 'v:val[1] . "/" . v:val[0]'), ', '))
                                        endif
   32              0.000063         endif
                            
   37              0.000148         if !active_checkers
    5              0.000021             if !empty(a:checkers)
                                            if len(a:checkers) == 1
                                                call syntastic#log#warn('checker ' . a:checkers[0] . ' is not active for filetype ' . &filetype)
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checkers, ', ') . ' are not active for filetype ' . &filetype)
                                            endif
                                        else
    5   0.000181   0.000080                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: no active checkers for filetype ' . &filetype)
    5              0.000008             endif
    5              0.000006         endif
                            
   37   0.001855   0.000746         call syntastic#log#debug(g:SyntasticDebugLoclist, "aggregated:", newLoclist)
   37              0.000084     endif
                            
   37              0.000454     let b:syntastic_loclist = newLoclist

FUNCTION  unite#redraw()
Called 4 times
Total time:   0.001609
 Self time:   0.000106

count  total (s)   self (s)
    4   0.001603   0.000100   call unite#view#_redraw(0, get(a:000, 0, 0), get(a:000, 1, 0))

FUNCTION  <SNR>145_restore_statusline()
Called 95 times
Total time:   0.002639
 Self time:   0.002639

count  total (s)   self (s)
   95              0.001663   if &filetype !=# 'unite' || !g:unite_force_overwrite_statusline
   95              0.000428     return
                              endif
                            
                              let unite = unite#get_current_unite()
                            
                              if &l:statusline != unite.statusline
                                " Restore statusline.
                                let &l:statusline = unite.statusline
                              endif

FUNCTION  SyntasticStatuslineFlag()
Called 5477 times
Total time:   1.018169
 Self time:   0.758989

count  total (s)   self (s)
 5477   0.115603   0.043538     let loclist = g:SyntasticLoclist.current()
 5477   0.077800   0.036557     let issues = loclist.filteredRaw()
 5477   0.057260   0.034985     let num_issues = loclist.getLength()
 5477   0.074323   0.041422     if loclist.hasErrorsOrWarningsToDisplay()
 4134   0.071755   0.024439         let errors = loclist.errors()
 4134   0.067702   0.024322         let warnings = loclist.warnings()
                            
 4134              0.016545         let num_errors = len(errors)
 4134              0.015558         let num_warnings = len(warnings)
                            
 4134              0.013584         let output = g:syntastic_stl_format
                            
                                    "hide stuff wrapped in %E(...) unless there are errors
 4134              0.055606         let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %W(...) unless there are warnings
 4134              0.041982         let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %B(...) unless there are both errors and warnings
 4134              0.041041         let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                            
                                    "sub in the total errors/warnings/both
 4134              0.034075         let output = substitute(output, '\m\C%w', num_warnings, 'g')
 4134              0.030739         let output = substitute(output, '\m\C%e', num_errors, 'g')
 4134              0.035610         let output = substitute(output, '\m\C%t', num_issues, 'g')
                            
                                    "first error/warning line num
 4134              0.045620         let output = substitute(output, '\m\C%F', num_issues ? issues[0]['lnum'] : '', 'g')
                            
                                    "first error line num
 4134              0.039468         let output = substitute(output, '\m\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                    "first warning line num
 4134              0.033312         let output = substitute(output, '\m\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
 4134              0.007986         return output
                                else
 1343              0.001510         return ''
                                endif

FUNCTION  unite#action#get_action_table()
Called 18 times
Total time:   0.118963
 Self time:   0.053026

count  total (s)   self (s)
   18              0.000125   let is_parents_action = get(a:000, 0, 0)
   18              0.000109   let source_table = get(a:000, 1, {})
                            
   18              0.000056   let action_table = {}
   38   0.000351   0.000206   for kind_name in unite#util#convert2list(a:kind)
   20   0.051484   0.038417     call extend(action_table, s:get_action_table(a:source_name,                kind_name, a:self_func,                is_parents_action, source_table))
   20              0.000030   endfor
                            
   18              0.000036   return action_table

FUNCTION  <SNR>186_load()
Called 3 times
Total time:   0.014123
 Self time:   0.000342

count  total (s)   self (s)
    6              0.000015   for arg in a:000
    3              0.000024     let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
    3              0.000022     let target = split(join(as, ''), '\W\+')
    3              0.000007     let dict = self
    5              0.000012     while 1 <= len(target)
    2              0.000008       let ns = remove(target, 0)
    2              0.000005       if !has_key(dict, ns)
    2              0.000005         let dict[ns] = {}
    2              0.000002       endif
    2              0.000006       if type(dict[ns]) == type({})
    2              0.000004         let dict = dict[ns]
    2              0.000002       else
                                    unlet dict
                                    break
                                  endif
    2              0.000001     endwhile
                            
    3              0.000007     if exists('dict')
    3   0.013848   0.000067       call extend(dict, s:_import(name))
    3              0.000003     endif
    3              0.000006     unlet arg
    3              0.000004   endfor
    3              0.000004   return self

FUNCTION  <SNR>48_next_char()
Called 2 times
Total time:   0.001341
 Self time:   0.000668

count  total (s)   self (s)
    2              0.000028   if a:fwd < 0 && !exists('s:ff')
                                return [0,0]
                              endif
    2              0.000011   if g:fanfingtastic_use_jumplist
                                normal! m'
                              endif
    2              0.000028   let s:ffwd = a:fwd < 0 ? s:ffwd : a:fwd
    2              0.000023   let fwd = a:fwd >= 0 ? s:ffwd : (a:fwd == -1 ? s:ffwd : !s:ffwd)
    2              0.000013   let s:ff = a:f
    2   0.000202   0.000065   call s:set_find_char(a:char, a:f, a:fwd)
    2              0.000021   if a:f ==? 'f' || g:fanfingtastic_fix_t
    2              0.000017     let ccount = a:count
    2              0.000005   else
                                " This replicates t/T/; + count behaviour.
                                let is_t_repeat = a:fwd < 0
                                if a:f ==# 't' && (a:fwd == 1 || a:fwd == -1) || a:f ==# 'T' && a:fwd == -2
                                  " Search forward.
                                  let pat = '\_.\ze'.s:str2coll(s:fchar)
                                  let flags = 'cWn'
                                else
                                  " Or not.
                                  let pat = s:str2coll(s:fchar).'\zs\_.'
                                  let flags = 'cWnb'
                                endif
                            
                                let is_on_one = getpos('.')[1:2] == searchpos(pat, flags, line('.'))
                                if a:count == 1 && is_on_one && (!is_t_repeat || is_t_repeat && &cpo =~ ';')
                                  return [0,0]
                                endif
                                if a:count > 1 && a:fwd == -1
                                  " Case 1 ';'
                                  let ccount = is_on_one ? a:count - 1 : a:count
                                elseif a:count > 1 && a:fwd == -2
                                  " Case 2 ','
                                  let ccount = a:count
                                elseif a:count > 1 && a:fwd
                                  " Case 3 't'
                                  let ccount = is_on_one ? a:count - 1 : a:count
                                elseif a:count > 1 && !a:fwd
                                  " Case 4 'T'
                                  let ccount = is_on_one ? a:count - 1 : a:count
                                else
                                  let ccount = a:count
                                endif
                              endif
                            
    2   0.000621   0.000085   return s:next_char_pos(ccount, a:f =~? 'f', fwd)

FUNCTION  vital#of()
Called 1 time
Total time:   0.019197
 Self time:   0.000364

count  total (s)   self (s)
    1              0.000250   let files = globpath(&runtimepath, 'autoload/vital/' . a:name . '.vital')
    1              0.000006   let file = split(files, "\n")
    1              0.000002   if empty(file)
                                throw 'vital: version file not found: ' . a:name
                              endif
    1              0.000026   let ver = readfile(file[0], 'b')
    1              0.000003   if empty(ver)
                                throw 'vital: invalid version file: ' . a:name
                              endif
    1   0.018901   0.000068   return vital#_{substitute(ver[0], '\W', '', 'g')}#new()

FUNCTION  neosnippet#mappings#expandable_or_jumpable()
Called 17 times
Total time:   0.048607
 Self time:   0.000632

count  total (s)   self (s)
   17   0.048558   0.000583   return neosnippet#mappings#expandable() || neosnippet#mappings#jumpable()

FUNCTION  airline#util#prepend()
Called 7697 times
Total time:   0.087811
 Self time:   0.087811

count  total (s)   self (s)
 7697              0.026874   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 7697              0.036940   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  unite#helper#get_input()
Called 4 times
Total time:   0.000403
 Self time:   0.000295

count  total (s)   self (s)
    4   0.000157   0.000049   let unite = unite#get_current_unite()
                              " Prompt check.
    4              0.000058   if stridx(getline(unite.prompt_linenr), unite.prompt) != 0
                                let modifiable_save = &l:modifiable
                                setlocal modifiable
                            
                                " Restore prompt.
                                call setline(unite.prompt_linenr, unite.prompt . getline(unite.prompt_linenr))
                            
                                let &l:modifiable = modifiable_save
                              endif
                            
    4              0.000055   return getline(unite.prompt_linenr)[len(unite.prompt):]

FUNCTION  <SNR>191_vp_pipe_read()
Called 2 times
Total time:   0.012794
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000008   if self.fd == 0
                                return ['', 1]
                              endif
                            
    2   0.012754   0.000053   let [hd, eof] = s:libcall('vp_pipe_read', [self.fd, a:number, a:timeout])
    2              0.000016   return [hd, eof]

FUNCTION  360()
Called 1 time
Total time:   0.000075
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000005   for candidate in a:context.candidates
    1              0.000006     let candidate.kind = [((a:context.source__ssh_path != '') ? 'file/ssh' : 'file'), 'jump_list']
    1   0.000051   0.000008     let candidate.action__directory = unite#util#path2directory(candidate.action__path)
    1              0.000002     let candidate.is_multiline = 1
    1              0.000001   endfor

FUNCTION  unite#util#iconv()
Called 4 times
Total time:   0.000189
 Self time:   0.000047

count  total (s)   self (s)
    4   0.000187   0.000045   return call(unite#util#get_vital().iconv, a:000)

FUNCTION  <SNR>191_vp_kill()
Called 1 time
Total time:   0.000409
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000007   let sig = get(a:000, 0, g:vimproc#SIGTERM)
    1              0.000002   if sig != 0
    1   0.000083   0.000007     call s:close_all(self)
    1              0.000002     let self.is_valid = 0
    1              0.000001   endif
                            
    1              0.000002   let ret = 0
    2              0.000009   for pid in get(self, 'pid_list', [self.pid])
    1   0.000288   0.000010     let ret = vimproc#kill(pid, sig)
    1              0.000002   endfor
                            
    1              0.000002   return ret

FUNCTION  neobundle#util#get_filetypes()
Called 8 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    8              0.000065   let filetype = exists('b:neocomplcache.context_filetype') ? b:neocomplcache.context_filetype : &filetype
    8              0.000057   return split(filetype, '\.')

FUNCTION  nerdtree#treeMarkupReg()
Called 600 times
Total time:   0.005640
 Self time:   0.005640

count  total (s)   self (s)
  600              0.002242     if g:NERDTreeDirArrows
  600              0.002482         return '^\([] \| \+[] \| \+\)'
                                endif
                            
                                return '^[ `|]*[\-+~]'

FUNCTION  <SNR>81_ClearCache()
Called 37 times
Total time:   0.039576
 Self time:   0.006029

count  total (s)   self (s)
   37   0.034782   0.001235     call s:notifiers.reset(g:SyntasticLoclist.current())
   37              0.004642     unlet! b:syntastic_loclist

FUNCTION  <SNR>168_get_sources_filetypes()
Called 17 times
Total time:   0.000962
 Self time:   0.000962

count  total (s)   self (s)
   17              0.000716   let filetypes = exists('*neocomplete#get_source_filetypes') ?   neocomplete#get_source_filetypes(a:filetype) : exists('*neocomplcache#get_source_filetypes') ?   neocomplcache#get_source_filetypes(a:filetype) :   [(a:filetype == '') ? 'nothing' : a:filetype]
   17              0.000184   return filetypes + ['_']

FUNCTION  unite#view#_set_highlight()
Called 1 time
Total time:   0.000637
 Self time:   0.000238

count  total (s)   self (s)
    1   0.000031   0.000008   let unite = unite#get_current_unite()
                            
                              " Set highlight.
    1              0.000005   let match_prompt = escape(unite.prompt, '\/*~.^$[]')
    1              0.000003   silent! syntax clear uniteInputPrompt
    1              0.000009   execute 'syntax match uniteInputPrompt' '/^'.match_prompt.'/ contained'
                            
    1   0.000035   0.000011   let marked_icon = unite#util#escape_pattern(g:unite_marked_icon)
    1              0.000011   execute 'syntax region uniteMarkedLine start=/^'. marked_icon.'/ end=''$'' keepend'
                            
    1   0.000025   0.000008   let candidate_icon = unite#util#escape_pattern(g:unite_candidate_icon)
    1              0.000019   execute 'syntax region uniteNonMarkedLine start=/^'. candidate_icon.' / end=''$'' keepend'. ' contains=uniteCandidateMarker,'. 'uniteCandidateSourceName,uniteCandidateAbbr'
    1              0.000007   execute 'syntax match uniteCandidateMarker /^'. candidate_icon.' / contained'
                            
    1              0.000020   execute 'syntax match uniteInputLine' '/\%'.unite.prompt_linenr.'l.*/' 'contains=uniteInputPrompt,uniteInputPromptError,'. 'uniteInputCommand'
                            
    1              0.000003   silent! syntax clear uniteCandidateSourceName
    1              0.000003   if unite.max_source_name > 0
                                syntax match uniteCandidateSourceName /\%3c[[:alnum:]_\/-]\+/ contained
                              else
    1              0.000009     execute 'syntax match uniteCandidateSourceName /^'. candidate_icon.' / contained'
    1              0.000001   endif
                            
    1              0.000009   execute 'highlight default link uniteCandidateAbbr' g:unite_abbr_highlight
                            
                              " Set syntax.
    2              0.000012   for source in filter(copy(unite.sources), 'v:val.syntax != ""')
    1              0.000005     let name = unite.max_source_name > 0 ? unite#helper#convert_source_name(source.name) : ''
                            
    1              0.000012     execute 'highlight default link' source.syntax g:unite_abbr_highlight
                            
    1              0.000024     execute printf('syntax match %s "^['.g:unite_candidate_icon.' ] %s" '. 'nextgroup='.source.syntax. ' keepend contains=uniteCandidateMarker,%s', 'uniteSourceLine__'.source.syntax, (name == '' ? '' : name . '\>'), (name == '' ? '' : 'uniteCandidateSourceName') )
                            
    1   0.000249   0.000008     call unite#helper#call_hook([source], 'on_syntax')
    1              0.000001   endfor
                            
    1   0.000103   0.000009   call s:set_syntax()

FUNCTION  <SNR>86_Highlight_Matching_Pair()
Called 2644 times
Total time:   0.638984
 Self time:   0.638984

count  total (s)   self (s)
                              " Remove any previous match.
 2644              0.035763   if exists('w:paren_hl_on') && w:paren_hl_on
  367              0.001694     3match none
  367              0.002087     let w:paren_hl_on = 0
  367              0.000655   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
 2644              0.028244   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
 2644              0.020261   let c_lnum = line('.')
 2644              0.015126   let c_col = col('.')
 2644              0.008237   let before = 0
                            
 2644              0.027981   let c = getline(c_lnum)[c_col - 1]
 2644              0.061408   let plist = split(&matchpairs, '.\zs[:,]')
 2644              0.020826   let i = index(plist, c)
 2644              0.006688   if i < 0
                                " not found, in Insert mode try character before the cursor
 2313              0.018141     if c_col > 1 && (mode() == 'i' || mode() == 'R')
 1864              0.007194       let before = 1
 1864              0.015444       let c = getline(c_lnum)[c_col - 2]
 1864              0.011188       let i = index(plist, c)
 1864              0.003175     endif
 2313              0.004615     if i < 0
                                  " not found, nothing to do
 2267              0.004788       return
                                endif
   46              0.000038   endif
                            
                              " Figure out the arguments for searchpairpos().
  377              0.000830   if i % 2 == 0
   20              0.000087     let s_flags = 'nW'
   20              0.000154     let c2 = plist[i + 1]
   20              0.000040   else
  357              0.001110     let s_flags = 'nbW'
  357              0.001039     let c2 = c
  357              0.001945     let c = plist[i - 1]
  357              0.000509   endif
  377              0.001090   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  377              0.000791   if before > 0
   46              0.000270     let save_cursor = winsaveview()
   46              0.000246     call cursor(c_lnum, c_col - before)
   46              0.000043   endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
  377              0.002830   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
  377              0.074298   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
  377              0.002713   let stoplinebottom = line('w$')
  377              0.001993   let stoplinetop = line('w0')
  377              0.000966   if i % 2 == 0
   20              0.000107     let stopline = stoplinebottom
   20              0.000035   else
  357              0.001269     let stopline = stoplinetop
  357              0.000412   endif
                            
  377              0.000831   try
                                " Limit the search time to 300 msec to avoid a hang on very long lines.
                                " This fails when a timeout is not supported.
  377              0.085532     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 300)
  377              0.001153   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  377              0.000868   if before > 0
   46              0.000234     call winrestview(save_cursor)
   46              0.000047   endif
                            
                              " If a match is found setup match highlighting.
  377              0.002062   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  367              0.014789     exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
  367              0.001570     let w:paren_hl_on = 1
  367              0.000505   endif

FUNCTION  nerdtree#runningWindows()
Called 2071 times
Total time:   0.020114
 Self time:   0.020114

count  total (s)   self (s)
 2071              0.018898     return has("win16") || has("win32") || has("win64")

FUNCTION  Preserve()
Called 2 times
Total time:   0.033383
 Self time:   0.001361

count  total (s)   self (s)
                                " preparation: save last search, and cursor position.
    2              0.000034     let _s=@/
    2              0.000028     let l = line(".")
    2              0.000018     let c = col(".")
                                " do the business:
    2   0.033239   0.001217     execute a:command
                                " clean up: restore previous search history, and cursor position
    2              0.000025     let @/=_s
    2              0.000010     call cursor(l, c)

FUNCTION  vimproc#parser#parse_pipe()
Called 1 time
Total time:   0.003398
 Self time:   0.000110

count  total (s)   self (s)
    1              0.000004   let commands = []
    2   0.000912   0.000011   for cmdline in vimproc#parser#split_pipe(a:statement)
                                " Split args.
    1   0.001270   0.000010     let cmdline = s:parse_cmdline(cmdline)
                            
                                " Parse redirection.
    1              0.000006     if cmdline =~ '[<>]'
                                  let [fd, cmdline] = s:parse_redirection(cmdline)
                                else
    1              0.000004       let fd = { 'stdin' : '', 'stdout' : '', 'stderr' : '' }
    1              0.000001     endif
                            
    3              0.000005     for key in ['stdout', 'stderr']
    2              0.000005       if fd[key] == '' || fd[key] =~ '^>'
    2              0.000004         continue
                                  endif
                            
                                  if fd[key] ==# '/dev/clip'
                                    " Clear.
                                    let @+ = ''
                                  elseif fd[key] ==# '/dev/quickfix'
                                    " Clear quickfix.
                                    call setqflist([])
                                  endif
                                endfor
                            
    1   0.001140   0.000013     call add(commands, { 'args' : vimproc#parser#split_args(cmdline), 'fd' : fd})
    1              0.000000   endfor
                            
    1              0.000001   return commands

FUNCTION  <SNR>191_garbage_collect()
Called 126 times
Total time:   0.009610
 Self time:   0.009610

count  total (s)   self (s)
  126              0.001369   for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, status] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, status])
                                  if cond !=# 'run' || a:is_force
                                    if cond !=# 'exit'
                                      " Kill process.
                                      call vimproc#kill(pid, g:vimproc#SIGTERM)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor

FUNCTION  vimproc#util#is_windows()
Called 6 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    6              0.000013   return s:is_windows

FUNCTION  364()
Called 1 time
Total time:   0.001018
 Self time:   0.000495

count  total (s)   self (s)
    1              0.000002   if a:context.input == ''
    1   0.001015   0.000492     return unite#filters#filter_matcher( a:candidates, '', a:context)
                              endif
                            
                              let candidates = a:candidates
                              for input in a:context.input_list
                                let a:context.input = input
                                let candidates = unite#filters#matcher_regexp#regexp_matcher( candidates, input, a:context)
                              endfor
                            
                              return candidates

FUNCTION  <SNR>81_BufWritePostHook()
Called 36 times
Total time:  26.561352
 Self time:   0.002988

count  total (s)   self (s)
   36   0.003630   0.002016     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufWritePost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
   36  26.557329   0.000579     call s:UpdateErrors(1)

FUNCTION  unite#variables#use_current_unite()
Called 202 times
Total time:   0.000887
 Self time:   0.000887

count  total (s)   self (s)
  202              0.000685   return s:use_current_unite

FUNCTION  unite#view#_print_message()
Called 2 times
Total time:   0.021096
 Self time:   0.000128

count  total (s)   self (s)
    2   0.000076   0.000012   let context = unite#get_context()
    2              0.000006   if get(context, 'silent', 0)
                                return
                              endif
                            
    2   0.000038   0.000010   let unite = unite#get_current_unite()
    2   0.000021   0.000012   let message = s:msg2list(a:message)
    2              0.000004   if !empty(unite)
    2              0.000005     let unite.msgs += message
    2              0.000001   endif
    2   0.020934   0.000067   echohl Comment | call s:redraw_echo(message) | echohl None

FUNCTION  unite#sources#history_yank#_append()
Called 404 times
Total time:   0.071680
 Self time:   0.039226

count  total (s)   self (s)
  404              0.006371   let prev_histories = s:yank_histories
                            
  404   0.022564   0.005163   call s:load()
                            
  404   0.020087   0.005034   call s:add_register('"')
                            
  404              0.001787   if g:unite_source_history_yank_save_clipboard
                                call s:add_register('+')
                              endif
                            
  404              0.001902   if prev_histories !=# s:yank_histories
                                " Updated.
                            
                                call unite#util#uniq(s:yank_histories)
                            
                                if g:unite_source_history_yank_limit < len(s:yank_histories)
                                  let s:yank_histories = s:yank_histories[ : g:unite_source_history_yank_limit - 1]
                                endif
                            
                                call s:save()
                              endif

FUNCTION  unite#kinds#common#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:kind

FUNCTION  unite#remove_previewed_buffer_list()
Called 2 times
Total time:   0.000073
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000071   0.000013   return unite#view#_remove_previewed_buffer_list(a:bufnr)

FUNCTION  unite#util#sort_by()
Called 3 times
Total time:   0.000536
 Self time:   0.000109

count  total (s)   self (s)
    3   0.000531   0.000104   return call(s:get_list().sort_by, a:000)

FUNCTION  <SNR>205_extend_actions()
Called 38 times
Total time:   0.005284
 Self time:   0.002674

count  total (s)   self (s)
   38   0.003017   0.000407   let filterd_table = s:filter_self_func(a:action_table2, a:self_func)
                            
   38              0.000089   if a:0 > 0
  212              0.000459     for action in values(filterd_table)
  190              0.000586       let action.from = a:1
  190              0.000282     endfor
   22              0.000024   endif
                            
   38              0.000429   return extend(a:action_table1, filterd_table, 'keep')

FUNCTION  <SNR>29_Match_wrapper()
Called 11 times
Total time:   0.026466
 Self time:   0.018495

count  total (s)   self (s)
                              " In s:CleanUp(), :execute "set" restore_options .
   11              0.000344   let restore_options = (&ic ? " " : " no") . "ignorecase"
   11              0.000109   if exists("b:match_ignorecase")
                                let &ignorecase = b:match_ignorecase
                              endif
   11              0.000146   let restore_options = " ve=" . &ve . restore_options
   11              0.000214   set ve=
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
   11              0.000064   if a:mode == "v"
                                execute "normal! gv\<Esc>"
                              endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
   11              0.000094   let startline = line(".")
   11              0.000078   let startcol = col(".")
                              " Use default behavior if called with a count.
   11              0.000036   if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
   11              0.000122   if !exists("b:match_words") || b:match_words == ""
   11              0.000064     let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
   11              0.000038   elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
   11              0.000302   if (match_words != s:last_words) || (&mps != s:last_mps) || exists("b:match_debug")
                                let s:last_words = match_words
                                let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
                                let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") . '\/\*:\*\/,#if\%(def\)\=:#else\>:#elif\>:#endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
                                let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
   11              0.000106   let matchline = getline(startline)
   11              0.000051   if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
   11   0.001590   0.000245     let regexp = s:Wholematch(matchline, s:all, startcol-1)
   11              0.000584     let curcol = match(matchline, regexp)
                                " If there is no match, give up.
   11              0.000050     if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
   11              0.000541     let endcol = matchend(matchline, regexp)
   11              0.000115     let suf = strlen(matchline) - endcol
   11              0.000113     let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
   11              0.000086     let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
   11              0.000022   endif
   11              0.000073   if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Reconstruct the version with unresolved backrefs.
   11              0.000418   let patBR = substitute(match_words.',', s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
   11              0.000304   let patBR = substitute(patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
   11   0.004663   0.000378   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
   11              0.000277   let i = matchend(group, s:notslash . ",")
   11              0.000148   let groupBR = strpart(group, i)
   11              0.000116   let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
   11              0.000042   if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
   11              0.000072   if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
   11              0.000225   let i = matchend(group, s:notslash . ":")
   11              0.000272   let j = matchend(group, '.*' . s:notslash . ":")
   11              0.000123   let ini = strpart(group, 0, i-1)
   11              0.000287   let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
   11              0.000093   let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
   11              0.000252   let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
   11              0.000226   let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
   11              0.000218   let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
   11              0.000206   let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
   11              0.000194   let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
   11              0.000194   let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
   11              0.000253   if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline =~ prefix . ini . suffix
   10              0.000041     let mid = ""
   10              0.000019   endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
   11              0.000206   if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline !~ prefix . ini . suffix
   10              0.000052     let flag = "bW"
   10              0.000022   else
    1              0.000006     let flag = "W"
    1              0.000002   endif
                              " Set skip.
   11              0.000077   if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
   11              0.000051     let skip = 's:comment\|string'
   11              0.000021   endif
   11   0.001039   0.000233   let skip = s:ParseSkip(skip)
   11              0.000070   if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
   11              0.000138   let restore_cursor = virtcol(".") . "|"
   11              0.000222   normal! g0
   11              0.000199   let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
   11              0.000208   normal! H
   11              0.000150   let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
   11              0.000416   execute restore_cursor
   11              0.000133   call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
   11              0.000295   if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
                              else
   11              0.001291     execute "if " . skip . "| let skip = '0' | endif"
   11              0.000022   endif
   11              0.001583   let sp_return = searchpair(ini, mid, fin, flag, skip)
   11              0.000194   let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
   11              0.000485   execute restore_cursor
   11              0.000095   normal! m'
   11              0.000054   if sp_return > 0
   11              0.000131     execute final_position
   11              0.000022   endif
   11   0.001819   0.000284   return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)

FUNCTION  nerdtree#closeTree()
Called 3 times
Total time:   0.035128
 Self time:   0.000774

count  total (s)   self (s)
    3   0.000431   0.000031     if !nerdtree#isTreeOpen()
                                    throw "NERDTree.NoTreeFoundError: no NERDTree is open"
                                endif
                            
    3              0.000071     if winnr("$") != 1
    3   0.000452   0.000055         if winnr() == nerdtree#getTreeWinNum()
    1   0.000375   0.000017             call nerdtree#exec("wincmd p")
    1              0.000013             let bufnr = bufnr("")
    1   0.000286   0.000016             call nerdtree#exec("wincmd p")
    1              0.000003         else
    2              0.000020             let bufnr = bufnr("")
    2              0.000005         endif
                            
    3   0.002137   0.000100         call nerdtree#exec(nerdtree#getTreeWinNum() . " wincmd w")
    3   0.031097   0.000287         close
    3   0.000109   0.000027         call nerdtree#exec(bufwinnr(bufnr) . " wincmd w")
    3              0.000002     else
                                    close
                                endif

FUNCTION  airline#builder#new()
Called 2543 times
Total time:   0.138166
 Self time:   0.138166

count  total (s)   self (s)
 2543              0.025816   let builder = copy(s:prototype)
 2543              0.012279   let builder._context = a:context
 2543              0.007932   let builder._side = 1
 2543              0.007456   let builder._curgroup = ''
 2543              0.006380   let builder._line = ''
                            
 2543              0.060647   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
 2543              0.006531   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   37  27.313645   0.009386  <SNR>81_UpdateErrors()
   37  26.566038   0.031126  <SNR>81_CacheErrors()
   36  26.561352   0.002988  <SNR>81_BufWritePostHook()
   32  26.444437   0.009076  38()
   32  26.416113   0.032165  SyntaxCheckers_java_javac_GetLocList()
   32  25.989263   0.112076  SyntasticMake()
17561   6.918519   0.882579  <SNR>109_exec_separator()
 2376   6.734259   0.068763  airline#extensions#tabline#get()
 2376   6.665496   0.585509  <SNR>107_get_tabs()
12817   6.539348   1.639008  123()
 7979   5.606838   0.845211  airline#check_mode()
 5469   5.216986   0.091827  airline#extensions#branch#get_head()
35122   5.125592   0.326736  airline#themes#get_highlight()
 5469   5.125159   0.453025  airline#extensions#branch#head()
10274   4.900340   0.242403  airline#highlighter#add_separator()
35122   4.798856   1.354494  airline#highlighter#get_highlight()
  200   4.737818   1.324220  airline#highlighter#highlight()
 5474   4.609558   0.375884  fugitive#detect()
 5474   4.233674   2.762630  fugitive#extract_git_dir()
70244   2.891816             <SNR>109_get_syn()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
70244              2.891816  <SNR>109_get_syn()
 5474   4.233674   2.762630  fugitive#extract_git_dir()
44143              2.076697  airline#highlighter#exec()
12817   6.539348   1.639008  123()
35122   4.798856   1.354494  airline#highlighter#get_highlight()
  200   4.737818   1.324220  airline#highlighter#highlight()
17561   6.918519   0.882579  <SNR>109_exec_separator()
 7979   5.606838   0.845211  airline#check_mode()
 4752   0.953744   0.840854  airline#extensions#tabline#formatters#default()
 5477   1.018169   0.758989  SyntasticStatuslineFlag()
65706              0.734363  <SNR>38_sub()
 2644              0.638984  <SNR>86_Highlight_Matching_Pair()
32853   0.954625   0.596331  fugitive#is_git_dir()
 2376   6.665496   0.585509  <SNR>107_get_tabs()
35122              0.552546  <SNR>109_get_array()
   53   0.510157   0.467635  114()
   46              0.457501  <SNR>82_doRedraw()
 5469   5.125159   0.453025  airline#extensions#branch#head()
48459              0.405056  airline#util#wrap()
 5477              0.393687  airline#extensions#whitespace#check()

